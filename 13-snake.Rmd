# Snake game {#seminar-02-01}

Welcome back! The purpose of today's seminar to refresh your knowledge of Python acquired previously. We will use dictionaries and lists, as well as conditional statements and loops. Plus, you will need to write functions.^[Sneaky preview: You will start learning about object-oriented programming during our next seminar and  we will turn it into object-based game.]

## Assignments

For this and following projects, use Python IDE of your choice (I would recommend [Visual Studio Code](#install-vs-code)). You still could and should use Jupyter for playing with and testing small code snippets, though. I've added a section on setting up [debugging in VS Code](#debug-in-vs-code) in [Getting Started](#getting-started), take a look once you are ready to run the code.

From now on, create a separate subfolder for each seminar (e.g. _Seminar 01_ for today) and create a separate file (or files, later on) for each exercise^[You can "Save as..." the previous exercise to avoid copy-pasting things by hand.] (e.g., _exercise01.py_, _exercise02.py_, etc.). This is not the most efficient implementation of a version control and will certainly clutter the folder. But it would allow me to see your solutions on every step, which will make it easier for me to comment on them. For submitting the assignment, just zip the folder and upload the zip-file.

## Snake

Today, we will program a good old classic: the snake game! The story is simple: you control a snake trying to eat as many apples as you can. Every time you consume an apple, snake's length increases. However, if you hit the wall or bite yourself, the game is over (or you lose one of your lives and game is over once you run out of lives).

As before, we will program the game step by step, starting with an empty gray PsychoPy window. Here is the general outline of how we will proceed:

1. Create boilerplate code to initialize PsychoPy.
2. Figure out how to place a square. We need this because our snake is made of square segments and lives on a rectangular grid made of squares.
3. Create a single segment stationary snake^[Not very exciting, I know. But one has to start somewhere!].
3. Make a single segment stationary snake move assuming a rectangular grid. Implement "died by hitting a wall".
4. Add apples and make the snake grow.
5. Add check for biting itself.
6. Add bells-and-whistles to make game look awesome.

As you can see, each new steps builds upon the previous one. Because of that, remember, do not proceed to the next step until the current one works and you fully(!) understand what each line of code does. Any leftover uncertainty will linger, grow and complicate your life disproportionately!

## Initializing PsychoPy

To remind yourself on how you initialize PsychoPy window, see [here](#seminar08). Let us plan ahead and decide on windows size and its units. Recall that PsychoPy has [five different units](#psychopy-units) for size and position. Given that our snake will be composed of square segments and move on a grid made out of squares, which units should we pick? Read on [units](#psychopy-units) and think which units you would pick before continuing

---

My suggestion would be `"height"` units as they make sizing squares easy. Next, let us think about the grid. We can define its width and height in _squares_, e.g., a 30 × 20 grid should give us enough space to try things out. Create a [constant]() `GRID_SIZE` and assign a [tuple](https://docs.python.org/3/tutorial/datastructures.html#tuples-and-sequences) of `(width, height)` to it. Note that window's aspect ratio will depend on the size of the grid that we pick. Want to have a square one, use a 30 × 30 grid.

We also need to _define_ an _absolute_ size of a square in pixels (call the constant `SQUARE_SIZE_PIX`), which will determine how large each square will look on the screen and, therefore, will determine the size of the window that we will open: $window~height = window~height~in~squares * square~size~in~pixels$ (same goes for the width). Note that this parameter determines how the game looks, double the size of the square in pixels and that will double both width and height of the window. 

Put it all together. You could should look roughly as follows:
```python
import all libraries and modules you need

define constants GRID_SIZE and SQUARE_SIZE_PIX

create PsychoPy window, computing it size in pixels from the two constants

wait for any key press (just so that window stays on the screen)

close PsychoPy window
```

Experiment with different grid and square sizes and pick the one that fits your screen.

::: {.infobox .program}
Put your code into _exercise01.py_.
:::

## Adding a square
As I already wrote, our game will be made of squares. Snake is made of squares. Grid it lives on is made of squares. Which means we need to know the size of that square in the units of the window and we need to know _where_ should each square go in the window, based on its coordinates on the grid.

Computing the size of the square in units of window size is easy, so let us start with it first. If you used `"height"` units for the PsychoPy window, we know that its height goes from -1 to 1. We also know that we have to fit in `GRID_SIZE[1]` squares vertically (recall that `GRID_SIZE` defines the size of our grid in number of squares). Create a new constant (`SQUARE_SIZE`) and compute square size in units of `"height"` based on total height of the window in the `"height"` units (not the pixels!) and number of squares we need to fit in vertically.

Next, let us create a function that translates position on the grid to the position in the window. This way, we can think in terms of the grid position but draw in the window coordinates. Create a new file _utilities.py_ and create a function `grid_to_win` that takes a tuple of integers `(x_index, y_index)` with grid position plus a second parameter with a square size (that we just computed) and returns a tuple of floats `(x_pos, y_pos)` with the coordinates of the _center_ of the square within the window. Take a look at the drawing below to see the logic of the computation.


I suggest using Jupyter notebook to create and debug this function and then copying it into _utilities.py_. Remember to document the function following [NumPy docstring format](https://numpydoc.readthedocs.io/en/latest/format.html).

::: {.infobox .program}
Put function grid_to_win into _utilities.py_.
:::

Now, test this function by creating a square and placing it at different locations of the grid. Check [here](#seminar08-add-square), if you forgot how to create squares in PsychoPy. Run the code several times, using different grid indexes and checking that visuals work as intended. Your code should look roughly as follows

```python
import all libraries and modules you need

import grid_to_win function from utilities.py file

define constants GRID_SIZE and SQUARE_SIZE_PIX
compute SQUARE_SIZE constant

create PsychoPy window, computing it size in pixels from the two constants

create a square (Rect stimulus) with size of SQUARE_SIZE and position computed
via grid_to_win function from a pair of grid coordinates

draw square and flip the window

wait for any key press (just so that window stays on the screen)

close PsychoPy window
```

::: {.infobox .program}
Put your code into _exercise02.py_.
:::


