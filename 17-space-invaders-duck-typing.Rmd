# Space invaders: mixins and duck typing {#seminar-02-05}

Today we will program a classic Space Invaders game with a twist. We will be using object-oriented programming but you will learn about _mixins_ and _duck typing_. Previously, you have learned how to ensure generalization --- common behavior for different classes --- via inheritance. E.g., when all visual stimuli inherit from the save `BaseVisualStim` class, you can be sure that they all have `size`, `ori`, and `pos` properties and that you can `draw()` them. However, this approach may not be best suited for cases when the same class must behave as different several classes. One solution is to use _multiple inheritance_, so that a class is a descendant of several classes and, thus, get behavior from many of them. This is the canonical way of ensuring generalization but you can achieve same means differently.

## Mixins
One way to infuse _common_ behavior into _different_ classes is via a mixin classes. These are classes that only define a single _behavior_ and nothing else. No constructor, typically no attributes. Thus, they are too limited to be used on their own but can be inherited from (mixed into the proper class) enabling that single behavior in the descendant.

Think about all creatures that can fly: insects, birds, bats, astronauts, etc. They do have a common ancestor but that common ancestor did not have the ability to fly. Instead, each line evolved that ability independently and all have evolutionary "cousins" that cannot fly. When programming, you can follow the same pattern of creating a common ancestor for flying and non-flying insects, then implementing ability to fly in the former. Do the same for birds, bats, astronauts, etc. If your implementation must be very detailed and creature-specific, this might be unavoidable. However, if your ability to "fly" is very abstract and, therefore, the same for all creatures in question, you will end up writing the same code for every insect, bird, bar class. An easy copy-paste, of course, but that means you get multiple places with identical implementation, so when you need to change it, you will have to make sure that you do it in all the places (and you gonna miss some, I always do). Alternative? Mixins! You create a class `FlightAbility` that implements that common abstract "flying" and, then, you inherit from that class whenever you need a flying someone. Mix a non-flying bird with the `FlightAbility` and it can fly! Mix it with an insect: Flying insect! You may also mix in more than one ability. Again, start with a bird that just walks around (chicken?). Add a mixin `FlightAbility` and you get a flying bird (pigeon?). Take the walking bird again and mix in `SwimAbility` and you get a swimming bird (penguin?). Mix in _both_ and you get a bird that can both fly and swim (swan?)!

You may not need mixins frequently but they are a powerful way of creating an isolated behavior that different classes might need without enforcing strict inheritance structure. PsychoPy is big on mixins. For example, it has `ColorMixin` that could be mixed-in to a visual class that needs to work with color, so it implements all the repetitive^[boilerplate] code for translating an arbitrary color representation (string, hexadecimal code, RGB triplet, HSL triplet, single grayscale value, etc.) into the internal RGB color value. It also has `TextureMixin` for classes that use textures for drawing objects. In our _Space Invaders_ game, we will use a Mixin class to mix in a "boom sound when exploded" behavior, common to both aliens and the player's ship.

## Duck typing
Alternatively, you might need your object to behave in a certain way but having a proper class hierarchy is an overkill because this is only one class and you might want some but not all the functionality. The idea is to use "duck typing", which comes from saying "If it walks like a duck, and it quacks like a duck, then it must be a duck." In other words, if the only things you care about are walking and quacking, do you need it to be an actual duck^[A man is hailing a taxi on a sidewalk. A car stops next to him. The guy looks at it and says "But there is the taxi sign on the roof?". The driver replies: "Do you need a taxi sign on the roof or a ride?"]? Will a goose that can walk and quack the same way do? Will a _dog_ that can walk and quack like a duck do? Obviously, the correct answer is "it depends" but in a lot of situations you are interested in a common behavior rather than in a common ancestor.

Duck typing is a popular method in Python. For example, `len(object)` is a canonical way to compute length of an object. That object could be a string `len("four")`, or a list `len([1, 2, 3, 4])`, a tuple `len(tuple(1, 4, 2))`, a dictionary `len({"A": 1, "B": 5})`, etc. The idea is that as long as a class has a concept of length (number of elements, number of characters, etc.), you should be able compute length via `len()`. This is achieved by adding a special methodto the class `__len__(self)` that must return an integer. This is called a "hook method", as it is never called directly but is "hooked" to the `len()` function call. Thus, whenever you write `len(object)`, it is actually translated into `object.__len()__`^[Why not implement it as a method `object.len()` or, even better, as a read-only property `object.len`? Read [here](https://mail.python.org/pipermail/python-3000/2006-November/004643.html) for the justification.].

Another popular duck typing application is an implementation of an iterator: an object that yields one item at a time, so you can do lazy computation^[Lazy computation means that you compute or get only what is necessary right now, rather than computing or getting all items in one go.] or loop over them. The former must implement two special methods to enable iteration over its items: `__iter__(self)` and `__next__(self)`. The former is called when iteration starts and it should perform all necessary initializations (e.g., setting internal counter to 0, reshuffling elements, etc.) and must return an iterator object (typically, a reference to itself)^[This is what function `range()` returns, not a list but an iterator object.]. The `__next()__` method is called whenever you the next item is needed: if you use iterator in the `for` loop, it is called automatically or you can call it yourself via `next(iterator_object)` (try it on a `range()`). `__next()__` must  return the next item or `raise StopIteration()` exception, signalling that it ran out of items.

Note that iterator does not require an implementation of the `__len()__` method! How come? If you have items you can iterate over, doesn't it make sense to also know their number (length of an object)? Not necessarily! First, if you use an iterator in a `for` loop and you just want to iterate over all of the items until you run out of them (which is signalled by the `StopIteration()` exception). Thus, their total number and, hence, `len()` method is of little interest. Accordingly, why implement a function that you do not need^[Of course, if you _do_ need it, you should implement it. The point is that quite often you do not.]? Second, what if your iterator is endless (in that case, it is called a _generator_)? E.g., every time `__next__()` is called it returns one random item or a random number. This way, it will never run out of items, so the question of "what is its length" is meaningless (unless you take "infinity" for an answer). This lack of need for `__len__()` for iterators is the spirit of duck typing: implement only the methods you need from your duck, ignore the rest.

Below, you will practice duck typing but implementing both `__len()__` and two special iterator methods as part of our `AlienArmada` class.
