% Options for packages loaded elsewhere
\PassOptionsToPackage{unicode}{hyperref}
\PassOptionsToPackage{hyphens}{url}
%
\documentclass[
]{book}
\usepackage{lmodern}
\usepackage{amsmath}
\usepackage{ifxetex,ifluatex}
\ifnum 0\ifxetex 1\fi\ifluatex 1\fi=0 % if pdftex
  \usepackage[T1]{fontenc}
  \usepackage[utf8]{inputenc}
  \usepackage{textcomp} % provide euro and other symbols
  \usepackage{amssymb}
\else % if luatex or xetex
  \usepackage{unicode-math}
  \defaultfontfeatures{Scale=MatchLowercase}
  \defaultfontfeatures[\rmfamily]{Ligatures=TeX,Scale=1}
\fi
% Use upquote if available, for straight quotes in verbatim environments
\IfFileExists{upquote.sty}{\usepackage{upquote}}{}
\IfFileExists{microtype.sty}{% use microtype if available
  \usepackage[]{microtype}
  \UseMicrotypeSet[protrusion]{basicmath} % disable protrusion for tt fonts
}{}
\makeatletter
\@ifundefined{KOMAClassName}{% if non-KOMA class
  \IfFileExists{parskip.sty}{%
    \usepackage{parskip}
  }{% else
    \setlength{\parindent}{0pt}
    \setlength{\parskip}{6pt plus 2pt minus 1pt}}
}{% if KOMA class
  \KOMAoptions{parskip=half}}
\makeatother
\usepackage{xcolor}
\IfFileExists{xurl.sty}{\usepackage{xurl}}{} % add URL line breaks if available
\IfFileExists{bookmark.sty}{\usepackage{bookmark}}{\usepackage{hyperref}}
\hypersetup{
  pdftitle={Python for social and experimental psychology},
  pdfauthor={Alexander (Sasha) Pastukhov},
  hidelinks,
  pdfcreator={LaTeX via pandoc}}
\urlstyle{same} % disable monospaced font for URLs
\usepackage{color}
\usepackage{fancyvrb}
\newcommand{\VerbBar}{|}
\newcommand{\VERB}{\Verb[commandchars=\\\{\}]}
\DefineVerbatimEnvironment{Highlighting}{Verbatim}{commandchars=\\\{\}}
% Add ',fontsize=\small' for more characters per line
\usepackage{framed}
\definecolor{shadecolor}{RGB}{248,248,248}
\newenvironment{Shaded}{\begin{snugshade}}{\end{snugshade}}
\newcommand{\AlertTok}[1]{\textcolor[rgb]{0.94,0.16,0.16}{#1}}
\newcommand{\AnnotationTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textbf{\textit{#1}}}}
\newcommand{\AttributeTok}[1]{\textcolor[rgb]{0.77,0.63,0.00}{#1}}
\newcommand{\BaseNTok}[1]{\textcolor[rgb]{0.00,0.00,0.81}{#1}}
\newcommand{\BuiltInTok}[1]{#1}
\newcommand{\CharTok}[1]{\textcolor[rgb]{0.31,0.60,0.02}{#1}}
\newcommand{\CommentTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textit{#1}}}
\newcommand{\CommentVarTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textbf{\textit{#1}}}}
\newcommand{\ConstantTok}[1]{\textcolor[rgb]{0.00,0.00,0.00}{#1}}
\newcommand{\ControlFlowTok}[1]{\textcolor[rgb]{0.13,0.29,0.53}{\textbf{#1}}}
\newcommand{\DataTypeTok}[1]{\textcolor[rgb]{0.13,0.29,0.53}{#1}}
\newcommand{\DecValTok}[1]{\textcolor[rgb]{0.00,0.00,0.81}{#1}}
\newcommand{\DocumentationTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textbf{\textit{#1}}}}
\newcommand{\ErrorTok}[1]{\textcolor[rgb]{0.64,0.00,0.00}{\textbf{#1}}}
\newcommand{\ExtensionTok}[1]{#1}
\newcommand{\FloatTok}[1]{\textcolor[rgb]{0.00,0.00,0.81}{#1}}
\newcommand{\FunctionTok}[1]{\textcolor[rgb]{0.00,0.00,0.00}{#1}}
\newcommand{\ImportTok}[1]{#1}
\newcommand{\InformationTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textbf{\textit{#1}}}}
\newcommand{\KeywordTok}[1]{\textcolor[rgb]{0.13,0.29,0.53}{\textbf{#1}}}
\newcommand{\NormalTok}[1]{#1}
\newcommand{\OperatorTok}[1]{\textcolor[rgb]{0.81,0.36,0.00}{\textbf{#1}}}
\newcommand{\OtherTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{#1}}
\newcommand{\PreprocessorTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textit{#1}}}
\newcommand{\RegionMarkerTok}[1]{#1}
\newcommand{\SpecialCharTok}[1]{\textcolor[rgb]{0.00,0.00,0.00}{#1}}
\newcommand{\SpecialStringTok}[1]{\textcolor[rgb]{0.31,0.60,0.02}{#1}}
\newcommand{\StringTok}[1]{\textcolor[rgb]{0.31,0.60,0.02}{#1}}
\newcommand{\VariableTok}[1]{\textcolor[rgb]{0.00,0.00,0.00}{#1}}
\newcommand{\VerbatimStringTok}[1]{\textcolor[rgb]{0.31,0.60,0.02}{#1}}
\newcommand{\WarningTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textbf{\textit{#1}}}}
\usepackage{longtable,booktabs}
% Correct order of tables after \paragraph or \subparagraph
\usepackage{etoolbox}
\makeatletter
\patchcmd\longtable{\par}{\if@noskipsec\mbox{}\fi\par}{}{}
\makeatother
% Allow footnotes in longtable head/foot
\IfFileExists{footnotehyper.sty}{\usepackage{footnotehyper}}{\usepackage{footnote}}
\makesavenoteenv{longtable}
\usepackage{graphicx}
\makeatletter
\def\maxwidth{\ifdim\Gin@nat@width>\linewidth\linewidth\else\Gin@nat@width\fi}
\def\maxheight{\ifdim\Gin@nat@height>\textheight\textheight\else\Gin@nat@height\fi}
\makeatother
% Scale images if necessary, so that they will not overflow the page
% margins by default, and it is still possible to overwrite the defaults
% using explicit options in \includegraphics[width, height, ...]{}
\setkeys{Gin}{width=\maxwidth,height=\maxheight,keepaspectratio}
% Set default figure placement to htbp
\makeatletter
\def\fps@figure{htbp}
\makeatother
\setlength{\emergencystretch}{3em} % prevent overfull lines
\providecommand{\tightlist}{%
  \setlength{\itemsep}{0pt}\setlength{\parskip}{0pt}}
\setcounter{secnumdepth}{5}
\usepackage{booktabs}
\ifluatex
  \usepackage{selnolig}  % disable illegal ligatures
\fi
\usepackage[]{natbib}
\bibliographystyle{apalike}

\title{Python for social and experimental psychology}
\author{Alexander (Sasha) Pastukhov}
\date{2021-05-11}

\begin{document}
\maketitle

{
\setcounter{tocdepth}{1}
\tableofcontents
}
\hypertarget{introduction}{%
\chapter*{Introduction}\label{introduction}}
\addcontentsline{toc}{chapter}{Introduction}

\hypertarget{about-the-material}{%
\section*{About the material}\label{about-the-material}}
\addcontentsline{toc}{section}{About the material}

This material is \textbf{free to use} and is licensed under the \href{https://creativecommons.org/licenses/by-nc-nd/4.0/}{Creative Commons Attribution-NonCommercial-NoDerivatives V4.0 International License}.

\hypertarget{about-the-seminar}{%
\section*{About the seminar}\label{about-the-seminar}}
\addcontentsline{toc}{section}{About the seminar}

This is a material for \emph{Python for social and experimental psychology} seminar. Each chapter covers a single seminar, introducing necessary ideas and is accompanied by a notebook with exercises that you need to complete and submit. The material assumes no foreknowledge of Python or programming from the reader. Its purpose is to gradually build up your knowledge and allow you to create more and more complex games. Yes, games! Of course, the real research is about performing experiments but there is little difference between the two. The basic ingredients are the same and, arguably, experiments are just boring games. And, be assured, if you can program a game, you certainly can program an experiment.

We will start with a simple \emph{Guess a Number} text-only game in which first you and then the computer will be doing the guessing. Next, we will implement a classic \emph{Hunt the Wumpus} text adventure game that will require use of more complex structures. Once we master the basics, we will up the ante by making \emph{video} games with graphics and sounds using \href{https://psychopy.org/}{PsychoPy} library. We will start with a classic \emph{Memory Game} and, then, create a more dynamic game by making a clone of a \emph{Flappy Bird}.

Remember that throughout the seminar you can and should(!) always ask me whenever something is unclear or you do not understand a concept or logic behind certain code. Do not hesitate to write me in the team or (better) directly to me in the chat (in the latter case, the notifications are harder miss and we don't spam others with our conversation).

You will need to submit your assignment one day before the next seminar (Tuesday before noon at the latest), so I would have time evaluate it and provide feedback.

As a final assignment, you will need to program a video game, which will only require the material covered by the seminar. Please inform me, If you require a grade, as then I will create a more specific description for you to have a clear understanding of how the program will be graded.

\hypertarget{note-on-exercises}{%
\section*{Note on exercises}\label{note-on-exercises}}
\addcontentsline{toc}{section}{Note on exercises}

In many exercises your will be not writing the code but reading and understanding it. Your job in this case is ``to think like a computer''. Your advantage is that computers are very dumb, so instructions for them must be written in very simple, clear, and unambiguous way. This means that, with practice, reading code is easy for a human (well, reading a well-written code is easy, you will eventually encounter ``spaghetti-code'' which is easier to rewrite from scratch than to understand). In each case, you simply go line-by-line, doing all computations by hand and writing down values stored in the variables (if there are too many to keep track of). Once you go through code in this manner, it will be completely transparent for you. No mysteries should remain, you should have no doubts or uncertainty about any(!) line. Moreover, then you can run the code and check that the values you are getting from computer match yours. Any difference means you made a mistake and code is working differently from how you think it does. In any case, \textbf{if you not 100\% sure about any line of code, ask me, so we can go through it together!}

In a sense, reading the code is the most important programming skill. It is impossible to learn how to write, if you cannot read first! Moreover, when programming you will probably spend more time reading the code and making sure that it works correctly than writing the new code. Thus, use this opportunity to practice and never use the code that you do not understand completely. This means that you certainly can use \href{https://stackoverflow.com/}{stackoverflow} but do make sure you understand the code you copied!

\hypertarget{why-python}{%
\section*{Why Python?}\label{why-python}}
\addcontentsline{toc}{section}{Why Python?}

The ultimate goal of this seminar is to teach you how to create an experiment for psychology research. There are many ways to achieve this end. You can use drag-and-drop systems either commercial like \href{https://www.neurobs.com/}{Presentation}, \href{https://www.sr-research.com/experiment-builder/}{Experiment Builder} or free like \href{https://psychopy.org/builder}{PsychoPy Bulder interface}. They have a much shallower learning curve, so you can start creating and running your experiments faster. However, the simplicity of their use has a price: They are fairly limited in which stimuli you can use and how you can control the presentation schedule, conditions, feedback, etc. Typically, they allow you to extend them by programming the desired behavior but you do need to know how to program to do this. Thus, I think that while these systems, in particular \href{https://psychopy.org/}{PsychoPy}, are great tools to quickly bang a simple experiment together, they are most useful if you understand how they create the underlying code and how you would program it yourself. Then, you will not be limited by the software, as you know you can program something the default drag-and-drop won't allow, but you can always opt in, if drag-and-drop is sufficient but faster. At the end, it is about having options and creative freedom to program an experiment that will answer your research question, not an experiment that your software allows you to program.

We will learn programming in Python, which is a great language that combines simple and clear syntax with power and ability to tackle almost any problem. The advantage of learning Python, as compared to say Matlab, which is commonly used in neuroscience, is that it allows you do almost anything. In this seminar, we will concentrate on desktop experiments but you can use it for online experiments (\href{https://otree.readthedocs.io/en/latest/}{oTree}), scientific programming (\href{https://numpy.org/}{NumPy} and \href{https://www.scipy.org/}{SciPy}), data analysis (\href{https://pandas.pydata.org/}{pandas}), machine learning (\href{https://keras.io/}{keras}), website programming (\href{https://www.djangoproject.com/}{django}), computer vision (\href{https://opencv.org/}{OpenCV}), etc. Thus, learning Python will give you one of the most versitile programming tools that you can use for all stages of your research or work. And, Python is free, so you do not need to worry whether you or your future employer will be able to afford the license fees (a very real problem, if you use Matlab).

\hypertarget{getting-started}{%
\chapter*{Getting Started}\label{getting-started}}
\addcontentsline{toc}{chapter}{Getting Started}

\hypertarget{install-anaconda}{%
\section*{Installing Anaconda environment}\label{install-anaconda}}
\addcontentsline{toc}{section}{Installing Anaconda environment}

First, install \href{https://www.anaconda.com}{Anaconda}, a Python distribution that includes many packages and tools out-of-the-box, makes it easy to install new packages and keep them updated. Follow this \href{https://www.anaconda.com/products/individual}{link} and download the installer suitable for your platform. You can pick either 32- or 64-bit version. I would recommend the latter, so that we all have maximally similar setup (it won't really make a difference in practice, though). Follow the installer instructions and use defaults, unless you have reasons to modify them (e.g.~folder location, as the drive for the default choice may have limited available space, as in my case).

After installation you will have a new \emph{Anaconda3 (64-bit)} folder that contains links to programs.

\begin{center}\includegraphics[width=0.5\linewidth]{images/anaconda-shortcuts} \end{center}

You can use \emph{Anaconda Navigator} that allows you to choose a specific programming environment, including \href{https://jupyter.org/}{Jupyter Notebook} that we will use (not JupyterLab, it is more versatile but we want to keep things simple at the beginning!). Alternatively, you can start \emph{Jupyter Notebook} directly from the start menu. Please read the \href{https://jupyter-notebook.readthedocs.io/en/stable/examples/Notebook/examples_index.html}{online documentation} to familiarize yourself with Jupyter Notebook basic interface, e.g.~how to create a new cell, run it, etc.

\hypertarget{install-vs-code}{%
\section*{Installing Visual Studio Code}\label{install-vs-code}}
\addcontentsline{toc}{section}{Installing Visual Studio Code}

\href{https://code.visualstudio.com/}{Visual Studio Code} is a free lightweight open-source editor with strong support for Python. We will start use it in earnest, once our programs grow to be sufficiently long and complex. At the early stages, we will mostly use Jupyter notebooks and I would recommend using Jupyter notebooks using the default browser-based editor you installed as part of \protect\hyperlink{install-anaconda}{Anaconda}. However, you can also work with Jupyter notebooks in VS Code \href{https://code.visualstudio.com/docs/python/jupyter-support}{directly}.

As in case of \protect\hyperlink{install-anaconda}{Anaconda}, download the installer for your platform and follow the instructions. Start VS Code and open any Python file, for example \href{other/empty.py}{this one} (use \texttt{Alt+click} to download it, ignore warnings, it is has only comments, so cannot harm you). When you open Python file for the first time, VS Code will suggest to install a Python extension. Do that and install a linter when VS Code suggests that (\href{https://code.visualstudio.com/docs/python/linting}{linting} highlights syntactical and stylistic problems in your code, making it easier to write consistent clear code).

Once the Python extension is activated, you will see which Python interpreter is used (you can have more than one or you may have multiple \href{https://docs.python.org/3/tutorial/venv.html}{virtual environments}).

\begin{center}\includegraphics[width=1\linewidth]{images/vscode-python-interpreter} \end{center}

If the selected environment is the wrong one or you are simply not sure, click on it and it will open a drop-down list with all interpreters and environments you have. Consult VS Code \href{https://code.visualstudio.com/docs/python/environments}{online documentation} on environments, if you need to change/add/delete environment (the exact settings may change, so looking at constantly updated online documentation is wiser than copying it here).

\hypertarget{debug-in-vs-code}{%
\section*{Debugging in VIsual Studio Code}\label{debug-in-vs-code}}
\addcontentsline{toc}{section}{Debugging in VIsual Studio Code}

VS Code gives you comprehensive debugging capabilities (read \href{https://code.visualstudio.com/docs/python/python-tutorial}{the tutorial} for detailed information about the tools you have). You can run the code in the debugging mode by pressing on debug button on the left toolbar

\begin{center}\includegraphics[width=0.05\linewidth]{images/vscode-debug-button} \end{center}

This will open the tab that initially will have the ``Run and Debug'' button or a suggestion to customize the setup

\begin{center}\includegraphics[width=1\linewidth]{images/vscode-rundebug} \end{center}

Click on ``create a launch.json file'', which will open a drop-down list at the top of the editor window:

\begin{center}\includegraphics[width=1\linewidth]{images/vscode-debug-options} \end{center}

Pick the first one (Debug the currently active python file) and this will generate a \emph{launch.json} configuration file, which you can close immediately. Now, in an active python file you can press \emph{F5} to start run and debug the program.

\hypertarget{install-psychopy}{%
\section*{Installing PsychoPy}\label{install-psychopy}}
\addcontentsline{toc}{section}{Installing PsychoPy}

This step can wait until the first \protect\hyperlink{memory-game-01}{Memory Game} seminar.

Download and install \href{https://www.psychopy.org/download.html}{Standalone PsychoPy} version. You can install PsychoPy as a conda package or via pip. However, using it as a standalone would ensure that you have all necessary additional libraries and a builder interface for the future use. We will use prepackaged PsychoPy's python environment in \protect\hyperlink{install-vs-code}{VS Code}.

\hypertarget{seminar01}{%
\chapter{Python basics}\label{seminar01}}

Before we start, create a folder called \emph{python-for-experiments} (or with some other more suitable but meaningful name) in you user folder (this is where Anaconda's Jupyter Notebook expects to find them). Download the \href{notebooks/Seminar\%2001.\%20Basics.ipynb}{exercise notebook} and put it in this folder. Open Jupyter Notebook (see \protect\hyperlink{getting-started}{Getting Started}, if you forgot how you do that), navigate to the folder you created and open the downloaded notebook. You will need to switch between explanations here and the exercises in the notebook, so keep them both open.

\hypertarget{variables}{%
\section{Variables}\label{variables}}

The first fundamental concept that we need to be acquainted with is \textbf{variable}. Variables are used to store information and you can think of it as a box with a name tag, so that you can put something into it. The name tag on that box is the name of the variable and its value what you store in it. For example, we can create a variable that stores the number of legs a game character has. We begin with a number typical for a human being.

\begin{center}\includegraphics[width=0.5\linewidth]{images/variable-as-box} \end{center}

In Python, you would write

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{number\_of\_legs }\OperatorTok{=} \DecValTok{2}
\end{Highlighting}
\end{Shaded}

The \textbf{assignment statement} above has very simple structure \texttt{\textless{}variable-name\textgreater{}\ =\ \textless{}value\textgreater{}}. Variable name (name tag on the box) should be meaningful, it can start with letters or \_ and can contain letters, numbers, and \_ symbol but not spaces, tabs, special characters, etc. Python recommends (well, actually, \href{https://www.python.org/dev/peps/pep-0008/}{insists}) that you use \textbf{snake\_case} (all lower-case, underscore for spaces) to format your variable names. The \texttt{\textless{}value\textgreater{}} on the right side is a more complex story, as it can be hard-coded (as in example above), computed using other variables or the same variable, returned by a function, etc.

Using variables means that you can concentrate what corresponding values \textbf{mean} rather than worrying about what these values are. For example, the next time you need to compute something based on number of character's legs (e.g., how many pairs of shoes does a character need), you can compute it based on current value of \texttt{number\_of\_legs} variable rather than assume that it is \texttt{1}.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# BAD: why 1? Is it because the character has two legs or}
\CommentTok{\# because we issue one pair of shoes per character irrespective of}
\CommentTok{\# their actual number of legs?}
\NormalTok{pairs\_of\_shoes }\OperatorTok{=} \DecValTok{1}

\CommentTok{\# BETTER!}
\NormalTok{pairs\_of\_shoes }\OperatorTok{=}\NormalTok{ number\_of\_legs }\OperatorTok{/} \DecValTok{2}
\end{Highlighting}
\end{Shaded}

Variables also give you flexibility. Their values can change during the program run: player's score is increasing, number of lives decreasing, number of spells it can cast grows or falls depending on their use, etc. Yet, you can always use the value in the variable to perform necessary computations. For example, here is a slightly extended \texttt{number\_of\_shoes} example.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{number\_of\_legs }\OperatorTok{=} \DecValTok{2}

\CommentTok{\# ...}
\CommentTok{\# something happens and our character is turned into an octopus}
\NormalTok{number\_of\_legs }\OperatorTok{=} \DecValTok{8}
\CommentTok{\# ...}

\CommentTok{\# the same code still works and we still can compute the correct number of pairs of shoes}
\NormalTok{pairs\_of\_shoes }\OperatorTok{=}\NormalTok{ number\_of\_legs }\OperatorTok{/} \DecValTok{2}
\end{Highlighting}
\end{Shaded}

As noted above, you can think about a variable as a labeled box you can store something in. That means that you can always ``throw away'' the old value and put something new. In case of variables, the ``throwing away'' part happens automatically, as the new value overwrites the old one. Check yourself, what will be final value of the variable in the code below?

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{number\_of\_legs }\OperatorTok{=} \DecValTok{2}
\NormalTok{number\_of\_legs }\OperatorTok{=} \DecValTok{5}
\NormalTok{number\_of\_legs }\OperatorTok{=} \DecValTok{1}
\NormalTok{number\_of\_legs}
\end{Highlighting}
\end{Shaded}

Do exercise \#1.

As you have already seen, you can \emph{compute} a value instead of specifying it. What would be the answer here?

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{number\_of\_legs }\OperatorTok{=} \DecValTok{2} \OperatorTok{*} \DecValTok{2}
\NormalTok{number\_of\_legs }\OperatorTok{=} \DecValTok{7} \OperatorTok{{-}} \DecValTok{2}
\NormalTok{number\_of\_legs}
\end{Highlighting}
\end{Shaded}

Do exercise \#2.

\hypertarget{assignments-are-not-equations}{%
\section{Assignments are not equations!}\label{assignments-are-not-equations}}

\textbf{Very important}: although assignments \emph{look} like mathematical equations, they are \textbf{not equations!} Assignments follow a \textbf{very important} rule that you must keep in mind when understanding assignments: the right side expression is evaluated \emph{first} until the final value is computed, then and only then the final value is assigned to the variable specified on the left side (put in the box). What this means is that you can use the same variable on \emph{both} sides! Let's take a look at this code:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x }\OperatorTok{=} \DecValTok{2}
\NormalTok{y }\OperatorTok{=} \DecValTok{5}
\NormalTok{x }\OperatorTok{=}\NormalTok{ x }\OperatorTok{+}\NormalTok{ y }\OperatorTok{{-}} \DecValTok{4}
\end{Highlighting}
\end{Shaded}

What happens when computer evaluates the last line?

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x }\OperatorTok{=}\NormalTok{ x }\OperatorTok{+}\NormalTok{ y }\OperatorTok{{-}} \DecValTok{4}
\end{Highlighting}
\end{Shaded}

First, it takes \emph{current} values of all variables (\texttt{2} for \texttt{x} and \texttt{5} for \texttt{y}) and substitutes them into the expression. After that internal step, the expression looks like

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x }\OperatorTok{=} \DecValTok{2} \OperatorTok{+} \DecValTok{5} \OperatorTok{{-}} \DecValTok{4}
\end{Highlighting}
\end{Shaded}

Then, it computes the expression on the right side and, \textbf{once the computation is completed}, stores that new value in \texttt{x}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x }\OperatorTok{=} \DecValTok{3}
\end{Highlighting}
\end{Shaded}

Do exercise \#3 to make sure you understand this.

\hypertarget{constants}{%
\section{Constants}\label{constants}}

Although the real power of variables is that you can change their value, you should use them even if the value remains constant. There are no true constants in Python, rather an agreement that their names should be all \texttt{UPPER\_CASE}. Accordingly, when you see \texttt{SUCH\_A\_VARIABLE} you know that you should not change its value. Technically, this is just a recommendation, as no one can stop you from modifying value of a \texttt{CONSTANT}. However, much of Python's ease-of-use comes from such ``gentlemen's agreements'' (such as \texttt{snake\_case} convention above), which you should respect. We will encounter more of them when learning about objects.

Taking all this into account, if number of legs stays constant throughout the game, you should highlight that constancy and write

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{NUMBER\_OF\_LEGS }\OperatorTok{=} \DecValTok{2}
\end{Highlighting}
\end{Shaded}

I strongly recommend using constants and avoid hardcoding the values. First, if you have several identical values that mean different things (2 legs, 2 eyes, 2 ears, 2 vehicles per character, etc.), seeing a \texttt{2} in the code will not tell you what does this \texttt{2} mean (the legs? the ears? the score multiplier?). You can, of course, figure it out based on the code that uses this number but you could spare yourself that extra effort and use a constant instead. Then, you just read its name and the meaning of the value becomes apparent (and it is the meaning not the actual value that you are mostly interested in). Second, if you decide to \emph{change} that value (say, our main character is now a tripod), when using a constant means you have only one place to worry about, the rest of the code stays as is. If you hard-coded that number, you are in for an exciting (not really) but definitely long search-and-replace throughout the entire code.

Do exercise \#4.

\hypertarget{value-types}{%
\section{Value types}\label{value-types}}

So far, we only used integer numeric values (1, 2, 5, 1000\ldots). Although, Python supports \href{https://docs.python.org/3/library/stdtypes.html}{many different value types}, at first we will concentrate on a small subset of them:

\begin{itemize}
\tightlist
\item
  integer numbers, we already used, e.g.~\texttt{-1}, \texttt{100000}, \texttt{42}.
\item
  float numbers that can take any real value, e.g.~\texttt{42.0}, \texttt{3.14159265359}, \texttt{2.71828}.
\item
  strings that can store text. The text is enclosed between either paired quotes \texttt{"some\ text"} or apostrophes \texttt{\textquotesingle{}some\ text\textquotesingle{}}. This means that you can use quotes or apostrophes inside the string, as long as its is enclosed by the alternative. E.g., \texttt{"students\textquotesingle{}\ homework"} (enclosed in \texttt{"}, apostrophe \texttt{\textquotesingle{}} inside) or \texttt{\textquotesingle{}"All\ generalizations\ are\ false,\ including\ this\ one."\ Mark\ Twain\textquotesingle{}} (quotation enclosed by apostrophes). There is much much more to strings and we will cover that material throughout the course.
\item
  logical / Boolean values that are either \texttt{True} or \texttt{False}.
\end{itemize}

When using a variable it is important that you know what type of value it stores and this is mostly on you. Python will raise an error, if you try doing a computation using incompatible. In some cases, Python will automatically convert values between certain types, e.g.~any integer value is also a real value, so conversion from \texttt{1} to \texttt{1.0} is mostly trivial and automatic. However, in other cases you may need to use explicit conversion. Go to exercise \#5 and try guessing which code will run and which will throw an error due to incompatible types?

\begin{Shaded}
\begin{Highlighting}[]
\DecValTok{5} \OperatorTok{+} \FloatTok{2.0}
\CommentTok{\textquotesingle{}5\textquotesingle{}} \OperatorTok{+} \DecValTok{2}
\CommentTok{\textquotesingle{}5\textquotesingle{}} \OperatorTok{+} \StringTok{\textquotesingle{}2\textquotesingle{}}
\CommentTok{\textquotesingle{}5\textquotesingle{}} \OperatorTok{+} \VariableTok{True}
\DecValTok{5} \OperatorTok{+} \VariableTok{True}
\end{Highlighting}
\end{Shaded}

Do exercise \#5.

Surprised by the last one? This is because internally, \texttt{True} is also \texttt{1} and \texttt{False} is \texttt{0}!

You can explicitly convert from one type to another using special functions. For example, to turn a number or a logical value into a string, you simply write \texttt{str(\textless{}value\textgreater{})}. In examples below, what would be the result?

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{str}\NormalTok{(}\DecValTok{10} \OperatorTok{/} \DecValTok{2}\NormalTok{)}
\BuiltInTok{str}\NormalTok{(}\FloatTok{2.5} \OperatorTok{+} \VariableTok{True}\NormalTok{)}
\BuiltInTok{str}\NormalTok{(}\VariableTok{True}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Do exercise \#6.

Similarly, you can convert to a logical/Boolean variable using \texttt{bool(\textless{}value\textgreater{})} function. The rules are simple, for numeric values \texttt{0} is \texttt{False}, any other non-zero value is converted to \texttt{True}. For string, an empty string \texttt{\textquotesingle{}\textquotesingle{}} is evaluated to \texttt{False} and non-empty string is converted to \texttt{True}. What would be the output in the examples below?

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{bool}\NormalTok{(}\OperatorTok{{-}}\DecValTok{10}\NormalTok{)}
\BuiltInTok{bool}\NormalTok{(}\FloatTok{0.0}\NormalTok{)}

\NormalTok{secret\_message }\OperatorTok{=} \StringTok{\textquotesingle{}\textquotesingle{}}
\BuiltInTok{bool}\NormalTok{(secret\_message)}

\BuiltInTok{bool}\NormalTok{(}\StringTok{\textquotesingle{}False\textquotesingle{}}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Do exercise \#7.

Converting to integer or float numbers is trickier. The simplest case is from logical to integer/float, as \texttt{True} gives you \texttt{int(True)} is \texttt{1} and \texttt{float(True)} is \texttt{1.0} and \texttt{False} gives you \texttt{0}/\texttt{0.0}. When converting from float to integer, Python simply drops the fractional part (not rounding!). When converting a string, it must be a valid number of the corresponding type or the error is generated. E.g., you can convert a string like \texttt{"123"} to and integer or a float but this won't work for \texttt{"a123"}. Moreover, you can convert \texttt{"123.4"} to floating-point number but not to an integer, as it has fractional part in it. Given all this, which cells would work and what output would they produce?

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{float}\NormalTok{(}\VariableTok{False}\NormalTok{)}
\BuiltInTok{int}\NormalTok{(}\OperatorTok{{-}}\FloatTok{3.3}\NormalTok{)}
\BuiltInTok{float}\NormalTok{(}\StringTok{"67.8"}\NormalTok{)}
\BuiltInTok{int}\NormalTok{(}\StringTok{"123+3"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Do exercise \#8.

\hypertarget{printing-output}{%
\section{Printing output}\label{printing-output}}

To print the value, you need you use \texttt{print()} function (we will talk about functions in general later). In the simplest case, you pass the value and it will be printed out.

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(}\DecValTok{5}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## 5
\end{verbatim}

or

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(}\StringTok{"five"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## five
\end{verbatim}

Of course, you already know about the variables, so rather than putting a value directly, you can pass a variable instead and its value will be printed out.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{number\_of\_pancakes }\OperatorTok{=} \DecValTok{10}
\BuiltInTok{print}\NormalTok{(number\_of\_pancakes)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## 10
\end{verbatim}

or

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{breakfast }\OperatorTok{=} \StringTok{"pancakes"}
\BuiltInTok{print}\NormalTok{(breakfast)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## pancakes
\end{verbatim}

You can also pass more than one value/variable to the print function and all the values will be printed one after another. For example, if we want to tell the user what did I had for breakfast and just how many of those, we can do

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{breakfast }\OperatorTok{=} \StringTok{"pancakes"}
\NormalTok{number\_of\_items }\OperatorTok{=} \DecValTok{10}
\BuiltInTok{print}\NormalTok{(breakfast, number\_of\_items)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## pancakes 10
\end{verbatim}

What will be printed by the code below?

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{dinner }\OperatorTok{=} \StringTok{"stake"}
\NormalTok{count }\OperatorTok{=} \DecValTok{4}
\NormalTok{desert }\OperatorTok{=} \StringTok{"cupcakes"}

\BuiltInTok{print}\NormalTok{(count, dinner, count, desert)}
\end{Highlighting}
\end{Shaded}

Do exercise \#9.

However, you probably would want to be more explicit, when you print out the information. For example, imagine you have these three variables:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{meal }\OperatorTok{=} \StringTok{"breakfast"}
\NormalTok{dish }\OperatorTok{=} \StringTok{"pancakes"}
\NormalTok{count }\OperatorTok{=} \DecValTok{10}
\end{Highlighting}
\end{Shaded}

You could, of course do \texttt{print(meal,\ dish,\ count)} but it would be nicer to print ``\emph{I had \textbf{10 pancakes} for \textbf{breakfast}}'', where items in bold would be the inserted variables' values. For this, we need to use string formatting. Please note that the string formatting is not specific to printing, you can create a new string value via formatting and store it in a variable (without printing it out) or print it out (without storing it).

\hypertarget{string-formatting}{%
\section{String formatting}\label{string-formatting}}

A great resource on string formatting in Python is \href{https://pyformat.info/}{pyformat.info}. As Python constantly evolves, it now has more than one way to format strings. Below, I will introduce the ``old'' format that is based on classic string formatting used in \texttt{sprintf} function is C, Matlab, R, and many other programming languages. It is somewhat less flexible than a newer ones but for simple tasks the difference is negligible. Knowing the old format is useful because of its generality. If you want to learn alternatives, read at the link above.

The general call is \texttt{"a\ string\ with\ formatting"\%(tuple\ of\ values\ to\ be\ used\ during\ formatting)}.

In \texttt{"a\ string\ with\ formatting"}, you specify where you want to put the value via \texttt{\%} symbol that is followed by an \emph{optional} formatting info and the \emph{required} symbol that defines the \textbf{type} of the value. The type symbols are

\begin{itemize}
\tightlist
\item
  \texttt{s} for string
\item
  \texttt{d} for an integer
\item
  \texttt{f} for a float value
\item
  \texttt{g} for an ``optimally'' printed float value, so that scientific notation is used for large values (\emph{e.g.}, \texttt{10e5} instead of \texttt{100000}).
\end{itemize}

Here is an example of formatting a string using an integer:

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(}\StringTok{"I had }\SpecialCharTok{\%d}\StringTok{ pancakes for breakfast"}\OperatorTok{\%}\NormalTok{(}\DecValTok{10}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## I had 10 pancakes for breakfast
\end{verbatim}

You are not limited to a single value that you can put into a string. You can specify more locations via \texttt{\%} but you must make sure that you pass the right number of values. Before running it, can you figure out which call will actually work (and what will be the output ) and which will produce an error?

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(}\StringTok{\textquotesingle{}I had }\SpecialCharTok{\%d}\StringTok{ pancakes and either }\SpecialCharTok{\%d}\StringTok{  or }\SpecialCharTok{\%d}\StringTok{ stakes for dinner\textquotesingle{}}\OperatorTok{\%}\NormalTok{(}\DecValTok{2}\NormalTok{))}
\BuiltInTok{print}\NormalTok{(}\StringTok{\textquotesingle{}I had }\SpecialCharTok{\%d}\StringTok{ pancakes and }\SpecialCharTok{\%d}\StringTok{ stakes for dinner\textquotesingle{}}\OperatorTok{\%}\NormalTok{(}\DecValTok{7}\NormalTok{, }\DecValTok{10}\NormalTok{))}
\BuiltInTok{print}\NormalTok{(}\StringTok{\textquotesingle{}I had }\SpecialCharTok{\%d}\StringTok{ pancakes and }\SpecialCharTok{\%d}\StringTok{ stakes for dinner\textquotesingle{}}\OperatorTok{\%}\NormalTok{(}\DecValTok{1}\NormalTok{, }\DecValTok{7}\NormalTok{, }\DecValTok{10}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

Do exercise \#10.

In case of real values you have two options: \texttt{\%f} and \texttt{\%g}. The latter uses scientific notation (e.g.~\texttt{1e10} for \texttt{10000000000}) to make a representation more compact.

Do exercise \#11 to get a better feeling for the difference.

These is much more to formatting and you can read about it at \href{https://pyformat.info/}{pyformat.info}. However, these basics are sufficient for us to start programming our first game during the next seminar. Don't forget to submit your exercise notebook and see you next time!

\hypertarget{seminar02}{%
\chapter{Guess the Number}\label{seminar02}}

Seminar \#1 covered Python basics, so now you are ready to start developing you first game! We will build it step by step and there will be a lot to learn about input, libraries, conditional statements, and indentation. As before, download \href{notebooks/Seminar\%2002.\%20Guess\%20the\%20number.ipynb}{exercise notebook}, copy it in your designated folder, and open it in Jupyter Notebook.

\hypertarget{game-description}{%
\section{Game description}\label{game-description}}

We will program a game in which one participant (computer) picks the number within a certain range (say, between 1 and 10) and the other participant (player) is trying to guess it. After every guess, the first participant (computer) responds whether the actual number is lower than a guess, higher than a guess, or matches it. The game is over when the player correctly guess the number or (in the later version of the game) runs out of attempts.

Our first version will allow just one attempt (will make it more fun later on) and the overall game algorithm will look like this:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# 1. computer generates a random number}
\CommentTok{\# 2. prints it out for debug purposes}
\CommentTok{\# 3. prompts user to enter a guess}
\CommentTok{\# 4. compares two numbers and print outs the outcome}
\CommentTok{\#    "My number is lower", "My number is higher", or "Spot on!"}
\end{Highlighting}
\end{Shaded}

\hypertarget{lets-pick-the-number-exercise-1}{%
\section{Let's pick the number (Exercise 1)}\label{lets-pick-the-number-exercise-1}}

Let us start by creating a variable that will hold a number that computer ``picked''. Let us name it \texttt{number\_picked} (you can some other meaningful name as well but it might be easier if we all stick to the same name). To make things a bit simpler at the beginning, let us assign some hard=coded arbitrary number between 1 and 10 to it (whatever you fill like). Then, let us print it out, so that we know the number ourselves (we know it now but that won't be the case when computer will generate it randomly). Use string formatting to make things user-friendly, e.g., print out something like ``The number I've picked is \ldots{}''. Your code should be a two-liner:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# 1. create variable and set it value}
\CommentTok{\# 2. print out the value}
\end{Highlighting}
\end{Shaded}

Put your code into exercise \#1 and make sure your code works!.

\hypertarget{input-function}{%
\section{Asking user for a guess (Exercise 2)}\label{input-function}}

Now we need to ask the player to enter their guess. For this, we will use \href{https://docs.python.org/3/library/functions.html\#input}{input({[}prompt{]})} function (here and below the links lead to the official documentation). It prints out \texttt{prompt} (a string) if you supplied it, reads the input (key presses) until the user presses \texttt{Enter}, and returns it \textbf{as a string}. For a moment, let us assume that the input is always an valid integer number (so, type only valid integers!), so we can convert it to an integer without extra checks (will add them later) and assign this value to a new variable called \texttt{guess}. Thus, you need to write a single line assignment statement with \texttt{guess} variable on the left side, whereas on the right should be a call to the \texttt{input(...)} function (think of a nice prompt message) wrapped by the type-conversion to \texttt{int(...)}. Switch to exercise 2 and, for the moment, only enter valid integers when running the code, so that the conversion works without an error.

Put your code into exercise \#2.

\hypertarget{conditional-if-statement}{%
\section{\texorpdfstring{Conditional \emph{if} statement}{Conditional if statement}}\label{conditional-if-statement}}

Now we have two numbers: One that computer picked and one that is player's guess. Now, we need to compare them to provide correct output message. For this, we will use conditional \href{https://docs.python.org/3/tutorial/controlflow.html\#if-statements}{if statement}:

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{if}\NormalTok{ some\_condition\_is\_true:}
    \CommentTok{\# do something}
\ControlFlowTok{elif}\NormalTok{ some\_other\_condition\_is\_true:}
    \CommentTok{\# do something else}
\ControlFlowTok{elif}\NormalTok{ yet\_another\_condition\_is\_true:}
    \CommentTok{\# do yet something else}
\ControlFlowTok{else}\NormalTok{:}
    \CommentTok{\# do something only if all conditions above are false.}
\end{Highlighting}
\end{Shaded}

Only the \texttt{if} part is required, whereas \texttt{elif} (short for ``else, if'') and \texttt{else} are optional. Thus you can do something, only if a condition is true:

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{if}\NormalTok{ some\_condition\_is\_true:}
    \CommentTok{\# do something, but OTHERWISE DO NOT DO ANYTHING }
    \CommentTok{\# and continue with code execution}
  
\CommentTok{\# some code that is executed after the if{-}statement,}
\CommentTok{\# irrespective of whether the condition was true or not.}
\end{Highlighting}
\end{Shaded}

Before we can properly use conditional statements, you need to understand (1) the conditions themselves and (2) use of indentation as a mean of grouping statements together.

\hypertarget{conditions-and-comparisons-exercises-3-8}{%
\section{Conditions and comparisons (exercises 3-8)}\label{conditions-and-comparisons-exercises-3-8}}

Condition is any expression that can be evaluated to see whether it is \texttt{True} or \texttt{False}. A straightforward example of such expression are comparisons, in human language expressed as ``is today Thursday?'', ``is the answer equal to 42'', ``is it raining and I have an umbrella?''. We will concentrate on them here but later you will see that in Python \textbf{any} expression is either \texttt{True} or \texttt{False}, even when it does not look like a comparison.

For the comparison, you can use the following operators:

\begin{itemize}
\tightlist
\item
  \emph{``A is equal B''} is written as \texttt{A\ ==\ B}.
\item
  \emph{``A is not equal B''} is written as \texttt{A\ !=\ B}.
\item
  \emph{``A is greater than B''} and \emph{``A is smaller than B''} are, respectively, \texttt{A\ \textgreater{}\ B} and \texttt{A\ \textless{}\ B}.
\item
  \emph{``A is greater than or equal to B''} and \emph{``A is smaller than or equal to B''} are, respectively, \texttt{A\ \textgreater{}=\ B} and \texttt{A\ \textless{}=\ B} (please note the order of symbols!).
\end{itemize}

Go to exercise \#3 to solve some comparisons.

You can \emph{invert} the logical value using \texttt{not} operator, as \texttt{not\ True} is \texttt{False} and \texttt{not\ False} is \texttt{True}. This means that \texttt{A\ !=\ B} is the same as \texttt{not\ A\ ==\ B} and, correspondingly, \texttt{A\ ==\ B} is \texttt{not\ A\ !=\ B}. To see how that works, consider both cases when \texttt{A} is indeed equal \texttt{B} and when it is not.

\begin{itemize}
\tightlist
\item
  If A is equal B then \texttt{A\ ==\ B} evaluates to \texttt{True}. The \texttt{A\ !=\ B} is then \texttt{False}, so \texttt{not\ A\ !=\ B} → \texttt{not\ False} → \texttt{True}.
\item
  If A is not equal B then \texttt{A\ ==\ B} evaluates to \texttt{False}. The \texttt{A\ !=\ B} is then \texttt{True}, so \texttt{not\ A\ !=\ B} → \texttt{not\ True} → \texttt{False}.
\end{itemize}

Go to exercise \#4 to explore this inversion yourself.

You can also combine several comparisons using \texttt{and} and/or \texttt{or} operators. As in human language, \texttt{and} means that both parts must be true: \texttt{True\ and\ True} → \texttt{True} but \texttt{True\ and\ False} → \texttt{False}, \texttt{False\ and\ True} → \texttt{False}, and \texttt{False\ and\ False} → \texttt{False}. Same holds if you have more have than two conditions/comparisons, \textbf{all} of them must be true. In case of \texttt{or} only one of the statements must be true, e.g.~\texttt{True\ and\ True} → \texttt{True}, \texttt{True\ and\ False} → \texttt{True}, \texttt{False\ and\ True} → \texttt{True}, but \texttt{False\ and\ False} → \texttt{False}. Again, for more than two comparisons/conditions at least one of them should be true for the entire expression to be true.

Do exercises \#5 and \#6.

Subtle but important point: conditions are evaluated from left to right until the whole expression can be definitely resolved. This means that if the first expression in a \texttt{and} pair is \texttt{False}, the second one is \textbf{never evaluated}. I.e., if \texttt{first\ and\ second} expressions both need to be \texttt{True} and you know that already \texttt{first} expression is false, the whole expression will be \texttt{False} in any case. This means that in the code below there will be no error, even though evaluating \texttt{int("e123")} raises \texttt{ValueError}.

\begin{Shaded}
\begin{Highlighting}[]
\DecValTok{2} \OperatorTok{*} \DecValTok{2} \OperatorTok{==} \DecValTok{5} \KeywordTok{and} \BuiltInTok{int}\NormalTok{(}\StringTok{"e123"}\NormalTok{) }\OperatorTok{==} \DecValTok{123}
\end{Highlighting}
\end{Shaded}

However, reverse the order, so that \texttt{int("e123")\ ==\ 123} needs to be evaluated first and you get the error message

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{int}\NormalTok{(}\StringTok{"e123"}\NormalTok{) }\OperatorTok{==} \DecValTok{123} \KeywordTok{and} \DecValTok{2} \OperatorTok{*} \DecValTok{2} \OperatorTok{==} \DecValTok{4}
\CommentTok{\# Generates ValueError: invalid literal for int() with base 10: \textquotesingle{}e123\textquotesingle{}}
\end{Highlighting}
\end{Shaded}

Similarly, if \emph{any} expression in \texttt{or} is \texttt{True}, you do not need to check the rest.

\begin{Shaded}
\begin{Highlighting}[]
\DecValTok{2} \OperatorTok{*} \DecValTok{2} \OperatorTok{==} \DecValTok{4} \KeywordTok{or} \BuiltInTok{int}\NormalTok{(}\StringTok{"e123"}\NormalTok{) }\OperatorTok{==} \DecValTok{123}
\end{Highlighting}
\end{Shaded}

However, if the first condition is \texttt{False}, we do need to continue (and stumble into an error):

\begin{Shaded}
\begin{Highlighting}[]
\DecValTok{2} \OperatorTok{*} \DecValTok{2} \OperatorTok{==} \DecValTok{5} \KeywordTok{or} \BuiltInTok{int}\NormalTok{(}\StringTok{"e123"}\NormalTok{) }\OperatorTok{==} \DecValTok{123}
\CommentTok{\# Generates ValueError: invalid literal for int() with base 10: \textquotesingle{}e123\textquotesingle{}}
\end{Highlighting}
\end{Shaded}

Do exercise \#7.

Finally, like in simple arithmetic, you can use brackets \texttt{()} to group conditions together. Thus a statement ``I always eat chocolate but I eat spinach only when I am hungry'' can be written as \texttt{food\ ==\ "chocolate"\ or\ (food\ ==\ "spinach"\ and\ hungry)}. Here, \texttt{the\ food\ ==\ "chocolate"} and \texttt{food\ ==\ "spinach"\ and\ hungry} are evaluated independently, their values are substituted in their place and then the \texttt{and} condition is evaluated.

Do exercise \#8.

\hypertarget{grouping-statements-via-identation-exercise-9}{%
\section{Grouping statements via identation (exercise \#9)}\label{grouping-statements-via-identation-exercise-9}}

Let us go back to the conditional if-statement. Take a look at following code example, in which statement \#1 is executed only if some condition is true, whereas statement \#2 is executed after that irrespective of the condition.

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{if}\NormalTok{ some\_condition\_is\_true:}
\NormalTok{    statement }\CommentTok{\#1}
\NormalTok{statement }\CommentTok{\#2 }
\end{Highlighting}
\end{Shaded}

Both statements \#1 and \#2 appear after the if-statement, so how does Python now that the first one is executed only if condition is true but the other one always runs? The answer is indentation (the \textbf{4 (four!)} spaces, they are automatically added whenever you press \texttt{Tab} and removed whenever you press \texttt{Shift\ +\ Tab}) that puts statement \#1 \emph{inside} the if-statement. Thus, indentation shows whether statements belong to the same group (same indentation as for \texttt{if} and \texttt{statement\ \#2}) or are inside conditional statement, loop, or function (\texttt{statement\ \#1}). For more complex code that will have, for example, if-statement inside an if-statement inside a loop, you will express this by adding more levels of indentation. E.g.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# some statements outside of the loop (0 indentation)}
\ControlFlowTok{while}\NormalTok{ game\_is\_not\_over: }\CommentTok{\# (0 indentation)}
    \CommentTok{\# statements inside of the loop }
    \ControlFlowTok{if}\NormalTok{ key\_pressed: }\CommentTok{\# (indentation of 4)}
        \CommentTok{\# inside loop and if{-}statement }
        \ControlFlowTok{if}\NormalTok{ key }\OperatorTok{==} \StringTok{"Space"}\NormalTok{: }\CommentTok{\# (indentation of 8)}
            \CommentTok{\# inside the loop, and if{-}statement, and another if{-}statement}
\NormalTok{            jump() }\CommentTok{\# (indentation of 12)}
        \ControlFlowTok{else}\NormalTok{: }\CommentTok{\# (indentation of 4)}
            \CommentTok{\# inside the loop, and if{-}statement, and else part of another if{-}statement}
\NormalTok{            stand() }\CommentTok{\# (indentation of 12)}
    
    \CommentTok{\# statements inside of the loop but outside of the outermost if{-}statement}
    \BuiltInTok{print}\NormalTok{(key) }\CommentTok{\# (indentation of 4)}
    
\CommentTok{\# some statements outside of the loop (0 indentation)}
\end{Highlighting}
\end{Shaded}

Pay very close attention to the indentation as it determines which statements are executed together!

Do exercise \#9.

The \texttt{if} and \texttt{ifelse} statements are evaluated until one of them turns out to be \texttt{True}. After that any following \texttt{ifelse} and \texttt{else} statements are simply ignored.

Do exercise \#10.

\hypertarget{checking-the-answer-exercise-11}{%
\section{Checking the answer (Exercise 11)}\label{checking-the-answer-exercise-11}}

Now you have all necessary instruments to finish the first version of our game. Go to exercise \#11 and, first, copy-paste your solutions to exercise \#1 (settings computer pick and printing it out) and \#2 (getting player input as an integer). Now, add conditional statements below, so that

\begin{itemize}
\tightlist
\item
  if the computer pick is smaller than player's guess, it will print \texttt{"My\ number\ is\ lower!"}
\item
  if the computer pick is larger than player's guess, it will print \texttt{"My\ number\ is\ higher!"}
\item
  if two numbers are identical, it will print \texttt{"Spot\ on!"}
\end{itemize}

Put your code into exercise \#11.

\hypertarget{picking-number-randomly-exercise-12}{%
\section{Picking number randomly (Exercise 12)}\label{picking-number-randomly-exercise-12}}

Our game is ``feature-complete'': computer picks a number, player makes a guess, computer responds appropriately. However, currently we are playing for both sides, as we hand pick the number for computer. Now, we will let computer pick this number itself using \href{https://docs.python.org/3/library/random.html\#random.randint}{randint(a, b)} function. It is part of the \href{https://docs.python.org/3/library/random.html}{random} library, so you will need to \emph{import} it first. We will talk about libraries and importing them in greater detail later. For now, it suffices that the top line of your code is

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{from}\NormalTok{ random }\ImportTok{import}\NormalTok{ randint}
\end{Highlighting}
\end{Shaded}

Function \texttt{randint(a,\ b)} generates a random integer on the interval \texttt{a..b}. In our case, this interval is \texttt{1..10}. Go to exercise \#11. First copy-paste your solution for exercise \#12. Add the \texttt{from\ random\ import\ randint} as the first line. Then, replace the hard-coded value you used for computer's pick with a call to \texttt{randint()} function. Run the code several times to check that computer does pick different random values.

Put your code into exercise \#12.

Congratulations, you just programmed your first computer game! Yes, it is very simple but it has key ingredients: a random decision by computer, user input, and feedback. Next time, you will learn about loops to allow for multiple attempts and about functions to make your code modular and reliable. In the meantime, let us solidify your knowledge by programming yet another game!

\hypertarget{one-armed-bandit-exercise-13}{%
\section{One-armed bandit (Exercise 13)}\label{one-armed-bandit-exercise-13}}

You know everything you need to program a simple version of an ``one-armed bandit'' game (exercise \#13). Here is the game logic:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  \texttt{from\ random\ import\ randint}
\item
  Generate three random integers (say, between 1 and 5) and store them in three variables \texttt{slot1}, \texttt{slot2}, and \texttt{slot3}.
\item
  Print out the numbers, use string formatting to make it look nice.
\item
  In addition,

  \begin{itemize}
  \tightlist
  \item
    if all three values are the same, print \texttt{"Three\ of\ a\ kind!"}.
  \item
    If only two numbers match, print \texttt{"Pair!"}.
  \item
    Print nothing, if all numbers are different.
  \end{itemize}
\end{enumerate}

Put your code into exercise \#13.

\hypertarget{seminar03}{%
\chapter{Guess the Number, the Sequel}\label{seminar03}}

During our previous seminar, you programmed a single-attempt-only ``Guess the Number'' game. Now, you will expand to multiple attempts and will add other bells-and-whistles to make it more fun. Download the \href{notebooks/Seminar\%2003.\%20Guess\%20the\%20number,\%20part\%202.ipynb}{exercise notebook} before we start!

\hypertarget{while-loop}{%
\section{While loop (Exercises 1-2)}\label{while-loop}}

If you want to repeat something, you need to use loops. There are two types of loops: \href{https://wiki.python.org/moin/WhileLoop}{while} loop, which is repeated \emph{while} a condition is true, and \href{https://wiki.python.org/moin/ForLoop}{for} loop that iterates over items (we will use it later).

The basic structure of a \emph{while} loop is

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# statements before the loop}

\ControlFlowTok{while} \OperatorTok{\textless{}}\NormalTok{condition}\OperatorTok{\textgreater{}}\NormalTok{:}
    \CommentTok{\# statements inside are executed}
    \CommentTok{\# repeatedly for as long as}
    \CommentTok{\# the condition is True}
    
\CommentTok{\# statements after the loop}
\end{Highlighting}
\end{Shaded}

The \texttt{\textless{}condition\textgreater{}} here is any expression that is evaluated to be either \texttt{True} or \texttt{False}, just like in an \emph{if-elif-else} conditional statement.

Do exercise \#1.

Let us use \emph{while} loop, so that the player keeps guessing until finally getting it right. You can copy-paste the code you programmed during the last seminar or could redo it from scratch (I would strongly recommend you doing the latter!). The overall program structure should be the following

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{from}\NormalTok{ random }\ImportTok{import}\NormalTok{ randint}

\CommentTok{\# generated random number and store in computer\_pick variable}
\CommentTok{\# print it out for debugging purposes}
\CommentTok{\# get player input, convert it to an integer, and store}

\CommentTok{\# while \textless{}players guess is not equal to the value the computer picked\textgreater{}:}
    \CommentTok{\# print out "my number is smaller" or "my number is larger" using if{-}else statement}
    
\CommentTok{\# print "Spot on!" (because if we got here that means guess is equal to the computer\textquotesingle{}s pick)}
\end{Highlighting}
\end{Shaded}

Put your code into exercise \#2.

\hypertarget{counting-attempts-exercise-3}{%
\section{Counting attempts (Exercise \#3)}\label{counting-attempts-exercise-3}}

Now let us add a variable that will count the total number of attempts the player required. For this, create a new variable (call it \texttt{attempts} or something similar) \emph{before the loop} and initialize it \texttt{0}. Add \texttt{1} to it every time the player inputs the guess. After the loop, expand the \texttt{"Spot\ on!"} message you print out by adding information about the attempts count. Use string formatting to make things look nice, e.g.~\texttt{"Spot\ on,\ you\ needed\ 5\ attempts"}.

Put your code into exercise \#3.

\hypertarget{break}{%
\section{Breaking (and exiting, Exercise \#4)}\label{break}}

\emph{While} loop is continuously executed while the condition is \texttt{True} and, importantly, all code inside is executed before the condition is evaluated again. However, sometimes you may need to abort sooner without executing the remaining code. For this, Python gives you a \texttt{break} statement that causes the program to exit the loop immediately and to continue with the code after the loop.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# this code runs before the loop}

\ControlFlowTok{while} \OperatorTok{\textless{}}\NormalTok{somecondition}\OperatorTok{\textgreater{}}\NormalTok{:}
  \CommentTok{\# this code runs on every iteration}
  
    \ControlFlowTok{if} \OperatorTok{\textless{}}\NormalTok{someothercondition}\OperatorTok{\textgreater{}}\NormalTok{:}
        \ControlFlowTok{break}
  
  \CommentTok{\# this code runs on every iteration but not when you break out of the loop}

\CommentTok{\# this code runs after the loop}
\end{Highlighting}
\end{Shaded}

Do exercise \#4 to build the intuition.

\hypertarget{limiting-number-of-attempts-via-break-exercise-5}{%
\section{Limiting number of attempts via break (Exercise 5)}\label{limiting-number-of-attempts-via-break-exercise-5}}

Let's put the player under some pressure! Decide on maximal number of attempts allowed and stores in a constant. Pick an appropriate name (e.g.~\texttt{MAX\_ATTEMPTS}) and REMEMBER, ALL CAPITAL LETTERS for a constant name! Now, use \texttt{break} to quit the \texttt{while} loop, if current attempt number is greater than \texttt{MAX\_ATTEMPTS}.

Put your code into exercise \#5.

\hypertarget{correct-end-of-game-message-exercise-6}{%
\section{Correct end-of-game message (Exercise 6)}\label{correct-end-of-game-message-exercise-6}}

Think about the final message. Currently it says ``Spot on\ldots{}'' because we assumed that you exited the loop because you gave the correct answer. With limited attempts that is not the case, as the player could out of the loop because

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  They answered correctly
\item
  They ran out of attempts.
\end{enumerate}

Use \texttt{if-else} conditional statement to print out an appropriate message (e.g., \texttt{"Better\ luck\ next\ time!}, if the player lost).

Put your code into exercise \#6.

\hypertarget{limiting-number-of-attempts-with-a-break-exercise-7}{%
\section{Limiting number of attempts with a break (Exercise 7)}\label{limiting-number-of-attempts-with-a-break-exercise-7}}

Modify your code to work without \texttt{break} statement. Modify your condition so that loop repeats while player's guess is incorrect and the number of attempts is still less than the maximally allowed.

Put your code into exercise \#7.

\hypertarget{show-remaining-attempts-exercise-8}{%
\section{Show remaining attempts (Exercise 8)}\label{show-remaining-attempts-exercise-8}}

Modify the \texttt{input} prompt message to include number of \emph{remaining} attempts. E.g. \texttt{"Please\ enter\ the\ guess,\ you\ have\ X\ attempts\ remaining"}.

Put your code into exercise \#8.

\hypertarget{repeating-the-game-exercise-9}{%
\section{Repeating the game (Exercise 9)}\label{repeating-the-game-exercise-9}}

Let us an option for the player to play again. This means putting \emph{all} the current code inside of another \texttt{while} loop that is repeated for as long as the player wants to play. The code should look following:

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{from}\NormalTok{ random }\ImportTok{import}\NormalTok{ randint}

\CommentTok{\# define MAX\_ATTEMPTS}

\CommentTok{\# define a variable called "want\_to\_play" and set to True}
\ControlFlowTok{while}\NormalTok{ want\_to\_play:}
  \CommentTok{\# your working game code goes here ()}
  
  \CommentTok{\# ask user whether via input function. E.g. "Want to play again? Y/N"}
  \CommentTok{\# want\_to\_play should be True if user input is equal to "Y"}
  
\CommentTok{\# very final message, e.g. "Thank you for playing the game!"}
\end{Highlighting}
\end{Shaded}

\textbf{Pay extra attention to indentation to group the code properly!}

Put your code into exercise \#9.

\hypertarget{best-score-exercise-10}{%
\section{Best score (Exercise 10)}\label{best-score-exercise-10}}

A ``proper'' game typically keeps the track of players' performance. Let us record what was the fewest number of attempts that the player needed to guess the number. For this, create a new variable \texttt{fewest\_attempts} and set it to \texttt{MAX\_ATTEMPTS} (this is as bad as the player can be). Think, where do you need to create it? Once a game round is over and you know how many attempts the player required, update it if the number of attempts that the player used was \emph{less} than the current value. You can add the information about ``Best so far'' into the game-round-over message.

Put your code into exercise \#10.

\hypertarget{counting-game-rounds-exercise-11}{%
\section{Counting game rounds (Exercise 11)}\label{counting-game-rounds-exercise-11}}

Let us count how many rounds the player played. The idea and implementation is the same as with counting the attempts. Create a new variable, initialize it to 0, increment by 1 whenever a new round starts. Include the total number of rounds into the very final message, e.g.~``Thank you for playing the game X times!''

Put your code into exercise \#11.

\hypertarget{wrap-up}{%
\section{Wrap up}\label{wrap-up}}

Most excellent, you now have a proper working computer game with game rounds, limited attempts, best score, and what not!

\hypertarget{seminar04}{%
\chapter{Hunt the Wumpus, part 1}\label{seminar04}}

We will program text adventure computer game \href{https://en.wikipedia.org/wiki/Hunt_the_Wumpus}{Hunt the Wumpus}: ``In the game, the player moves through a series of connected caves, arranged in a dodecahedron, as they hunt a monster named the Wumpus. The turn-based game has the player trying to avoid fatal bottomless pits and''super bats" that will move them around the cave system; the goal is to fire one of their ``crooked arrows'' through the caves to kill the Wumpus\ldots"

As before, we will start with a very basic program and will build it step-by-step towards the final version. Don't forget to download the \href{notebooks/Seminar\%2004.\%20Hunt\%20the\%20Wumpus,\%20part\%201.ipynb}{exercise notebook}.

\hypertarget{lists}{%
\section{Lists}\label{lists}}

So far, we were using variables to store single values: computer's pick, player's guess, number of attempts, etc. However, you can store multiple values in a variable using \href{https://docs.python.org/3/library/stdtypes.html\#list}{lists}. The idea is fairly straightforward, a variable is not a simple box but a box with slots for values numbered from \texttt{0} to \texttt{len(variable)-1}.

The list is defined via square brackets \texttt{\textless{}variable\textgreater{}\ =\ {[}\textless{}value1\textgreater{},\ \textless{}value2\textgreater{},\ ...\ \textless{}valueN\textgreater{}{]}} and an individual value can be accessed also via square brackets \texttt{\textless{}variable\textgreater{}{[}\textless{}index\textgreater{}{]}} where index goes from \texttt{0} to \texttt{len(\textless{}variable\textgreater{})-1} (\href{https://docs.python.org/3/library/functions.html\#len}{\texttt{len(\textless{}object\textgreater{})}} function returns number of items in an object, in our case, it would be a list). Thus, if you have five values in the list, the index of the first one is \texttt{0} (not \texttt{1}) and the index of the last one is \texttt{4} (not \texttt{5})!

Do exercise \#1 see how lists are defined and indexed.

You can also get many values from the list via so called \emph{slicing} when you specify index of many elements via \texttt{\textless{}start\textgreater{}:\textless{}stop\textgreater{}}. There is a catch though and, as this is a recurrent theme in Python, pay close attention: The index slicing builds goes from \texttt{start} up to \textbf{but not including} \texttt{stop}, in mathematical notation \([start, stop)\). So, if you have a list \texttt{my\_pretty\_numbers} that holds five values and you want to get values from second (index \texttt{1}) till fourth (index \texttt{3}) you need to write the slice as \texttt{1:4} (not \texttt{1:3}!). This \emph{including the start but excluding the stop} is both fairly counterintuitive (I still have to consciously remind myself about this) and widely used in Python.

Do exercise \#2 to build the intuition.

You can also omit either \texttt{start} or \texttt{stop}. In this case, Python will assume that a missing \texttt{start} means \texttt{0} (the index of the first element) and missing \texttt{stop} means \texttt{len(\textless{}list\textgreater{})}. If you omit \emph{both}, e.g., \texttt{my\_pretty\_numbers{[}:{]}} it will return all values, as this is equivalent to \texttt{my\_pretty\_numbers{[}0:len(my\_pretty\_numbers){]}}.\footnote{Note, that this is almost but not quite the same thing as just writing \texttt{my\_pretty\_numbers}, the difference is subtle but important and we will look into it later when talking about mutable versus immutable types.}

Do exercise \#3.

You can also use \emph{negative} indexes that are relative to length of the list. Thus, if you want to get the \emph{last} element of the list, you can say \texttt{my\_pretty\_numbers{[}len(my\_pretty\_numbers)-1{]}} or just \texttt{my\_pretty\_numbers{[}-1{]}}. The last-but-one element would be \texttt{my\_pretty\_numbers{[}-2{]}}, etc. You can use negative indexes for slicing but keep in mind \emph{including the start but excluding the stop}: \texttt{my\_pretty\_numbers{[}:-1{]}} will return all but last element of the list not the entire list.

Do exercise \#4.

The slicing can be extended by specifying a \texttt{step}, so that \texttt{stop:start:step}. This can be combined with omitted and negative indexes. To get every \emph{odd} element of the list, you write \texttt{my\_pretty\_numbers{[}::2{]}}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{my\_pretty\_numbers }\OperatorTok{=}\NormalTok{ [}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{, }\DecValTok{4}\NormalTok{, }\DecValTok{5}\NormalTok{, }\DecValTok{6}\NormalTok{, }\DecValTok{7}\NormalTok{]}
\NormalTok{my\_pretty\_numbers[::}\DecValTok{2}\NormalTok{]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1, 3, 5, 7]
\end{verbatim}

Do exercise \#5.

Finally, for those who are familiar with R, the good news is that Python does not allow you to use indexes outside of the range, so trying to get 6\textsuperscript{th} element (index \texttt{5}) of a five-element-long list will generate a simple and straightforward error (a so-called \href{https://en.wikipedia.org/wiki/Fail-fast}{fail-fast} principle). The bad news is that if your \emph{slice} is larger than the range, it will truncated to the range without an extra warning or an error. So, for a five-element list \texttt{my\_pretty\_numbers{[}:6{]}} will return all numbers of to the maximal possible index (thus, effectively, this is equivalent to \texttt{my\_pretty\_numbers{[}:{]}}). Moreover, if the slice is empty (\texttt{2:2}, cannot include \texttt{2}, even though it starts from it) or the entire slice is outside of the range, Python will return an empty list, again, neither warning or error is generated.

Do exercise \#6.

\hypertarget{caves}{%
\section{Caves}\label{caves}}

In our game, the player will wander through a systems of caves with cave being connected to three other caves. The cave layout will be \emph{CONSTANT}, so we will define at the beginning of the program as follows.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{CAVES }\OperatorTok{=}\NormalTok{ [[}\DecValTok{1}\NormalTok{, }\DecValTok{4}\NormalTok{, }\DecValTok{5}\NormalTok{], [}\DecValTok{2}\NormalTok{, }\DecValTok{0}\NormalTok{, }\DecValTok{7}\NormalTok{], [}\DecValTok{3}\NormalTok{, }\DecValTok{1}\NormalTok{, }\DecValTok{9}\NormalTok{], [}\DecValTok{4}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{11}\NormalTok{], }
\NormalTok{         [}\DecValTok{0}\NormalTok{, }\DecValTok{3}\NormalTok{, }\DecValTok{13}\NormalTok{], [}\DecValTok{6}\NormalTok{, }\DecValTok{14}\NormalTok{, }\DecValTok{0}\NormalTok{], [}\DecValTok{7}\NormalTok{, }\DecValTok{5}\NormalTok{, }\DecValTok{15}\NormalTok{], [}\DecValTok{8}\NormalTok{, }\DecValTok{6}\NormalTok{, }\DecValTok{1}\NormalTok{], }
\NormalTok{         [}\DecValTok{9}\NormalTok{, }\DecValTok{7}\NormalTok{, }\DecValTok{16}\NormalTok{], [}\DecValTok{10}\NormalTok{, }\DecValTok{8}\NormalTok{, }\DecValTok{2}\NormalTok{], [}\DecValTok{11}\NormalTok{, }\DecValTok{9}\NormalTok{, }\DecValTok{17}\NormalTok{], [}\DecValTok{12}\NormalTok{, }\DecValTok{10}\NormalTok{, }\DecValTok{3}\NormalTok{], }
\NormalTok{         [}\DecValTok{13}\NormalTok{, }\DecValTok{11}\NormalTok{, }\DecValTok{18}\NormalTok{], [}\DecValTok{14}\NormalTok{, }\DecValTok{12}\NormalTok{, }\DecValTok{4}\NormalTok{], [}\DecValTok{5}\NormalTok{, }\DecValTok{13}\NormalTok{, }\DecValTok{19}\NormalTok{], [}\DecValTok{16}\NormalTok{, }\DecValTok{19}\NormalTok{, }\DecValTok{6}\NormalTok{], }
\NormalTok{         [}\DecValTok{17}\NormalTok{, }\DecValTok{15}\NormalTok{, }\DecValTok{8}\NormalTok{], [}\DecValTok{18}\NormalTok{, }\DecValTok{16}\NormalTok{, }\DecValTok{10}\NormalTok{], [}\DecValTok{19}\NormalTok{, }\DecValTok{17}\NormalTok{, }\DecValTok{12}\NormalTok{], [}\DecValTok{15}\NormalTok{, }\DecValTok{18}\NormalTok{, }\DecValTok{14}\NormalTok{]]}
\end{Highlighting}
\end{Shaded}

Let us decipher this. You have a list of twenty elements (caves). Inside each element is a list of connecting caves. This means, that if you are in cave \#1 (index \texttt{0}), it is connected to \texttt{CAVES{[}0{]}} → \texttt{{[}1,\ 4,\ 5{]}} (note that these numbers inside are zero-based indexes as well!). So, to see what is the index of the second cave connected to the first one you would write \texttt{CAVES{[}0{]}{[}1{]}} (you get first element of the list and, then, the second element of the list from inside).

Do exercise \#7 to get comfortable with indexing list of lists.

To allow the player to wander, we need to know where they are to begin with. Let us define a new variable called, simply, \texttt{player} and assign a random integer between \texttt{0} and \texttt{19} to it, thus putting the player into a random cave. For this, you will need a \texttt{randomint} function from the \texttt{random} library. Look at our previous seminar, if you forgot how to use it.

Our player needs to know where they can go, so on each turn we will need to print out the information about which cave the player is in and about the connecting caves (use string formatting to make this look nice). Let this be our first code snippet for the game. The code should look like this

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# import randint function from the random library}

\CommentTok{\# define CAVES (simply copy{-}paste the definition)}

\CommentTok{\# create \textasciigrave{}player\textasciigrave{} variable and set it to a random number between 0 and 19, }
\CommentTok{\# putting player into a random cave}

\CommentTok{\# print out the list of the connecting caves. Use string formatting.}
\end{Highlighting}
\end{Shaded}

Put your code into exercise \#8.

\hypertarget{wandering-around}{%
\section{Wandering around}\label{wandering-around}}

Now that the player can ``see'' where they are, let them wander! Use \texttt{input()} function to ask for the index of the cave the player wants to go to and store the value in a new variable \texttt{move\_to}. Remember that \texttt{input()} returns a string, so you will need to explicitly convert it to an integer (see Guess-the-Number game, if you forgot how to do it). Now ``move'' the player to that by assigning the \texttt{move\_to} value to the \texttt{player}. For now, enter only valid numbers, as we will add checks later. To make wandering continuous, put it inside the while loop, so that player wanders until they get to the cave \#5 (index \texttt{4}). We will have more sensible game-over conditions later on but this will allow you to exit the game without interrupting it from outside. The code should look like this (remember to watch your indentations!).

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# import randint function from the random library}

\CommentTok{\# define CAVES (simply copy{-}paste the definition)}

\CommentTok{\# create \textasciigrave{}player\textasciigrave{} variable and set it to a random number between 0 and 19, }
\CommentTok{\# putting player into a random cave}

\CommentTok{\# while player is not in the cave \#5 (index 4):}
    \CommentTok{\# print out the list of the connecting caves. Use string formatting.}
    \CommentTok{\# get input about the cave the player want to move to, store it in a variable \textasciigrave{}move\_to\textasciigrave{}}
    \CommentTok{\# "move" the \textasciigrave{}player\textasciigrave{} to the cave they wanted to \textasciigrave{}move\_to\textasciigrave{}}
    
\CommentTok{\# print a nice game{-}over message}
\end{Highlighting}
\end{Shaded}

Put your code into exercise \#9.

\hypertarget{checking-whether-a-value-is-in-the-list}{%
\section{\texorpdfstring{Checking whether a value is \emph{in} the list}{Checking whether a value is in the list}}\label{checking-whether-a-value-is-in-the-list}}

Right now we trust the player (well, you) to enter the correct index for the cave. Thus, the program will move a player to a new cave even if you enter an index of the cave that is not connected to the current one. Even worse, it will try to move the player to an undefined cave, if you enter an index larger than 19. To check whether an entered index matches one of the connected cave, you need to use \href{https://docs.python.org/3/tutorial/datastructures.html\#more-on-conditions}{ in } conditional statement. The idea is straightforward, if the value is in the list, the statement is \texttt{True}, if not, it is \texttt{False}.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x }\OperatorTok{=}\NormalTok{ [}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{]}
\BuiltInTok{print}\NormalTok{(}\DecValTok{1} \KeywordTok{in}\NormalTok{ x)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## True
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(}\DecValTok{4} \KeywordTok{in}\NormalTok{ x)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## False
\end{verbatim}

Note that you can check \emph{one} value/object at a time. Because a list is also a single object, you will be checking whether it is an element of the other list, not whether all or some of it elements are in it.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x }\OperatorTok{=}\NormalTok{ [}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, [}\DecValTok{3}\NormalTok{, }\DecValTok{4}\NormalTok{]]}
\CommentTok{\# This is False because x has no element [1, 2], only 1, and 2 (separately)}
\BuiltInTok{print}\NormalTok{([}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{] }\KeywordTok{in}\NormalTok{ x)}

\CommentTok{\# This is True because x has [3, 4] element}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## False
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{([}\DecValTok{3}\NormalTok{, }\DecValTok{4}\NormalTok{] }\KeywordTok{in}\NormalTok{ x)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## True
\end{verbatim}

Do exercise \#10.

\hypertarget{checking-valid-cave-index}{%
\section{Checking valid cave index}\label{checking-valid-cave-index}}

Now that you know how to check whether a value is in the list, let's use it to validate cave index. Before moving the player, you now need to check whether the entered index is in the list of the connected caves. If this is \texttt{True}, you move the player as before. Otherwise, print out an error message, e.g.~``Wrong cave index!'' without moving a player. Loop ensure that the player will be prompted for the input again.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# import randint function from the random library}

\CommentTok{\# define CAVES (simply copy{-}paste the definition)}

\CommentTok{\# create \textasciigrave{}player\textasciigrave{} variable and set it to a random number between 0 and 19, }
\CommentTok{\# putting player into a random cave}

\CommentTok{\# while player is not in the cave \#5 (index 4):}
    \CommentTok{\# print out the list of the connecting caves. Use string formatting.}
    \CommentTok{\# get input about the cave the player want to move to, store it in a variable \textasciigrave{}move\_to\textasciigrave{}}
    \CommentTok{\# if \textasciigrave{}move\_to\textasciigrave{} matches on of the connected caves:}
      \CommentTok{\# "move" the \textasciigrave{}player\textasciigrave{} to the cave they wanted to \textasciigrave{}move\_to\textasciigrave{}}
    \CommentTok{\# else:}
      \CommentTok{\# print out an error message}
    
\CommentTok{\# print a nice game{-}over message}
\end{Highlighting}
\end{Shaded}

Put your code into exercise \#11.

\hypertarget{checking-that-string-can-be-converted-to-an-integer}{%
\section{Checking that string can be converted to an integer}\label{checking-that-string-can-be-converted-to-an-integer}}

There is another danger with out input: The player is not guaranteed to enter a valid integer! So far we relied on you to behave but in real life, even when people do not deliberately try to break your program, they will occasionally press the wrong button. Thus, we need to check that the \emph{string} that they entered can be converted to an \emph{integer}.

Python string is an object (more on that in a few seminars) with different methods that allow to perform various operations on them. On subset of methods allows you to make a rough check of its content. The one we are interested is \href{https://docs.python.org/3/library/stdtypes.html\#str.isdigit}{str.isdigit()} that checks whether all symbols are digits and that the string is not empty (it has at least one symbol). You can follow the link above to check other alternatives such as \texttt{str.islower()}, \texttt{str.isalpha()}, etc.

Do exercise \#12.

\hypertarget{checking-valid-integer-input}{%
\section{Checking valid integer input}\label{checking-valid-integer-input}}

Modify the code that gets the input from the user. First, store the raw string (not converted to an integer) into an intermediate variable, e.g.~\texttt{move\_to\_str}. Then, if \texttt{move\_to\_str} is all digits, convert it to an integer, and do the check that it is a valid connected cave index (moving player or printing an error message). However, if \texttt{move\_to\_str} is not all digits, only print the error message. This means you need to have an if-statement inside the if-statement. The outline is below, watch you indentations!

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# import randint function from the random library}

\CommentTok{\# define CAVES (simply copy{-}paste the definition)}

\CommentTok{\# create \textasciigrave{}player\textasciigrave{} variable and set it to a random number between 0 and len(CAVES){-}1, }
\CommentTok{\# putting player into a random cave}

\CommentTok{\# while player is not in the cave \#5 (index 4):}
    \CommentTok{\# print out the list of the connecting caves. Use string formatting.}
    \CommentTok{\# get input into a variable \textasciigrave{}move\_to\_str\textasciigrave{}}
    \CommentTok{\# if move\_to\_str can be converted to an integer:}
        \CommentTok{\# convert move\_to\_str to integer and store value in move\_to}
        \CommentTok{\# if \textasciigrave{}move\_to\textasciigrave{} matches one of the connected caves:}
            \CommentTok{\# "move" the \textasciigrave{}player\textasciigrave{} to the cave they wanted to \textasciigrave{}move\_to\textasciigrave{}}
        \CommentTok{\# else:}
            \CommentTok{\# print out an error message}
    \CommentTok{\# else:}
        \CommentTok{\# print error message that user must enter a number}
    
\CommentTok{\# print a nice game{-}over message}
\end{Highlighting}
\end{Shaded}

Put your code into exercise \#13.

\hypertarget{wrap-up-1}{%
\section{Wrap up}\label{wrap-up-1}}

You now have a player in a system of the caves and they can navigate around. Next time, you will learn how to make your code modular by using functions and the game will have more thrills to it once we add bottomless pits and excitable bats.

\hypertarget{seminar05}{%
\chapter{Hunt the Wumpus, part 2}\label{seminar05}}

During our previous seminar, we defined a system of interconnected caves, placed a player into a random cave, and allowed them to wander around. Now, we will make the code modular by using functions. Don't forget to download the \href{notebooks/Seminar\%2005.\%20Hunt\%20the\%20Wumpus,\%20part\%202.ipynb}{exercise notebook}.

\hypertarget{function}{%
\section{Functions}\label{function}}

In programming, purpose of a function is to isolate certain code that performs a single computation making it testable and reusable. Let us go through the first sentence bit by bit using examples.

\hypertarget{function-performs-a-single-computation}{%
\subsection*{Function performs a single computation}\label{function-performs-a-single-computation}}
\addcontentsline{toc}{subsection}{Function performs a single computation}

I told you that reading code is easy because every action has to be spelled-out for computers in simple and clear way. However, a lot of simple things can be very overwhelming and confusing. Think about the final code for the previous seminar: we had a loop with two conditional statements nested inside the loop and each other. Add a few more of those and you have so many brunches to trace, you will never be quite sure what will happen. This is because our cognition and working memory, which you use to trace all brunches, are limited to just about four items (the official magic number is \href{https://en.wikipedia.org/wiki/The_Magical_Number_Seven,_Plus_or_Minus_Two}{7±2} but reading the original paper tells you that this is more like four for most of us).

Thus, a function should perform one computation that is conceptually clear and those purpose should be understood directly from its name or, at most, from a single sentence that describes it\footnote{This is similar to scientific writing, where a single paragraph conveys a single idea. So, for me, it helps to first write the idea of the paragraph in a single sentence before writing the paragraph itself. If one sentence is not enough, I need to split the text into more paragraphs.}. If you need more than once sentence to explain what function does, you should consider splitting the code further. This does not mean that entire description / documentation must fit into a single sentence. The full description can be lengthy, particularly if underlying computation is complex and there are many parameters to consider. However, these are optional details that tell the reader \emph{how} the function is doing its job. Again, they should be able to understand \emph{what} the job is just from the name or from a single sentence. I am repeating myself and stressing it so much because conceptually simple single job functions are a foundation of a clear robust reusable code. And, trust me on this one, future-you will be very grateful that it has to work with easy-to-understand isolated reliable code you wrote.

\hypertarget{function-isolates-code-from-the-rest-of-the-program}{%
\subsection*{Function isolates code from the rest of the program}\label{function-isolates-code-from-the-rest-of-the-program}}
\addcontentsline{toc}{subsection}{Function isolates code from the rest of the program}

Isolation means that your code is run in a separate scope where the only things that exist are function arguments (limited number of values you pass to it from outside with fixed meaning) and local variables that you define inside the function. You have no access to variables defined in the outside script or to variables defined inside of other functions. Conversely, neither global script nor other function have access to variables and values you compute inside. This means that you only need to study the code \emph{inside} the function to understand how it works. Accordingly, when you write the code it should be \emph{independent} of any global context the function can be used in. Thus, isolation is both practical (no run-time access to variables from outside means fewer chance that things go terribly wrong) and conceptual (no further context is required to understand the code).

\hypertarget{function-makes-code-easier-to-test}{%
\subsection*{Function makes code easier to test}\label{function-makes-code-easier-to-test}}
\addcontentsline{toc}{subsection}{Function makes code easier to test}

You can build even moderately complex programs only if you can be certain what individual chunks of code are doing under every possible condition. Do they give the correct results? Do the fail clearly raising an error, if the inputs are wrong? Do they use defaults when required? However, testing all chunks together means running extreme number of runs as you need to test all possible combinations of conditions for one chunk given all possible conditions for other chunk, etc. Functions make your life much easier. Because they have a single point of entry, fixed number of parameters, a single return value, and are isolated (see above), you can test them one at a time independent of other functions of the rest of the code. This is called \emph{unit testing} and it is heavy use of \href{https://docs.python.org/3/library/unittest.html}{automatic unit testing} (it is normal to have more code devoted to testing than to the actual program) that ensures reliable code for absolute majority of programs and apps that you use.

\hypertarget{function-makes-code-reusable}{%
\subsection*{Function makes code reusable}\label{function-makes-code-reusable}}
\addcontentsline{toc}{subsection}{Function makes code reusable}

Sometimes this reason is given as the primary reason to use functions. Turning code into a function means that you can call the function instead of copy-pasting the code. The latter is a terrible idea as it means that you have to maintain the same code at many places (sometimes you might not be even sure in just how many). This is a problem even if the code is extremely simple. Here, we define a \emph{standard} way to compute an initial by taking the first symbol from a string. The code is as simple as it gets.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{...}
\NormalTok{initial }\OperatorTok{=} \StringTok{"test"}\NormalTok{[}\DecValTok{0}\NormalTok{]}
\NormalTok{...}
\NormalTok{initial\_for\_file }\OperatorTok{=}\NormalTok{ filename[}\DecValTok{0}\NormalTok{]}
\NormalTok{...}
\NormalTok{initial\_for\_website }\OperatorTok{=}\NormalTok{ first\_name[}\DecValTok{0}\NormalTok{]}
\NormalTok{...}
\end{Highlighting}
\end{Shaded}

Imagine that you decided to change it and use first \emph{two} symbols. Again, the computation is hardly complicated, use just replace \texttt{{[}0{]}} with \texttt{{[}:2{]}}. But you have to do it for \emph{all} the code that does this computation. And you cannot use \emph{Replace All} option because sometimes you might use the first element for some other purposes. And when you edit the code, you are bound to forget about some locations (at least, I do it all the time) making things even less consistent and more confusing. Turning code into a function means you need to modify and test just everything at just one location. Here is the original code implemented via a function.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{def}\NormalTok{ generate\_initial(full\_string):}
    \CommentTok{"""Generates an initial using first symbol.}
\CommentTok{    }
\CommentTok{    Parameters}
\CommentTok{    {-}{-}{-}{-}{-}{-}{-}{-}{-}{-}}
\CommentTok{    full\_string : str}
\CommentTok{    }
\CommentTok{    Returns}
\CommentTok{    {-}{-}{-}{-}{-}{-}{-}{-}{-}{-}}
\CommentTok{    str : single symbol}
\CommentTok{    """}
    \ControlFlowTok{return}\NormalTok{ full\_string[}\DecValTok{0}\NormalTok{]}

\NormalTok{...}
\NormalTok{initial }\OperatorTok{=}\NormalTok{ generate\_initial(}\StringTok{"test"}\NormalTok{)}
\NormalTok{...}
\NormalTok{initial\_for\_file }\OperatorTok{=}\NormalTok{ generate\_initial(filename)}
\NormalTok{...}
\NormalTok{initial\_for\_website }\OperatorTok{=}\NormalTok{ generate\_initial(first\_name)}
\NormalTok{...}
\end{Highlighting}
\end{Shaded}

and here is the ``alternative'' initial computation. Note that the code that uses the function \emph{stays the same}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{def}\NormalTok{ generate\_initial(full\_string):}
    \CommentTok{"""Generates an initial using first TWO symbols.}
\CommentTok{    }
\CommentTok{    Parameters}
\CommentTok{    {-}{-}{-}{-}{-}{-}{-}{-}{-}{-}}
\CommentTok{    full\_string : str}
\CommentTok{    }
\CommentTok{    Returns}
\CommentTok{    {-}{-}{-}{-}{-}{-}{-}{-}{-}{-}}
\CommentTok{    str : two symbols long}
\CommentTok{    """}
    \ControlFlowTok{return}\NormalTok{ full\_string[:}\DecValTok{2}\NormalTok{]}

\NormalTok{...}
\NormalTok{initial }\OperatorTok{=}\NormalTok{ generate\_initial(}\StringTok{"test"}\NormalTok{)}
\NormalTok{...}
\NormalTok{initial\_for\_file }\OperatorTok{=}\NormalTok{ generate\_initial(filename)}
\NormalTok{...}
\NormalTok{initial\_for\_website }\OperatorTok{=}\NormalTok{ generate\_initial(first\_name)}
\NormalTok{...}
\end{Highlighting}
\end{Shaded}

Thus, turning the code into function is particularly useful when the reused code is complex but it pays off even if computation is as simple and trivial as in example above. With a function you have a single code to worry about and you can be sure that same computation is performed whenever you call the function (not the copy of the code that should be identical but may be not).

Note that I put reusable code as the last reason to use functions. This is because the other three reasons are far more important. Having a conceptually clear isolated and testable code is advantages even if you call this function only once. It still makes code easier to understand and to test and helps you to reduce the complexity by replacing code with its meaning. Take a look at the example below. The first code takes the first symbol but this action (taking the first symbol) does not \emph{mean} anything by itself, it is just a mechanical computation. It is only the original context \texttt{initial\_for\_file\ =\ filename{[}0{]}} or additional comments that give it its meaning. In contrast, calling a function called \emph{compete\_initial} tells you what is happening, as it disambiguates the purpose of the computation. I suspect that future-you is very pro-disambiguation and anti-confusion.

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{if}\NormalTok{ filename[}\DecValTok{0}\NormalTok{] }\OperatorTok{==} \StringTok{"A"}\NormalTok{:}
\NormalTok{    ...}
    
\ControlFlowTok{if}\NormalTok{ compute\_initial(filename) }\OperatorTok{==} \StringTok{"A"}\NormalTok{:}
\NormalTok{    ...}
\end{Highlighting}
\end{Shaded}

\hypertarget{defining-a-function-in-python}{%
\section{Defining a function in Python}\label{defining-a-function-in-python}}

A function in Python looks like this (note the indentation)

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{def} \OperatorTok{\textless{}}\NormalTok{function name}\OperatorTok{\textgreater{}}\NormalTok{(param1, param2, ...):}
\NormalTok{    some internal computation}
    \ControlFlowTok{if}\NormalTok{ somecondition:}
        \ControlFlowTok{return}\NormalTok{ some value}
    \ControlFlowTok{return}\NormalTok{ some other value}
\end{Highlighting}
\end{Shaded}

The parameters are optional, so is the return value. Thus the minimal function would be

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{def}\NormalTok{ minimal\_function():}
    \ControlFlowTok{pass} \CommentTok{\# pass means "do nothing"}
\end{Highlighting}
\end{Shaded}

You must defined your function (once!) before calling it (one or more times). Thus, you should create functions \emph{before} the code that uses it (main script or other functions).

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{def}\NormalTok{ do\_something():}
    \CommentTok{"""}
\CommentTok{    This is a function called "do\_something". It actually does nothing.}
\CommentTok{    It requires no input and returns no value.}
\CommentTok{    """}
    \ControlFlowTok{return}
    
    
\KeywordTok{def}\NormalTok{ another\_function():}
\NormalTok{    ...}
    \CommentTok{\# We call it in another function.}
\NormalTok{    do\_something()}
\NormalTok{    ...}
    
    
\CommentTok{\# This is a function call (we use this function)}
\NormalTok{do\_something()}

\CommentTok{\# And we use it again!}
\NormalTok{do\_something()}
\end{Highlighting}
\end{Shaded}

Do exercise \#1.

You must also keep in mind that redefining a function (or defining a different function that has the same name) overwrites the original definition, so that only the latest version of it is retained and can be used.

Do exercise \#2.

Although example in the exercise makes the problem look very obvious, in a large code that spans multiple files and uses various libraries, the issue may not be so straightforward!

\hypertarget{function-arguments}{%
\section{Function arguments}\label{function-arguments}}

Some function may not need arguments (also called parameters), as they perform a fixed action:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{def}\NormalTok{ ping():}
    \CommentTok{"""}
\CommentTok{    Machine that goes "ping!"}
\CommentTok{    """}
    \BuiltInTok{print}\NormalTok{(}\StringTok{"ping!"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

However, typically, you need to pass information to the function, which then affects how the function performs its action. In Python, you simply list arguments within the round brackets after the function name (there are more bells and whistles but we will keep it simple for now). For example, we could write a function that computes and prints person's age given two parameters 1) their birth year, 2) current year:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{def}\NormalTok{ print\_age(birth\_year, current\_year):}
    \CommentTok{"""}
\CommentTok{    Prints age given birth year and current year.}
\CommentTok{    }
\CommentTok{    Parameters}
\CommentTok{    {-}{-}{-}{-}{-}{-}{-}{-}{-}{-}}
\CommentTok{    birth\_year : int}
\CommentTok{    current\_year : int}
\CommentTok{    """}
    \BuiltInTok{print}\NormalTok{(current\_year }\OperatorTok{{-}}\NormalTok{ birth\_year)}
\end{Highlighting}
\end{Shaded}

It is a \textbf{very good idea} to give meaningful names to functions, parameters, and variables. The following code will produce exactly the same result but understanding \emph{why} and \emph{what for} it is doing what it is doing would be much harder (so \textbf{always} use meaningful names!):

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{def}\NormalTok{ x(a, b):}
    \BuiltInTok{print}\NormalTok{(b }\OperatorTok{{-}}\NormalTok{ a)}
\end{Highlighting}
\end{Shaded}

When calling a function, you must pass the correct number of parameters and pass them in a \emph{correct order}, another reason for a function arguments to have meaningful names.

Do exercise \#3.

When you call the function, the values you \emph{pass} to the function are assigned to the parameters and they are used as \emph{local} variables (more on \emph{local} bit later). However, it does not matter \emph{how} you came up with this values, whether they were in a variable, hard-coded, or returned by another function. If you are using numeric, logical, or string values (\emph{immutable} types), you can assume that any link to the original variable or function that produced it is gone (we'll deal with \emph{mutable} types, like lists, later). Thus, when writing a function or reading its code, you just assume that it has been set to some value during the call and you can ignore the context in which this call was made

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# hardcoded}
\NormalTok{print\_age(}\DecValTok{1976}\NormalTok{, }\DecValTok{2020}\NormalTok{)}

\CommentTok{\# using values from variables}
\NormalTok{i\_was\_born }\OperatorTok{=} \DecValTok{1976}
\NormalTok{today\_is }\OperatorTok{=} \DecValTok{2020}
\NormalTok{print\_age(i\_was\_born, today\_is)}

\CommentTok{\# using value from a function}
\KeywordTok{def}\NormalTok{ get\_current\_year():}
    \ControlFlowTok{return} \DecValTok{2020}

\NormalTok{print\_age(}\DecValTok{1976}\NormalTok{, get\_current\_year())}
\end{Highlighting}
\end{Shaded}

\hypertarget{functions-returned-value-output}{%
\section{Functions' returned value (output)}\label{functions-returned-value-output}}

Your function may perform an action without returning any value to the caller (this is what out \texttt{print\_age} function was doing). However, you may need to return the value instead. For example, to make things more general, we might want write a new function called \texttt{compute\_age} that return the age instead of printing it (we can always print ourselves).

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{def}\NormalTok{ compute\_age(birth\_year, current\_year):}
    \CommentTok{"""}
\CommentTok{    Computes age given birth year and current year.}

\CommentTok{    Parameters}
\CommentTok{    {-}{-}{-}{-}{-}{-}{-}{-}{-}{-}}
\CommentTok{    birth\_year : int}
\CommentTok{    current\_year : int}
\CommentTok{    }
\CommentTok{    Returns}
\CommentTok{    {-}{-}{-}{-}{-}{-}{-}{-}{-}{-}}
\CommentTok{    int : age}
\CommentTok{    """}
    \ControlFlowTok{return}\NormalTok{ current\_year }\OperatorTok{{-}}\NormalTok{ birth\_year}
\end{Highlighting}
\end{Shaded}

Note that even if a function returns the value, it is retained only if it is actually used (stored in a variable, used as a value, etc.). Thus, just calling it will not by itself store the returned value anywhere!

Do exercise \#4.

\hypertarget{scopes-for-immutable-values}{%
\section{Scopes (for immutable values)}\label{scopes-for-immutable-values}}

As we have discussed above, turning code into a function \emph{isolates} it, so makes it run in it own \emph{scope}. In Python, each variable exists in the \emph{scope} it has been defined in. If it was defined in the \emph{global} script, it exists in that \emph{global} scope as a \emph{global} variable. However, it is not accessible (at least not without special effort via a \texttt{global} operator) from within a function. Conversely, function's parameters and any variable defined \emph{inside a function}, exists and is accessible only \textbf{inside that function}. It is fully invisible for the outside world and cannot be accessed from a global script or from another function. Conversely, any changes you make to the function parameter or local variable have no effect on the outside world (well, almost, \emph{mutable} objects list lists are more complicated, more on that later).

The purpose of scopes is to isolate individual code segments from each other, so that modifying variables within one scope has no effect on all other scopes. This means that when writing or debugging the code, you do not need to worry about code in other scopes and concentrate only on the code you working on. Because scopes are isolated, they may have \emph{identically named variables} that, however, have no relationship to each other as they exists in their own parallel universes. Thus, if you want to know which value a variable has, you must look only within the scope and ignore all other scopes (even if the names match!).

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# this is variable \textasciigrave{}x\textasciigrave{} in the global scope}
\NormalTok{x  }\OperatorTok{=} \DecValTok{5} 

\KeywordTok{def}\NormalTok{ f1():}
  \CommentTok{\# This is variable \textasciigrave{}x\textasciigrave{} in the scope of function f1}
  \CommentTok{\# It has the same name as the global variable but}
  \CommentTok{\# has no relation to it: many people are called Sasha }
  \CommentTok{\# but they are still different people. Whatever you}
  \CommentTok{\# happens to \textasciigrave{}x\textasciigrave{} in f1, stays in f1\textquotesingle{}s scope.}
\NormalTok{  x }\OperatorTok{=} \DecValTok{3}
  
  
\KeywordTok{def}\NormalTok{ f2(x):}
  \CommentTok{\# This is parameter \textasciigrave{}x\textasciigrave{} in the scope of function f2.}
  \CommentTok{\# Again, no relation to other global or local variables.}
  \CommentTok{\# It is a completely separate object, it just happens to }
  \CommentTok{\# have the same name (again, just namesakes)}
  \BuiltInTok{print}\NormalTok{(x)}
\end{Highlighting}
\end{Shaded}

Do exercise \#5.

\hypertarget{create-input_int}{%
\section{\texorpdfstring{Create \emph{input\_int()}}{Create input\_int()}}\label{create-input_int}}

Let us create the first function called \texttt{input\_int}. It will take have no arguments (yet) and will return an integer value. This will encapsulate the checks and repeated prompts inside the function, making it easier to maintain the code. It will also make your top-level code cleaner as multiple lines are now replaced with a single call to a function \texttt{input\_int()}, so you know that in this line you get an integer input from the user. This helps you to concentrate on what is happening (``I am getting an integer input'') not how it is happening.

So let us re-implement the code that you created during the last seminar as a function with the only difference is that you \texttt{return} the user input instead of using the variable's value directly. I would recommend implementing the code in a separate cell without the function header (\texttt{def\ input():}) and the \texttt{return} statements first. Once it works, you can indent it and add the function header. Next, test it by calling the function (e.g.~\texttt{guess\ =\ input\_int()} or just \texttt{input\_int()}), to see that it works reliably, i.e.~keeps prompting you until you enter a valid integer.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{def}\NormalTok{ input\_int():}
\NormalTok{  get user }\BuiltInTok{input} \KeywordTok{and}\NormalTok{ store it }\KeywordTok{in}\NormalTok{ a local variable}
  \ControlFlowTok{while}\NormalTok{ it cannot be converted to an integer:}
\NormalTok{    remind the player that it must enter an integer}
\NormalTok{    get user }\BuiltInTok{input} \KeywordTok{and}\NormalTok{ store it }\KeywordTok{in}\NormalTok{ a local variable}
    
  \ControlFlowTok{return} \BuiltInTok{input}\OperatorTok{{-}}\ImportTok{as}\OperatorTok{{-}}\NormalTok{an}\OperatorTok{{-}}\NormalTok{integer}
\end{Highlighting}
\end{Shaded}

Put your code into exercise \#6.

\hypertarget{documenting-input_int}{%
\section{\texorpdfstring{Documenting \emph{input\_int()}}{Documenting input\_int()}}\label{documenting-input_int}}

Writing a function is only half the job. You need to document it! This may feel excessive but it does not take much time and it is a good habit that makes your code easy to use and reuse. Document your code (a function, or a class, or a module) even if you just trying things out. Remember, ``there is nothing more permanent than a temporary solution.'' Not documenting code is a false economy: a few minutes you save on not documenting it, will translate into dozens of them when you try to understand and debug undocumented code later on.

There are different ways to document the code but we will use \href{https://numpydoc.readthedocs.io/en/latest/format.html\#docstring-standard}{NumPy docstring convention}. Here is an example of such documented function

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{def}\NormalTok{ generate\_initial(full\_string):}
    \CommentTok{"""Generates an initial using first symbol.}
\CommentTok{    }
\CommentTok{    Parameters}
\CommentTok{    {-}{-}{-}{-}{-}{-}{-}{-}{-}{-}}
\CommentTok{    full\_string : str}
\CommentTok{    }
\CommentTok{    Returns}
\CommentTok{    {-}{-}{-}{-}{-}{-}{-}{-}{-}{-}}
\CommentTok{    str : single symbol}
\CommentTok{    """}
    \ControlFlowTok{return}\NormalTok{ full\_string[}\DecValTok{0}\NormalTok{]}
\end{Highlighting}
\end{Shaded}

Take the look at the \href{https://numpydoc.readthedocs.io/en/latest/format.html\#docstring-standard}{manual} and document the function NumPy style. You will only need one-line summary and return value information.

Put your code into exercise \#7.

\hypertarget{adding-prompt-parameter-to-input_int}{%
\section{\texorpdfstring{Adding prompt parameter to \emph{input\_int()}}{Adding prompt parameter to input\_int()}}\label{adding-prompt-parameter-to-input_int}}

So far the input function you called inside our \texttt{input\_int()} function either had no prompt or had some fixed prompt that you hard-coded. However, we will use this function for two different actions: moving (the only thing player can do now) and shooting an arrow (we are hunting the Wumpus, after all!). These two actions require two different prompts, so it makes sense to add an \emph{argument} \texttt{prompt} to our \texttt{input\_int()} function.

You assume that this argument is a string that you need to pass on to the \texttt{input()} function you are using inside. Thus, you would be able to call your function (almost) the same way as you called \texttt{input()}, e.g.~\texttt{input\_int("Please\ enter\ the\ cave\ index")}, but are guaranteed to get an integer value, as all the check and repeated prompts occur inside of the function.

Put your code into exercise \#8.

\hypertarget{using-the-function-in-the-code}{%
\section{Using the function in the code}\label{using-the-function-in-the-code}}

Now we have a function that makes our code cleaner and easier to understand, so let us use it! Copy-paste your final game code for the previous seminar and alter it to use \texttt{input\_int()} in place of \texttt{input()} + checks + type-conversion. In this modified code, put the function declaration after the import and a constant definition but before the rest of the code.

Put your code into exercise \#9.

\hypertarget{create-input_cave-function}{%
\section{\texorpdfstring{Create \emph{input\_cave()} function}{Create input\_cave() function}}\label{create-input_cave-function}}

You implemented a function that get an \emph{integer} input from the player. This is a good first step, as it takes care of all the checks that the value is of the correct type. However, we are not interested in getting an integer per se, we are interested in getting the index of the cave the player wants to move to and this index must be \emph{correct}, as in match the index of accessible caves.

Let us implement a function that does just that. We will call it \texttt{input\_cave}, it will have a single argument \texttt{accesible\_caves} (the assumed value is the list of accessible caves), and it will return a integer: the index of the cave the player picked. In the function, you need to print the cave indexes and ask about which cave the player wants to go to until they give a valid answer. Note that you do not need to re-implement the \texttt{input\_int()} functionality inside, you use that function to get an integer and perform additional checks that integer is \texttt{in} the list. Don't forget to document and test it!

Put your code into exercise \#10.

Now copy-paste the code from exercise \#9 and alter it to use \texttt{input\_cave} in place of \texttt{input\_int()} + checks code.

Put your code into exercise \#11.

\hypertarget{create-find_empty_cave-function}{%
\section{\texorpdfstring{Create \emph{find\_empty\_cave()} function}{Create find\_empty\_cave() function}}\label{create-find_empty_cave-function}}

As final modification for today, let us spin-off the code that places the player into a random cave into a separate function. We will call it \texttt{find\_empty\_cave} and, currently, it will have just one parameter \texttt{caves\_number} (the total number of caves), and it will generate and return a random number between \texttt{0} and \texttt{caves\_number\ -\ 1}. Its functionality will be identical to the simple call you are already making in your code, so this may feel unnecessary. However, later we will be placing other objects (bottomless pits, bats, the Wumpus), so we will need a function that can find an empty (unoccupied) cave with all the necessary lack-of-conflict checks. The current function, however limited, will serve as a foundation for our development during the next seminar.

Do not forget to document and test the function.
::: \{.infobox .program\}
Put your code into exercise \#12.
:::

Now copy-paste the code from exercise \#11 and alter it to use \texttt{find\_empty\_cave} function.

Put your code into exercise \#13.

Your final code should look roughly as follows and, as you can see, the main script is now slim and easy to follow.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# import randint function from the random library}

\CommentTok{\# define CAVES (simply copy{-}paste the definition)}

\CommentTok{\# define input\_int function}
\CommentTok{\# define input\_cave function}
\CommentTok{\# define find\_empty\_cave function}

\CommentTok{\# create \textasciigrave{}player\textasciigrave{} variable and put him into an empty (unoccupied) cave}

\CommentTok{\# while player is not in the cave \#5 (index 4):}
    \CommentTok{\# get input on which cave the player wants to move to}
    \CommentTok{\# move the player to that cave}

\CommentTok{\# print a nice game{-}over message}
\end{Highlighting}
\end{Shaded}

\hypertarget{seminar06}{%
\chapter{Hunt the Wumpus, part 3}\label{seminar06}}

During the last seminar, we used functions to make out code modular. Now, let us add more bells-and-whistles to the game: bottomless pits, crazy bats, and the Wumpus itself. Don't forget to download the \href{notebooks/Seminar\%2006.\%20Hunt\%20the\%20Wumpus,\%20part\%203.ipynb}{exercise notebook}.

Before we continue with the game, I would like to introduce the critical difference between \emph{mutable} and \emph{immutable} types.

\hypertarget{recall-variables-as-boxes-immutable-objects}{%
\section{Recall, Variables as Boxes (immutable objects)}\label{recall-variables-as-boxes-immutable-objects}}

You may remember the \emph{variable-as-a-box} metaphor. Just to remind you, a variable is ``box'' with the variable name written on it and a value is stored ``inside''. When you use this value or assign it to a different variable, you can assume that Python \emph{makes a copy} of it (not really, but this makes it easier to understand) and puts that copy into a different variable ``box''. When you \emph{replace} value of a variable, what happens is that you take out the old value, destroy it (by throwing into a nearest black hole), create a new one, and put it into the variable ``box''. When you \emph{change} the value of a variable based on its current state, the same thing happens. You take out the value, create a new value (by adding to the original one or doing some other operation), destroy the old one, and put it back into the variable ``box''.

This metaphor works nicely and explains why the scopes work the way they do (see the Scopes part in the previous seminar). Each scope has its own set of boxes and whenever you pass information between the scopes, e.g.~from a global script to a function, a copy of value is created and put into a new box (i.e., parameter) inside the function. When the function returns the value, that is copied and put in one of the boxes in the global script, etc.

Unfortunately, this is true only for \emph{immutable} objects (values) such as numbers, strings, logical values, but also \href{https://docs.python.org/3/library/stdtypes.html?highlight=tuple\#tuple}{tuples} (see below for what these are). As you could have guessed from the name, this means that there are other \emph{mutable} objects and they behave very differently.

\hypertarget{mutable-objects}{%
\section{Variables as post-it stickers (mutable objects)}\label{mutable-objects}}

Mutable objects are lists, dictionaries, and classes. The difference is that \emph{immutable} objects can be thought as fixed in their size. A number takes up that many bytes to store, same goes for a given string (although a different string would require more or fewer bytes). Still, they do not change, they are created and destroyed when unneeded but never truly updated.

\emph{Mutable} objects can be changed. For example, you can add elements to your list, or remove them, or shuffle them. Same goes for \href{https://docs.python.org/3/tutorial/datastructures.html?highlight=dictionary\#dictionaries}{dictionaries}. Making such object \textbf{immutable} would be computationally inefficient (every time you add a value a long list is destroyed and recreated with just that one additional value), which is why Python simply \emph{updates} the original object. For further computation efficiency, these objects are not copied but \emph{passed by reference}. This means that the variable is no longer a ``box'' but a ``sticker'' you put on an object (a list, a dictionary). And, you can put as many stickers on an object as you want \textbf{and it still will be the same object!}

What on Earth do I mean? Keeping in mind that a variable is just (one of many) stickers for a mutable object, try figuring out what will be the output below:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x }\OperatorTok{=}\NormalTok{ [}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{]}
\NormalTok{y }\OperatorTok{=}\NormalTok{ x}
\NormalTok{y.append(}\DecValTok{4}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(x)}
\end{Highlighting}
\end{Shaded}

Do exercise \#1.

What? Why? ``But I didn't touch \texttt{x}, only \texttt{y}'' I hear you say? That is precisely what I have meant with ``stickers on the same object''. Since both \texttt{x} and \texttt{y} are stickers on the \emph{same} object, they are, effectively, synonyms. In that specific situation, once you set \texttt{x\ =\ y}, it does not matter which variable name you use to change \emph{the} object, they are just two stickers hanging side-by-side on the \emph{same} list. Again, just a reminder, this is \textbf{not} what would happen for \textbf{immutable} values, like numbers, where things would behaved the way you expect them to behave.

This variable-as-a-sticker, aka ``passing value by reference'', has very important implications for the function calls, as it breaks your scope without ever giving you a warning. Look at the code below and try figuring out what the output will be.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{def}\NormalTok{ change\_it(y):}
\NormalTok{    y.append(}\DecValTok{4}\NormalTok{)}

\NormalTok{x }\OperatorTok{=}\NormalTok{ [}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{]}
\NormalTok{change\_it(x)}
\BuiltInTok{print}\NormalTok{(x)}
\end{Highlighting}
\end{Shaded}

Do exercise \#2.

How did we manage to modify a \emph{global} variable from inside the function? Didn't we change the \emph{local} parameter of the function? Yep, that is exactly the problem with passing by reference. Your function parameter is just another sticker on the \emph{same} object, so even though it \emph{looks} like you do not need to worry about global variables (that's why you wrote the function!), you still do. If you are perplexed by this, you are in a good company. This is one of the most unexpected and confusing bits in Python that routinely catches people by surprise. Let us do a few more exercises, before I show you how to solve the scope problem for the mutable objects.

Do exercise \#3.

\hypertarget{tuple-a-frozen-list}{%
\section{Tuple: a frozen list}\label{tuple-a-frozen-list}}

The wise people who created Python were acutely aware of the problem that the \emph{variable-as-a-sticker} creates. Which is why, they added an \textbf{immutable} version of a list, called a \href{https://docs.python.org/3/library/stdtypes.html?highlight=tuple\#tuple}{tuple}. It is a ``frozen'' list of values, which you can loop over, access its items by index, or figure out how many items it has, but you \emph{cannot modify it}. No appending, removing, replacing values, etc. For you this means that a frozen list is a box rather than a sticker and that it behaves just like any other ``normal'' \textbf{immutable} object. You can create a \texttt{tuple} by using round brackets.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{i\_am\_a\_tuple }\OperatorTok{=}\NormalTok{ (}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

You can loop over it, \emph{e.g.}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{i\_am\_a\_tuple }\OperatorTok{=}\NormalTok{ (}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{)}
\ControlFlowTok{for}\NormalTok{ number }\KeywordTok{in}\NormalTok{ i\_am\_a\_tuple:}
    \BuiltInTok{print}\NormalTok{(number)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## 1
## 2
## 3
\end{verbatim}

but, as I said, appending will throw a mistake (try this code in a cell)

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{i\_am\_a\_tuple }\OperatorTok{=}\NormalTok{ (}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{)}

\CommentTok{\# throws AttributeError: \textquotesingle{}tuple\textquotesingle{} object has no attribute \textquotesingle{}append\textquotesingle{}}
\NormalTok{i\_am\_a\_tuple.append(}\DecValTok{4}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Same goes for trying to change it

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{i\_am\_a\_tuple }\OperatorTok{=}\NormalTok{ (}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{)}

\CommentTok{\# throws TypeError: \textquotesingle{}tuple\textquotesingle{} object does not support item assignment}
\NormalTok{i\_am\_a\_tuple[}\DecValTok{1}\NormalTok{] }\OperatorTok{=} \DecValTok{1} 
\end{Highlighting}
\end{Shaded}

This means that when you need to pass a list of values to a function, you should instead pass \emph{a tuple of values} to the function. The function still has a list of values but the link to the original list object is now broken. You can turn a list into a tuple using \texttt{tuple()}. Keeping in mind that \texttt{tuple()} creates a frozen copy of the list, what will happen below?

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x }\OperatorTok{=}\NormalTok{ [}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{]}
\NormalTok{y }\OperatorTok{=} \BuiltInTok{tuple}\NormalTok{(x)}
\NormalTok{x.append(}\DecValTok{4}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(y)}
\end{Highlighting}
\end{Shaded}

Do exercise \#4.

As you probably figured out, when \texttt{y\ =\ tuple(x)}, Python creates \textbf{a copy} of the list values, freezes them (they are immutable now), and puts them into the ``y'' box. Hence, whatever you do to the original list, has no effect on the immutable ``y''.

Conversely, you ``unfreeze'' a tuple by turning it into a list via \texttt{list()}. Please note that it creates \textbf{a new list}, which has no relation to any other existing list, even if values were originally taken from any of them!

Do exercise \#5.

Remember I just said that list() creates a new list? This means that you can use it to create a copy of a list directly, without an intermediate tuple step. You can also achieve the same results by slicing an entire list, e.g.~\texttt{list(x)}, is the same as \texttt{x{[}:{]}}.

Do exercise \#6.

Here, y = list(x) created a new list (which was a carbon copy of the one with the ``x'' sticker on it) and the ``y'' sticker was put on that new list, while the ``x'' remained hanging on the original.

Confusing? You bet! If you feel overwhelmed by this whole mutable/immutable, tuple/list, copy/reference mess, you are just being a normal human being. I understand the reasons for doing things this way and I am aware of this difference but it still catches me by suprise occasionally!

\hypertarget{keeping-track-of-occupied-caves}{%
\section{Keeping track of occupied caves}\label{keeping-track-of-occupied-caves}}

So far, we had only the player to keep the track of and we were doing it by storing their location in the \texttt{player} variable. However, as we will add more game objects (bottomless pits, bats, the Wumpus), we need to keep the track of who-is-where, so that we don't place them in an already occupied cave. For this, we will keep a \emph{list} of occupied caves (let's call the variable \texttt{occupied\_caves}). We will initialize it as empty list (you can make an empty list via either \texttt{{[}{]}} or \texttt{list()}) and then \href{https://docs.python.org/3.8/tutorial/datastructures.html\#more-on-lists}{append} to it (e.g., \texttt{list.append(new\_value)}). We will pass this list to \texttt{find\_empty\_cave} function as a second argument and we will modify the function to generate an index of the cave \emph{not} in that list.

Let us start with the function, add a second argument to it (call it \texttt{caves\_taken} or something along these lines) and modify the code so the it keeps randomly generating cave index until it is \emph{not} in the \texttt{caves\_taken} list. Remember to document the code and test the code by passing a list of hard-coded values to see that it never returns value from the list (e.g., \texttt{find\_empty\_cave(len(CAVES),\ {[}2,\ 5,\ 7{]})}).

Put your code into exercise \#7.

Now we need to modify the main script to take advantage of the update \texttt{find\_empty\_cave()}. Here is the outline

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# import randint function from the random library}

\CommentTok{\# define CAVES}

\CommentTok{\# define input\_int function}
\CommentTok{\# define input\_cave function}
\OperatorTok{{-}\textgreater{}} \CommentTok{\# define updated find\_empty\_cave function }

\OperatorTok{{-}\textgreater{}} \CommentTok{\# create \textasciigrave{}occupied\_caves\textasciigrave{} variable and initialize it to an empty list}
\OperatorTok{{-}\textgreater{}} \CommentTok{\# create \textasciigrave{}player\textasciigrave{} variable and put him into an empty (unoccupied) cave (use \textasciigrave{}occupied\_caves\textasciigrave{} when calling the function)}
\OperatorTok{{-}\textgreater{}} \CommentTok{\# append player location to the \textasciigrave{}occupied\_caves\textasciigrave{} list for future use}

\CommentTok{\# while player is not in the cave \#5 (index 4):}
    \CommentTok{\# get input on which cave the player wants to move to}
    \CommentTok{\# move the player to that cave}

\CommentTok{\# print a nice game{-}over message}
\end{Highlighting}
\end{Shaded}

Put your code into exercise \#8.

Now that we have the scaffolding in place, let us add bottomless pits. But before that, you need to learn about \href{https://docs.python.org/3/tutorial/controlflow.html\#for-statements}{for} loops and \href{https://docs.python.org/3/tutorial/controlflow.html\#the-range-function}{range}.

\hypertarget{for-loop}{%
\section{For loop}\label{for-loop}}

The \href{https://docs.python.org/3/tutorial/controlflow.html\#for-statements}{for} loop iterates over sequence of items. Generally speaking, for loop loops over items that are in \emph{iterable} containers or yielded by \emph{generators}. We won't go into exact details of what these are and how their are implemented. For now, you just need to know that there are two kinds of things a for loop can iterate over and that they differ in whether they produce a finite number of elements to loop over (iterable containers) or a potentially endless number of elements to iterate over (generators). An example of the former is a list (an iterable container that holds a finite number of items), an example of the latter is a \texttt{range()} function, which we will discuss separately below.

To iterate over items in the list, you simply write

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{for}\NormalTok{ item }\KeywordTok{in} \BuiltInTok{list}\NormalTok{:}
\NormalTok{  ...}
\NormalTok{  do something }\ControlFlowTok{with}\NormalTok{ an item }\KeywordTok{or}\NormalTok{ just do something}
\NormalTok{  ...}
\end{Highlighting}
\end{Shaded}

For example, you can print every item of the list one-by-one. The loop will be executed three times (there are three items in the list) and on each iteration the \texttt{item} variable will take the value of the corresponding element: \texttt{"A"} on the first iteration, \texttt{"B"} on the second, \texttt{"C"} on the third.

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{for}\NormalTok{ item }\KeywordTok{in}\NormalTok{ [}\StringTok{"A"}\NormalTok{, }\StringTok{"C"}\NormalTok{, }\StringTok{"K"}\NormalTok{]:}
    \BuiltInTok{print}\NormalTok{(}\StringTok{"Item is }\SpecialCharTok{\%s}\StringTok{"}\OperatorTok{\%}\NormalTok{(item))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## Item is A
## Item is C
## Item is K
\end{verbatim}

Do exercise \#9.

\hypertarget{range}{%
\section{range()}\label{range}}

Sometimes you need to repeat an action several times (e.g., in our code below, we will need to add two bottomless pits) or iterate over sequence of numbers. You can write down such list by hand, e.g.~\texttt{{[}0,\ 1,\ 2{]}}, but an easier way is to use \href{https://docs.python.org/3/library/stdtypes.html\#range}{range(start, stop, step)} function that generates a sequence of numbers from \texttt{start} until-but-not-including \texttt{stop} with a given \texttt{step}. If you omit the \texttt{step}, it is assumed to be \texttt{1}. You can also pass just one value that is interpreted as \texttt{stop} with \texttt{start=0} and \texttt{step=1}. Thus, \texttt{range(3)} is the same as \texttt{range(0,\ 3)} and \texttt{range(0,\ 3,\ 1)}.

Important note, \texttt{range()} function does not produce a list of values but a \emph{generator} that yields values one at a time. You can see it by calling this function in isolation

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{range}\NormalTok{(}\DecValTok{3}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## range(0, 3)
\end{verbatim}

The generators are functions (or objects) that yield items upon request, which makes them ``lazy'' but more memory efficient. E.g., if you want to iterate over 1,000,000 numbers, you do not need to generate a 1,000,000 number long list (takes memory), you just need to get numbers from that sequence one a time. You can convert a generator into a list via \texttt{list()} function

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{list}\NormalTok{(}\BuiltInTok{range}\NormalTok{(}\DecValTok{3}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [0, 1, 2]
\end{verbatim}

The reason for distinction between generators and iterable containers like lists, is that generator sequences can be unlimited. For example, you can have a generator that yields a new random number upon request. It will never run out of items to yield and trying to convert it to a list would be a bad idea as an infinitely long list requires infinite amount of memory!

Do exercise \#10.

\hypertarget{placing-bottomless-pits}{%
\section{Placing bottomless pits}\label{placing-bottomless-pits}}

Now we can add bottomless pits to the game. The idea is simple, we place two of those in random caves, so when the player wanders into a cave with a bottomless pit, they fall down and die (game over). We will, however, warn the player, that their current cave is next to a bottomless pit, without telling them which cave it is in specifically.

First thing first, let us add them. For this, we will create a new constant \texttt{NUMBER\_OF\_BOTTOMLESS\_PITS} (I suggest that we set it to \texttt{2} but you can have more or fewer of them) and a new variable (\texttt{bottomless\_pits}) that will hold a list of indexes of caves with the bottomless pits in them. Add bottomless pits to using using a for loop: On each iteration get an index of an empty cave (via \texttt{find\_empty\_cave} functionm think about its parameters), append this index to both 1) \texttt{bottomless\_pits} and 2) \texttt{occupied\_caves} variables, so that you 1) know where bottomless pits are and 2) know which caves are occupied. Here is the code outline for the initialization part (do not copy paste the main loop just yet). See if numbers makes sense (number of caves is what you expected them to be, value are within the range, there are no duplicates, etc.)

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# import randint function from the random library}

\CommentTok{\# define CAVES}
\OperatorTok{{-}\textgreater{}} \CommentTok{\# define NUMBER\_OF\_BOTTOMLESS\_PITS}

\CommentTok{\# define input\_int function}
\CommentTok{\# define input\_cave function}
\CommentTok{\# define find\_empty\_cave function}

\CommentTok{\# create \textasciigrave{}occupied\_caves\textasciigrave{} variable and initialize it to an empty list}
\CommentTok{\# create \textasciigrave{}player\textasciigrave{} variable and put him into an empty (unoccupied) cave (use \textasciigrave{}occupied\_caves\textasciigrave{} when calling the function)}
\CommentTok{\# append player location to the \textasciigrave{}occupied\_caves\textasciigrave{} list for future use}

\OperatorTok{{-}\textgreater{}} \CommentTok{\# create \textasciigrave{}bottomless\_pits\textasciigrave{} variable and initialize it to an empty list}
\OperatorTok{{-}\textgreater{}} \CommentTok{\# use for loop and range function to repeat the for loop NUMBER\_OF\_BOTTOMLESS\_PITS times}
\OperatorTok{{-}\textgreater{}} \CommentTok{\#     generate a new location for the bottomless pit via find\_empty\_cave() function}
\OperatorTok{{-}\textgreater{}} \CommentTok{\#     append this location to \textasciigrave{}occupied\_caves\textasciigrave{} variable}
\OperatorTok{{-}\textgreater{}} \CommentTok{\#     append this location to \textasciigrave{}bottomless\_pits\textasciigrave{} variable}


\OperatorTok{{-}\textgreater{}} \CommentTok{\# print out both player and bottomless\_pits variables for diagnostics}
\end{Highlighting}
\end{Shaded}

Put your code into exercise \#11.

\hypertarget{falling-into-a-bottomless-pit}{%
\section{Falling into a bottomless pit}\label{falling-into-a-bottomless-pit}}

Now we will add one of the ways for the game to be over: the player falls into a bottomless pit. For this, we just need to check whether player is currently in a cave that has a bottomless pit in on every turn. If that is the case, player's cave is indeed in the bottomless pits list, print a sad game over message and \texttt{break} out of the loop. In addition, let us modify the \texttt{while} loop condition to \texttt{while\ True:}, so that the only way to end the game is to fall into the pit (not exactly fair to the player, but we'll fix that later). The outline of the updated code is as follows:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# import randint function from the random library}

\CommentTok{\# define CAVES}
\CommentTok{\# define NUMBER\_OF\_BOTTOMLESS\_PITS}

\CommentTok{\# define input\_int function}
\CommentTok{\# define input\_cave function}
\CommentTok{\# define find\_empty\_cave function}

\CommentTok{\# create \textasciigrave{}occupied\_caves\textasciigrave{} variable and initialize it to an empty list}
\CommentTok{\# create \textasciigrave{}player\textasciigrave{} variable and put him into an empty (unoccupied) cave (use \textasciigrave{}occupied\_caves\textasciigrave{} when calling the function)}
\CommentTok{\# append player location to the \textasciigrave{}occupied\_caves\textasciigrave{} list for future use}

\CommentTok{\# create \textasciigrave{}bottomless\_pits\textasciigrave{} variable and initialize it to an empty list}
\CommentTok{\# use for loop and range function to repeat the for loop NUMBER\_OF\_BOTTOMLESS\_PITS times}
\CommentTok{\#     generate a new location for the bottomless pit via find\_empty\_cave() function}
\CommentTok{\#     append this location to \textasciigrave{}occupied\_caves\textasciigrave{} variable}
\CommentTok{\#     append this location to \textasciigrave{}bottomless\_pits\textasciigrave{} variable}

\OperatorTok{{-}\textgreater{}} \CommentTok{\# print out both player and bottomless\_pits variables for diagnostics}

\OperatorTok{{-}\textgreater{}} \CommentTok{\# while True:}
    \CommentTok{\# get input on which cave the player wants to move to}
    \CommentTok{\# move the player to that cave}
    
    \OperatorTok{{-}\textgreater{}} \CommentTok{\# if players in a cave with bottomless pit:}
    \OperatorTok{{-}\textgreater{}}      \CommentTok{\# print out sad game{-}over message}
    \OperatorTok{{-}\textgreater{}}      \CommentTok{\# break out of the loop}
\end{Highlighting}
\end{Shaded}

Put your code into exercise \#12.

\hypertarget{warning-about-a-bottomless-pit}{%
\section{Warning about a bottomless pit}\label{warning-about-a-bottomless-pit}}

We need to give the player a chance to avoid the fate of falling into a bottomless pit but warning him that one (or two) are nearby. To this end, we need to print additional information before they decide to make their move. In a for loop, iterate over the connected caves and every time cave has a bottomless pit in it, print ``You feel a breeze!''. This informs the player that the cave is nearby and the number of messages tells them just how many bottomless pits are nearby.

Put your code into exercise \#13.

\hypertarget{placing-bats}{%
\section{Placing bats}\label{placing-bats}}

We need more thrills! Let us add bats to the fray. They live in caves, the player can hear them, if they are in a connect cave (``You hear flapping!''), but if the player inadvertently enters the cave with bats, they carry the player to a \emph{random} cave.

Placing the bats is analogous to placing bottomless pits. You need a constant that determines the number of bat colonies (e.g., \texttt{NUMBER\_OF\_BATS} and set it \texttt{2} or some other number you prefer), a variable that holds a list with indexes of caves with bats (e.g., \texttt{bats}), and you need to pick random empty caves and store them in \texttt{bats} in exactly the same way you did it with bottomless pits. Print out location of bats for diagnostic purposes.

Put your code into exercise \#14.

\hypertarget{warned-about-bats}{%
\section{Warned about bats}\label{warned-about-bats}}

In the same loop over connected caves that you use to warn the player about bottomless pits, add another check that prints out \texttt{"You\ hear\ flapping!"} every time the connected cave have bats in it.

Put your code into exercise \#15.

\hypertarget{transported-by-bats-to-a-random-cave}{%
\section{Transported by bats to a random cave}\label{transported-by-bats-to-a-random-cave}}

If the player is in the cave with bats, they transport them to a \emph{random} cave, irrespective of whether the cave is occupied or not. Thus, bats can carry the player to a cave:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  with another bat colony and it will transport the player again.
\item
  with a bottomless pit and the player will fall into it.
\item
  later on, to the cave with the Wumpus (the player may not survive that one).
\end{enumerate}

Think about:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  \emph{when} you check for bats presence (before or after checking for a bottomless pit?),
\item
  do you check once (using \texttt{if}) or one-or-more times (using \texttt{while})
\end{enumerate}

Put your code into exercise \#16.

Next time, we will finish the game by adding the Wumpus and the arrows.

\hypertarget{seminar07}{%
\chapter{Hunt the Wumpus, part 4}\label{seminar07}}

Our game is almost complete, we only need to add the Wumpus and arm the player with crooked arrows! Grab the \href{notebooks/Seminar\%2007.\%20Hunt\%20the\%20Wumpus,\%20part\%204.ipynb}{exercise notebook} and let get busy.

\hypertarget{adding-wumpus.}{%
\section{Adding Wumpus.}\label{adding-wumpus.}}

By now you have added a player (single, location stored as in integer), bottomless pits (plural, locations stored in a list), and bats (plural as well). Add Wumpus!

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Create a new variable (\texttt{wumpus}?) and place Wumpus in an unoccupied cave. Print out location of Wumpus for debugging purposes.
\item
  Warn about Wumpus in the same code that warns about pits and bats. Canonical warning text is \texttt{"You\ smell\ a\ Wumpus!"}.
\item
  Check if player is in the same cave as Wumpus. If that is the case, game is over, as the player is eaten by a hungry Wumpus. This is similar to \emph{game-over} due to falling into a bottomless pit. Think about whether the check should before or after check for bats.
\end{enumerate}

Put your code into exercise \#1.

\hypertarget{giving-player-a-chance.}{%
\section{Giving player a chance.}\label{giving-player-a-chance.}}

Let us give player a chance. As they enter the cave with the Wumpus, they startle it. Then, Wumpus either runs away to a random adjacent cave (new) or stays put and eats the player. First, create a new constant that defines a probability that Wumpus runs away, e.g.~\texttt{P\_WUMPUS\_SCARED}. In implementations I've found, it is typically 0.25, but use any value you feel is reasonable.

Thus, if the player is in the cave with Wumpus, draw a random number between 0 and 1. The function you are looking for is \href{https://docs.python.org/3/library/random.html\#random.random}{random()} and it is part of \href{https://docs.python.org/3/library/random.html}{random} library, so the call is \texttt{random.random()}. Remember that you can either import the \emph{entire} library and then call its function by prefixing them with the library name or you can import only a specific function via \texttt{from\ ...\ import\ ...}.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\#1  import entire library}
\ImportTok{import}\NormalTok{ random}

\NormalTok{random.random()}
\NormalTok{random.randint(}\DecValTok{5}\NormalTok{)}

\CommentTok{\# import only functions you need}
\ImportTok{from}\NormalTok{ random }\ImportTok{import}\NormalTok{ randint, random}

\NormalTok{random()}
\NormalTok{randint()}
\end{Highlighting}
\end{Shaded}

If that number is smaller than probability that the Wumpus is scared, move it to a random adjacent cave (bats ignore Wumpus and it clings to the ceiling of the caves, so bottomless pits are not a problem for it). A useful function is \href{https://docs.python.org/3/library/random.html\#random.choice}{choice()}, again, part of \href{https://docs.python.org/3/library/random.html}{random} library. Otherwise, if Wumpus was not scared off, the player is eaten and game is over (the only outcome in exercise \#1).

Put your code into exercise \#2.

\hypertarget{flight-of-a-crooked-arrow}{%
\section{Flight of a crooked arrow}\label{flight-of-a-crooked-arrow}}

Our player is armed with \emph{crooked} arrows that can fly through caves. The rules for its flight are the following:

\begin{itemize}
\tightlist
\item
  The player decide in which cave it shoots an arrow and how far the arrow flies (from 1 up to 5 caves).
\item
  Every time the arrow needs to flight into a next cave, that cave is picked randomly from adjacent caves \emph{excluding} the cave it came from (so, the arrow cannot make a 180° turn and there are only two out of three caves available for choosing).
\item
  If the arrow flies into a cave with Wumpus, it is defeated and the game is won.
\item
  If the arrow flies into a cave with the player, then they committed unintentional suicide and the game is lost.
\item
  If the arrow reached it last cave (based on how far the player wanted to shoot) and the cave is empty, it drops down on the floor.
\item
  Bats or bottomless pits have no effect on the arrow.
\end{itemize}

The total number of arrows the player has at the beginning should be defined in \texttt{ARROWS\_NUMBER} constant (e.g., \texttt{5}).

To keep track of the arrow, you will need following variables:

\begin{itemize}
\tightlist
\item
  \texttt{arrow}: current location of the arrow.
\item
  \texttt{arrow\_previous\_cave}: index of the cave the arrow came from, so that you know where it cannot flight back.
\item
  \texttt{shooting\_distance}: remaining distance to travel.
\item
  \texttt{remaining\_arrows}: number of remaining arrows (set to \texttt{ARROWS\_NUMBER} when the game starts).
\end{itemize}

\hypertarget{random-cave-but-no-180-turn}{%
\section{Random cave but no 180° turn}\label{random-cave-but-no-180-turn}}

You need to program a function (call it \texttt{next\_arrow\_cave()}) that picks a random cave but not the previous cave the arrow had been in. It should have two parameters:

\begin{itemize}
\tightlist
\item
  \texttt{connected\_caves}: a list of connected caves.
\item
  \texttt{previous\_cave}: cave from which the arrow came from.
\end{itemize}

First, debug the code in a separate cell. Assume that \texttt{connecting\_caves\ =\ CAVES{[}1{]}} (so, arrow is currently in cave 1) and \texttt{previous\_cave\ =\ 0} (arrow came from cave 0). Write the code that will pick one of the remaining caves randomly (in this case, either \texttt{2} or \texttt{7}). Once the code works, turn it into a function that returns the next cave for an arrow. Document the function. Test it with for other combinations of connected and previous caves.

Put your code into exercise \#3.

\hypertarget{going-distance}{%
\section{Going distance}\label{going-distance}}

Now that you have a function that flies to the next random cave, implement flying using a for loop. An arrow should fly through \texttt{shooting\_distance} caves (set it to \texttt{5}, maximal distance, by hand for testing). The \emph{first} cave is given (it will be picked by the player), so set \texttt{arrow} to \texttt{1} and \texttt{arrow\_previous\_cave} to \texttt{0} (player is in the cave \texttt{0} and shot the arrow into cave \texttt{1}). For debugging purposes, print out location of the arrow on each iteration. Test the code by changing \texttt{shooting\_distance}. In particular, set it to \texttt{1}. The arrow should ``fall down'' already in cave \texttt{1}.

Put your code into exercise \#4.

\hypertarget{hitting-a-target}{%
\section{Hitting a target}\label{hitting-a-target}}

Implement check for hitting the Wumpus or the player in the loop. Should the check be before or after the arrow flies to the next random cave? In both cases, write an appropriate ``game over'' message, set variable \texttt{gameover} to \texttt{True} (we will add to the main code later), and break out of the loop. Test the code by placing Wumpus by hand into the cave the player is shooting at or the next one. Run code multiple times to check that it works.

Put your code into exercise \#5.

\hypertarget{almost-where}{%
\section{Almost where}\label{almost-where}}

We are almost where but before we can start putting the code together we need a few more things. To better understand what all the functions are for, take a look at the overall program we are trying to make. You have most parts: placing player and game objects, moving player, checking for bats, bottomless pits, and wumpus. But we still need to implement asking player whether they want to shoot or move, asking for shooting distance, and for cave the player wants to shoot at.

\begin{verbatim}
import random

define CAVES
define other constants

define functions 

place player, bottomless pits, bats, and wumpus
set number of remaining arrows to ARROWS_NUMBER

set gameover to False
while not gameover:
    while player wants to shoot and has arrows:
        ask about cave that player want to shoot at
        ask how the far the arrow should fly
        
        fly arrow through caves in for loop:
            if hit wumpus -> congrats game over message, gameover=True, and break out of the loop
            if hit player -> oops game over message, gameover=True, and break out of the loop
        decrease number of remaining arrows
        
    check if game is over, break out of the loop, if that is the case
        
    ask player about the cave he want to go to and move player
    
    check for bats, move player to a random cave, while they are in the cave with bats
    
    check for bottomless pits (player dies, set gameover to True, break out of the loop)
    
    if player is in the same cave as wumpus:
        if wumpus is scared
            move wumpus to a random cave
        otherwise
            player is dead, set gameover to True, break out of the loop
\end{verbatim}

\hypertarget{move-or-shoot}{%
\section{Move or shoot?}\label{move-or-shoot}}

Previously, the player could only move, so we just asked for the next cave number. Now, on each turn, the player will have a choice of shooting an arrow or moving. Implement a function \texttt{input\_shoot\_or\_move()} that has no parameters and returns \texttt{"s"} for shooting o \texttt{"m"} for moving. Inside, ask the player about their choice until they pick one of two options. Conceptually, this is very similar to your other input functions (\texttt{input\_int()} and \texttt{input\_cave()}) that repeatedly request input until a valid one is given. Test and document!

Put your code into exercise \#6.

\hypertarget{how-far}{%
\section{How far?}\label{how-far}}

Implement \texttt{input\_distance()} function that has no parameters and returns the desired shooting distance between \texttt{1} and \texttt{5}. Inside, repeatedly ask for an integer number input on how far the arrow should travel until valid input is given. This is very similar to your other input functions. Test and document.

Put your code into exercise \#7.

\hypertarget{input_cave-prompt}{%
\section{input\_cave prompt}\label{input_cave-prompt}}

Add \texttt{prompt} parameter to the \texttt{input\_cave()} function you have previously. Now we can ask either about moving to or shooting at the cave, hence, the need for the prompt in place of a hard-coded message.

Put your code into exercise \#8.

\hypertarget{putting-it-all-together}{%
\section{Putting it all together}\label{putting-it-all-together}}

Here is the pseudocode again. Take a look to better understand how the new bits get integrated into the old code. By now, you should have following constants (you can have other values):

\begin{itemize}
\tightlist
\item
  \texttt{CAVES}
\item
  \texttt{NUMBER\_OF\_BATS} = 2
\item
  \texttt{NUMBER\_OF\_BOTTOMLESS\_PITS} = 2
\item
  \texttt{P\_WUMPUS\_SCARED} = 0.25
\item
  \texttt{ARROWS\_NUMBER} = 5
\end{itemize}

Following functions:

\begin{itemize}
\tightlist
\item
  \texttt{find\_empty\_cave(total\_caves,\ caves\_taken)}, returns an integer cave index
\item
  \texttt{input\_int(prompt)}, returns an integer
\item
  \texttt{input\_cave(prompt,\ connected\_cave)}, returns an integer cave index
\item
  \texttt{input\_shoot\_or\_move()}, returns \texttt{"s"} for shoot and \texttt{"m"} for move.
\item
  \texttt{input\_distance()}, returns an integer between 1 and 5
\item
  \texttt{next\_arrow\_cave(connected\_caves,\ previous\_cave)}, return an integer cave index
\end{itemize}

Following variables:

\begin{itemize}
\tightlist
\item
  \texttt{player} : cave index
\item
  \texttt{bottomless\_pit}: list of cave indexes
\item
  \texttt{bats}: list of cave indexes
\item
  \texttt{wumpus}: cave index
\item
  \texttt{remaining\_arrows}: integer number of remaining arrows
\item
  \texttt{gameover}: \texttt{False} initially, until something good (defeated wumpus) or bad (fell into a bottomless pit, got eaten by wumpus) happens.
\end{itemize}

Service/temporary variables:

\begin{itemize}
\tightlist
\item
  \texttt{occupied\_caves}: list of cave indexes
\item
  \texttt{arrow}: location of an arrow
\item
  \texttt{shooting\_distance}: number of caves the arrow should fly through.
\end{itemize}

\begin{verbatim}
import random

define CAVES
define other constants

define functions 

place player, bottomless pits, bats, and wumpus
set number of remaining arrows to ARROWS_NUMBER

set gameover to False
while not gameover:
    while player wants to shoot (input_shoot_or_move function) and has arrows (remaining_arrows variable):
        ask about cave that player want to shoot at (input_cave function), store answer in `arrow` variable
        ask how the far the arrow should fly (input_distance function), store answer in `shooting_distance` variable
        
        fly arrow through caves in for loop (shooting_distance caves):
            if hit wumpus -> congrats game over message, gameover=True, and break out of the loop
            if hit player -> oops game over message, gameover=True, and break out of the loop
            move arrow to the next random cave (next_arrow_cave function and arrow variable)
        decrease number of remaining arrows (remaining_arrows variable)
        
    check if game is over, break out of the loop, if that is the case
        
    ask player about the cave he want to go to and move player (input_cave function)
    
    while player is in the cave with bats: 
        move player to a random cave
    
    check for bottomless pits (player dies, set gameover to True, break out of the loop)
    
    if player is in the same cave as wumpus:
        if wumpus is scared
            move wumpus to a random cave
        otherwise
            player is dead, set gameover to True, break out of the loop
\end{verbatim}

Put your code into exercise \#9.

\hypertarget{wrap-up-2}{%
\section{Wrap up}\label{wrap-up-2}}

Well done! Next time, we will put \emph{video} into \emph{video game}!

\hypertarget{seminar08}{%
\chapter{Gettings start with PsychoPy}\label{seminar08}}

Before we program our first game using \href{https://psychopy.org/}{PsychoPy}, we need to spend some time figuring out its basics. It is not the most suitable library for writing games, for that you might want to use \href{https://arcade.academy/}{Python Arcade} or \href{https://www.pygame.org/}{PyGame}). However, it is (IMHO) the best Python library for developing psychophysical experiments, which is why we will use it in our course.

For this and following projects, we won't use Jupyter Notebooks but will develop a Python program using IDE environment of your choice (I would recommend \protect\hyperlink{install-vs-code}{Visual Studio Code}). You still could and should use Jupyter for playing with and testing small code snippets, though. I've added a section on setting up \protect\hyperlink{debug-in-vs-code}{debugging in VS Code} in \protect\hyperlink{getting-started}{Getting Started}, take a look once you are ready to run the code.

From now on, create a separate subfolder for each seminar (e.g.~\emph{Seminar 08} for today) and create a separate file (or files, later on) for each exercise\footnote{You can ``Save as\ldots{}'' the previous exercise to avoid copy-pasting things by hand.} (e.g., \emph{exercise01.py}, \emph{exercise02.py}, etc.). This is not the most efficient implementation of a version control and will certainly clutter the folder. But it would allow me to see your solutions on every step, which will make it easier for me to write comments. For submitting the assignment, just zip the folder and submit the zip-file.

\hypertarget{minimal-psychopy-code}{%
\section{Minimal PsychoPy code}\label{minimal-psychopy-code}}

In the subfolder for the current seminar, create file \emph{exercise01.py} (I would recommend using lead zero in \emph{01}, as it will ensure correct file sorting once we get to exercise 10, 11, etc.). Copy-paste the following code:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{"""}
\CommentTok{A minimal PsychoPy code.}
\CommentTok{"""}

\CommentTok{\# this imports two modules from psychopy}
\CommentTok{\# visual has all the visual stimuli, including the Window class}
\CommentTok{\# that we need to create a program window}
\CommentTok{\# event has function for working with mouse and keyboard}
\ImportTok{from}\NormalTok{ psychopy }\ImportTok{import}\NormalTok{ visual, event}

\CommentTok{\# creating a 800 x 600 window}
\NormalTok{win }\OperatorTok{=}\NormalTok{ visual.Window(size}\OperatorTok{=}\NormalTok{(}\DecValTok{800}\NormalTok{, }\DecValTok{600}\NormalTok{))}

\CommentTok{\# waiting for any key press}
\NormalTok{event.waitKeys()}

\CommentTok{\# closing the window}
\NormalTok{win.close()}
\end{Highlighting}
\end{Shaded}

Run it to check that PsychoPy work. You should get a gray window with \emph{PsychoPy} title. Press any key (click on the window, if you switched to another one, so that it registers the key press) and it should close. Not very exciting but does show that everything works as it should.

Put your code into \emph{exercise01.py}.

Let me explain what we are doing here line-by-line.

\begin{itemize}
\tightlist
\item
  \texttt{from\ psychopy\ import\ visual,\ event} here we import two (out of many) PsychoPy modules that give us \emph{visual} stimuli and main program window plus ability to process \emph{events}, such as keyboard presses or mouse activity.
\item
  \texttt{win\ =\ visual.Window(size=(800,\ 600))} we create a new PsychoPy \href{https://psychopy.org/api/visual/window.html\#psychopy.visual.Window}{Window} \emph{object} (you will learn about classes and objects soon) and define its \texttt{size} as 800 by 600 pixels (you can change that and see how the window also changes its size).
\item
  \texttt{event.waitKeys()} function \href{https://psychopy.org/api/event.html\#psychopy.event.waitKeys}{waitKeys()} waits for a press of a keyboard key. As we didn't specify which keys we are interested in, \emph{any} key will do. Later on, you will learn how to make it wait for specific keys.
\item
  \texttt{win.close()} this calls a \emph{method} \texttt{close} (function that belongs to an object, again, you'll learn about them later) that tells window \texttt{win} to close itself.
\end{itemize}

\hypertarget{adding-main-loop}{%
\section{Adding main loop}\label{adding-main-loop}}

Currently, nothing really happens in the code, so let us add the main loop. The loop goes between opening and closing the window:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{importing libraries}
\NormalTok{opening the window}

\OperatorTok{{-}{-}\textgreater{}}\NormalTok{ our main loop }\OperatorTok{\textless{}{-}{-}}

\NormalTok{closing the window}
\end{Highlighting}
\end{Shaded}

For this, you need to create a new variable \texttt{gameover} and set it too \texttt{False} (just like we did it in \emph{Hunt the Wumpus} game) and run the loop for as long as the game is \textbf{not} over. Inside the loop, use function \href{https://psychopy.org/api/event.html\#psychopy.event.getKeys}{event.getKeys()} to check whether \emph{escape} button was pressed (for this, you need to pass \texttt{keyList={[}\textquotesingle{}escape\textquotesingle{}{]}}). The function returns a list of keys, if any of them were pressed in the meantime or an empty list, if no keys from the list were pressed. Accordingly, you need to check whether the return value as an empty list. There are two ways to do this. First, you can check whether length of the list is larger than zero (so, it has elements) using function \href{https://docs.python.org/3/library/functions.html\#len}{len()}. Alternatively, an empty list evaluates to \texttt{False} when converted to a logical value either explicitly (via \texttt{bool()} type conversion) or when evaluated inside of the condition in an \texttt{if} or \texttt{while} statement:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x }\OperatorTok{=}\NormalTok{ []}
\ControlFlowTok{if}\NormalTok{ x:}
  \BuiltInTok{print}\NormalTok{(}\StringTok{"List is not empty"}\NormalTok{)}
\ControlFlowTok{else}\NormalTok{:}
  \BuiltInTok{print}\NormalTok{(}\StringTok{"List is definitely empty"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## List is definitely empty
\end{verbatim}

If list is \emph{not} empty, you should change \texttt{gameover} to \texttt{True}. Think, how can you do it \emph{without} an \texttt{if} statement, computing the logical value directly?

Put your code into \emph{exercise02.py}.

\hypertarget{adding-text-message}{%
\section{Adding text message}\label{adding-text-message}}

Although we are now running a nice loop, we still have only a boring gray window to look at. Let us create a text stimulus, which would say ``Press escape to exit'' and display it during the loop. For this we will use \href{https://psychopy.org/api/visual/textstim.html}{visual.TextStim} class from PsychoPy library.

First, you need to create the \texttt{press\_escape\_text} object (instance of the \texttt{TextStim} class) before the main loop. There are quite a few parameters that you can play with but minimally, you need to pass the program window (our \texttt{win} variable) and the actual text you want to display (\texttt{"Press\ escape\ to\ exit"}). For all other settings PsychoPy will use its defaults (default font family, color and size, placed right the screen center).

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{press\_escape\_text }\OperatorTok{=}\NormalTok{ visual.TextStim(win, }\StringTok{"Press escape to exit"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

To show the visuals in PsychoPy, you first \emph{draw} each element by calling its \texttt{draw()} method (thus, in our case, \texttt{press\_escape\_text.draw()}) and then put the ``drawing'' on the screen by \emph{flipping} we window (\texttt{win.flip()} method). These two calls should go inside the main loop either before (my preference) or after the keyboard check.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{importing libraries}
\NormalTok{opening the window}

\OperatorTok{{-}{-}\textgreater{}}\NormalTok{ create press\_escape\_text here }\OperatorTok{\textless{}{-}{-}}

\NormalTok{gameover }\OperatorTok{=} \VariableTok{False}
\ControlFlowTok{while} \KeywordTok{not}\NormalTok{ gameover:}
    \OperatorTok{{-}{-}\textgreater{}}\NormalTok{ draw press\_escape\_text }\OperatorTok{\textless{}{-}{-}}
    \OperatorTok{{-}{-}\textgreater{}}\NormalTok{ flip the window  }\OperatorTok{\textless{}{-}{-}}
\NormalTok{    check keyboard }\ControlFlowTok{for}\NormalTok{ escape button press}
    
\NormalTok{close the window}
\end{Highlighting}
\end{Shaded}

Now, you should have a nice, although static, message that tells you how you can exit the game. Check out the manual page for \href{https://psychopy.org/api/visual/textstim.html}{visual.TextStim} and try changing it by passing additional parameters to the object constructor call. For example you can change its \texttt{color}, whether text is \texttt{bold} and/or \texttt{italic}, how it is aligned, etc. However, if you want to change \emph{where} the text is displayed, read on below.

Put your code into \emph{exercise03.py}.

\hypertarget{adding-a-square-and-placing-it-not-at-the-center-of-the-window}{%
\section{\texorpdfstring{Adding a square and placing it \emph{not} at the center of the window}{Adding a square and placing it not at the center of the window}}\label{adding-a-square-and-placing-it-not-at-the-center-of-the-window}}

Now, let us figure out how create and move visuals to an arbitrary location on the screen. In principle, this is very straightforward as every visual stimulus (including \texttt{TextStim} we used just above) has \texttt{pos} property that specifies (you guessed it!) its position. However, to make your life easier, PsychoPy first complicates it by having \href{https://psychopy.org/general/units.html}{\textbf{five} different units systems}.

Before we start exploring the units, let us create a simple white square. The visual class we need is \href{https://psychopy.org/api/visual/rect.html}{visual.Rect}. Just like the \texttt{TextStim} above, it requires \texttt{win} variable (so it knows which window it belongs to), \texttt{width} (defaults to 0.5 of that mysterious units), \texttt{height} (also defaults to 0.5), \texttt{pos} (defaults to (0,0)), \texttt{lineColor} (defaults to \texttt{white}) and \texttt{fillColor} (defaults to \texttt{None}). Thus, to get a ``standard'' white square with size of \texttt{(0.5,\ 0.5)} units at \texttt{(0,\ 0)} location you only need pass the \texttt{win} variable: \texttt{white\_square\ =\ visual.Rect(win)}. You draw the square just like you drew the text stimulus, via its \texttt{draw()} method. Create the code, run it to see a very white square, and read on.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{importing libraries}
\NormalTok{opening the window}

\OperatorTok{{-}{-}\textgreater{}}\NormalTok{ create white\_square here }\OperatorTok{\textless{}{-}{-}}

\NormalTok{gameover }\OperatorTok{=} \VariableTok{False}
\ControlFlowTok{while} \KeywordTok{not}\NormalTok{ gameover:}
    \OperatorTok{{-}{-}\textgreater{}}\NormalTok{ draw white\_square }\KeywordTok{and}\NormalTok{ flip the window here }\OperatorTok{\textless{}{-}{-}}
\NormalTok{    check keyboard }\ControlFlowTok{for}\NormalTok{ escape button press}

\NormalTok{close the window}
\end{Highlighting}
\end{Shaded}

Put your code into \emph{exercise04.py}.

What did you say, your square was not really a square? Well, I told you, \textbf{five} units systems!

\hypertarget{psychopy-units}{%
\section{Five units systems}\label{psychopy-units}}

\hypertarget{height-units}{%
\subsection{Height units}\label{height-units}}

With height units everything is specified in the units of window height. The center of the window is at \texttt{(0,0)} and the window goes vertically from \texttt{-0.5} to \texttt{0.5}. However, its horizontal limits depend on the aspect ratio. For our 800×600 window, it will go from -0.666 to 0.666 (the window is 1.3333 window heights wide). For a 600×800 window from -0.375 to 0.375 (the window is 0.75 window heights wide), for a square window 600×600 from -0.5 to 0.5 (again, in all these cases it goes from -0.5 to 0.5 vertically). This means that the actual on-screen distance for the units is the same for both axes. So that a square of \texttt{size=(0.5,\ 0.5)} is actually a square (it spans the same distance vertically and horizontally). Thus, it makes \emph{sizing} objects easier but \emph{placing them on horizontal axis correctly} harder (as you need to know the aspect ratio).

Modify your code by specifying the unit system when you create the window: \texttt{win\ =\ visual.Window(...,\ units="height")}. Play with your code by specifying position of the square when you create it. You just need to pass an extra parameter \texttt{pos=(\textless{}x\textgreater{},\ \textless{}y\textgreater{})}. Which was is up, when y is below or above zero?

Put your code into \emph{exercise05.py}.

Unfortunately, unlike x-axis, the y-axis can go both ways. For PsychoPy y-axis points up (so negative values move the square down and positive up). However, if you would use an Eyelink eye tracker to record where participants looked \emph{on the screen}, it assumes that y-axis starts at the top of the screen and points down (which could be very confusing, if you forget about this when overlaying gaze data on the image you used and wondering what on Earth the participants were doing).

Now, modify the size of the square (and turn it into a non-square rectangle) by passing \texttt{width=\textless{}some-width-value\textgreater{}} and \texttt{height=\textless{}some-height-value\textgreater{}}.

Put your code into \emph{exercise06.py}.

\hypertarget{normalized-units}{%
\subsection{Normalized units}\label{normalized-units}}

These units are default ones and assume that the window goes from -1 to 1 both along x- and x-axis. Again, (0,0) is the center of the screen but the bottom-left corner is (-1, -1) whereas the top-right is (1, 1). This makes \emph{placing} your objects easier but \emph{sizing} them harder (you need to know the aspect ratio to ensure that a square is a square).

Modify your code, so that it uses \texttt{"norm"} units when you create the window and size the \texttt{Rect} stimulus, so it does look like a square.

Put your code into \emph{exercise07.py}.

\hypertarget{pixels-on-screen}{%
\subsection{Pixels on screen}\label{pixels-on-screen}}

In this case, the window center is still at \texttt{(0,0)} but it goes from \texttt{-\textless{}width-in-pixels\textgreater{}/2} to \texttt{\textless{}width-in-pixels\textgreater{}/2} horizontally (from -400 to 400 in our case) and \texttt{-\textless{}height-in-pixels\textgreater{}/2} to \texttt{\textless{}height-in-pixels\textgreater{}/2} vertically (from -300 to 300). These units could be more intuitive when you are working with a fixed sized window, as the span is the same along the both axes (like for the height units). However, they spell trouble if your window size was changed or you are using a full screen window on some monitor with an unknown resolution.

Modify your code to use \texttt{"pix"} units and briefly test sizing and placing your square within the window.

Put your code into \emph{exercise08.py}.

\hypertarget{degrees-of-visual-angle}{%
\subsection{Degrees of visual angle}\label{degrees-of-visual-angle}}

Unlike the three units above, these require you knowing a physical size of the screen, its resolution, and your viewing distance (how far your eyes are away from the screen). They are \emph{the} measurement units used in visual psychophysics as they describe stimulus size as it appears on the retina (see \href{https://en.wikipedia.org/wiki/Visual_angle}{Wikipedia} for details). Thus, these are the units you want to use when running an actual experiment in the lab but for our purposes we will stick to one of the three units systems above.

\hypertarget{centimeters-on-screen}{%
\subsection{Centimeters on screen}\label{centimeters-on-screen}}

Here, you would need know the physical size of your screen and its resolution. These are fairly exotic units for very specific situations\footnote{so specific that I can't think of one, to be honest.}.

\hypertarget{make-your-square-jump}{%
\section{Make your square jump!}\label{make-your-square-jump}}

So far, we fixed the location of the square when we created it. However, you can move it at any time by assigning a new \texttt{(\textless{}x\textgreater{},\ \textless{}y\textgreater{})} coordinates to its \texttt{pos} property. \emph{E.g.}, \texttt{white\_square.pos\ =\ (-0.1,\ 0.2)}. Let us experiment by moving the square to a random location on every iteration of the loop (this could cause a lot of flashing, so if you have a photosensitive epilepsy that can be triggered by flashing lights, you probably should do it just once before the loop). Use the units of your choice (I would recommend \texttt{"norm"}) and generate a new position using \href{https://docs.python.org/3/library/random.html\#random.uniform}{random.uniform(a, b)} function, that generates a random value within \emph{a..b} range. You need to generate two values (one for x, one for y) and your range is the same for \texttt{"norm"} units (from -1 to 1) but is different (and depends on the aspect ratio) for \texttt{"height"} units.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{importing libraries, now also the random library}
\BuiltInTok{open}\NormalTok{ the window}
\NormalTok{create white\_square here}

\NormalTok{gameover }\OperatorTok{=} \VariableTok{False}
\ControlFlowTok{while} \KeywordTok{not}\NormalTok{ gameover:}
    \OperatorTok{{-}{-}\textgreater{}}\NormalTok{ move the square to a random position }\OperatorTok{\textless{}{-}{-}}
\NormalTok{    draw white\_square }\KeywordTok{and}\NormalTok{ flip the window here}
\NormalTok{    check keyboard }\ControlFlowTok{for}\NormalTok{ escape button press}

\NormalTok{close the window}
\end{Highlighting}
\end{Shaded}

Put your code into \emph{exercise09.py}.

\hypertarget{make-the-square-jump-on-your-command}{%
\section{Make the square jump on your command!}\label{make-the-square-jump-on-your-command}}

This was very flashy, so let us make the square jump only when you press \emph{Space} button. For this, we need to expand the code that processes keyboard input. So far, we restricted it to just ``escape'' button and checked whether any (hence, ``escape'') button was pressed. In my case, the code looks like that

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{gameover }\OperatorTok{=}\NormalTok{ event.getKeys(keyList}\OperatorTok{=}\NormalTok{[}\StringTok{\textquotesingle{}escape\textquotesingle{}}\NormalTok{])}
\end{Highlighting}
\end{Shaded}

But I could have written it as

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{keys\_pressed }\OperatorTok{=}\NormalTok{ event.getKeys(keyList}\OperatorTok{=}\NormalTok{[}\StringTok{\textquotesingle{}escape\textquotesingle{}}\NormalTok{])}
\ControlFlowTok{if}\NormalTok{ keys\_pressed }\KeywordTok{is} \KeywordTok{not} \VariableTok{None}\NormalTok{:}
\NormalTok{    game\_over }\OperatorTok{=} \VariableTok{True}
\end{Highlighting}
\end{Shaded}

Let us use the \emph{second} version, where we explicitly store the output of \texttt{event.getKeys()} function in \texttt{keys\_pressed}. First, you need to add \texttt{"space"} to the \texttt{keyList} parameter. Second, because \texttt{event.getKeys()} function returns a \textbf{list} of keys that were pressed, we need to loop over that list (which in most cases will contain no or just one element) and use conditional statements inside that loop to make the square jump or to exit the program.

Use for \texttt{for} loop to loop over the elements of the list. Note that no iterations will occur if the list is empty, you can test this in a Jupyter cell:

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{for}\NormalTok{ \_ }\KeywordTok{in}\NormalTok{ []:}
    \BuiltInTok{print}\NormalTok{(}\StringTok{"No one will ever see me..."}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

When you loop over \texttt{keys\_pressed}, your current loop variable value will be the string with the name of the button pressed (so, either \texttt{"escape"} or \texttt{"space"}). Now, you need to use conditional statements, so that the square jumps if the key was \texttt{"space"} and game is over if the key was \texttt{"escape"}. You code should look roughly like that

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{importing libraries, now also the random library}
\BuiltInTok{open}\NormalTok{ the window}
\NormalTok{create white\_square}

\NormalTok{gameover }\OperatorTok{=} \VariableTok{False}
\ControlFlowTok{while} \KeywordTok{not}\NormalTok{ gameover:}
\NormalTok{    draw white\_square }\KeywordTok{and}\NormalTok{ flip the window here}
    
    \CommentTok{\# {-}{-}{-}{-}{-} New code {-}{-}{-}{-}{-}}
\NormalTok{    keys\_pressed }\OperatorTok{=}\NormalTok{ event.getKeys(keyList}\OperatorTok{=}\NormalTok{[}\StringTok{\textquotesingle{}escape\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}space\textquotesingle{}}\NormalTok{])}
\NormalTok{    loop over keys\_pressed:}
        \ControlFlowTok{if}\NormalTok{ participant pressed space key:}
\NormalTok{            move the square to a random location}
        \ControlFlowTok{elif}\NormalTok{ participant pressed escape key:}
            \BuiltInTok{set}\NormalTok{ gameover to }\VariableTok{False}
    \CommentTok{\# {-}{-}{-}{-}{-} End of new code {-}{-}{-}{-}{-}}

\NormalTok{close the window}
\end{Highlighting}
\end{Shaded}

Put your code into \emph{exercise10.py}.

\hypertarget{i-like-to-move-it-move-it}{%
\section{I like to move it, move it!}\label{i-like-to-move-it-move-it}}

Let us exert more control over our rectangle by moving it around using arrow buttons (\texttt{"up"}, \texttt{"down"}, \texttt{"left"}, and \texttt{"right"} in PsychoPy). Add these keys to the \texttt{keyList} parameter of the \texttt{event.getKeys()} call and add more conditional statements when processing the pressed key. In PsychoPy you can change position by adding to it via \texttt{+=} or \texttt{-=} operations (other operations are also supported, see \href{https://psychopy.org/coder/codeStimuli.html\#attrib-operations}{manual}). Thus, you can move your square to the right by 0.1 units (whatever they are) by writing \texttt{white\_square.pos\ +=\ (0.1,\ 0)}. Please note that you \textbf{cannot} write \texttt{white\_square.pos\ =\ white\_square.pos\ +\ (0.1,\ 0)}!

Expand your code, so you move the rectangle around by 0.05 units in the direction of the key pressed.

Put your code into \emph{exercise11.py}.

When we continue, we will expand on this to build a Memory game. In the meantime, experiment with stimuli (you can have a circle or a line rather than a square). Try showing more than one stimulus (\emph{e.g.}, add back the ``press escape to exit'' message), etc.

\hypertarget{seminar09}{%
\chapter{Memory game, part 1}\label{seminar09}}

Today, we will continue learning how to use PsychoPy. To this end, you will write a good old \emph{Memory} game. Sixteen cards are lying ``face down'', you can turn any two of them and, if they are identical, they are taken off the table. If they are different, the cards turn ``face down'' again.

Before we start, create a new folder \emph{Memory01} for exercise files and create a subfolder \emph{Images} in it. Then, download \href{material/chicken.zip}{images of chicken}\footnote{The images are from \href{https://openclipart.org/}{OpenClipart} and are public domain.} that we will use for the game and unzip them into \emph{Images} subfolder.

As per usual, we will start with bare basic and will add the complexity along the way. For the main script(s), please use VS Code (or IDE of your choice) but I would still encourage you to use Jupyter to figure out small code snippents.

\hypertarget{minimal-code}{%
\section{Minimal code}\label{minimal-code}}

The minimal code that we start with is

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{from}\NormalTok{ psychopy }\ImportTok{import}\NormalTok{ visual, event}
 
\NormalTok{win }\OperatorTok{=}\NormalTok{ visual.Window(size}\OperatorTok{=}\NormalTok{(???, ???), units}\OperatorTok{=}\StringTok{"norm"}\NormalTok{)}

\CommentTok{\# wait for a key press}

\NormalTok{win.close()}
\end{Highlighting}
\end{Shaded}

Your first task is to figure the optimal image size. Each chicken image is 240×400 pixels and, for the game, we need place for \emph{exactly} 4×2 images, i.e.~our window must be 4 cards wide and 2 cards high. Compute the window size and put into the code. Add \href{https://psychopy.org/api/event.html\#psychopy.event.waitKeys}{event.waitKeys()}, to check the window before it closes.

Put your code into \emph{exercise01.py}.

\hypertarget{drawing-an-image}{%
\section{Drawing an image}\label{drawing-an-image}}

Last time we displayed text and rectangles. Today, we will use images (see instructions above on downloading them). Using an \href{https://psychopy.org/api/visual/imagestim.html}{image stimulus} in PsychoPy is very straightforward. First, you need to create an new object by calling \texttt{visual.ImageStim(...)}. You can find the complete list of parameters in the documentation (see the link above) but for our initial intents and purposes, we only need to pass three of them:

\begin{itemize}
\tightlist
\item
  our window variable: \texttt{win}
\item
  image file name: \texttt{image\ =\ "Images/r01.png"}
\item
  size: \texttt{size=(???,\ ???)}. That is one for you to compute. Given that we use \texttt{"norm"} units (windows is 2 units wide and 2 units high) and we want to have a 4×2 images, what is the size of each image in \texttt{"norm"} units?
\end{itemize}

Create the simple code that should follow the template:

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{from}\NormalTok{ psychopy }\ImportTok{import}\NormalTok{ visual, event}
 
\NormalTok{win }\OperatorTok{=}\NormalTok{ visual.Window(size}\OperatorTok{=}\NormalTok{(???, ???), units}\OperatorTok{=}\StringTok{"norm"}\NormalTok{)}

\CommentTok{\# create the image stimulus, call variable "chicken"}

\CommentTok{\# draw chicken image just like you drew text or rectangle in previous seminar}
\CommentTok{\# flip window}

\CommentTok{\# wait for any key press}

\NormalTok{win.close()}
\end{Highlighting}
\end{Shaded}

Put your code into \emph{exercise02.py}.

\hypertarget{python-function-argumentsparameters}{%
\section{Python function arguments/parameters}\label{python-function-argumentsparameters}}

When we created the image stimulus, we used two tricks: passing value by parameter name and using default values.

\hypertarget{position-and-name-keyword}{%
\subsection{Position and name (keyword)}\label{position-and-name-keyword}}

In Python, you can pass values to parameters by position or using their name. For example, if you have a simple function

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{def}\NormalTok{ subtract(x, y):}
    \ControlFlowTok{return}\NormalTok{ x }\OperatorTok{{-}}\NormalTok{ y}
\end{Highlighting}
\end{Shaded}

you can call it by passing two values to the function \texttt{subtract(2,\ 3)}, which will return \texttt{-1}. However, you can also use parameter names to make it more explicit, \emph{e.g.} \texttt{subtract(x=2,\ y=3)}, which will also return \texttt{-1}. If you use parameters by name, you do not need to list in the original order, \emph{e.g.} \texttt{subtract(y=3,\ x=2)} will, again, return \texttt{-1}.

Moreover, you can mix position and keyword (named) parameters in the same call, \emph{e.g.} \texttt{subtract(2,\ y=3)}. However, the position parameters must always come \emph{before} named parameters \texttt{\textless{}function\textgreater{}(\textless{}value1\textgreater{},\ \textless{}value2\textgreater{},\ \textless{}param\textgreater{}=\textless{}value\textgreater{},\ ...)}. Thus, in case of our simple function above, \texttt{subtract(x=2,\ 3)} won't work.

\hypertarget{default-values}{%
\paragraph{Default values}\label{default-values}}

When you write a function, you can also specify \emph{default} values for its arguments. This way, when the function is called, you \textbf{must} specify the parameters without default values and you \textbf{can but do not have to} also pass values to the arguments with the default values. PsychoPy relies heavily on defaults, allowing you to specify a bare minimum. For example, when we created the \texttt{ImageStim}, we only specified three parameters: \texttt{win}, \texttt{image}, and \texttt{size}. We \textbf{had to} specify the first two, as there are no meaningful defaults for them (PsychoPy needs to know which image and in which window it must use). But we could have left \texttt{size} argument out, in which case PsychoPy would use the actual image size (240×400 pixels, in our case).

When writing a function, you simple add \texttt{=\textless{}default\_value\textgreater{}} to the argument, \emph{e.g.}:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{def}\NormalTok{ subtract(x, y}\OperatorTok{=}\DecValTok{1}\NormalTok{):}
    \ControlFlowTok{return}\NormalTok{ x }\OperatorTok{{-}}\NormalTok{ y}
\end{Highlighting}
\end{Shaded}

Now, you call \texttt{subtract(5)} to get \texttt{4} because function will use the default valule for \texttt{y}, which is 1. But you can always specify value for \texttt{y} as in previous examples \texttt{subtract(5,\ 3)} to get \texttt{2}.

Don't forget to document the default values and, preferably, the reason for having these specific values as defaults.

\hypertarget{using-os-library}{%
\subsection{\texorpdfstring{Using \emph{os} library}{Using os library}}\label{using-os-library}}

We specified image file name as \texttt{"Images/r01.png"}. This did the job but, unfortunately, major operating systems disagree with Windows on which slash should be used. To make your code more robust, you need to construct a proper filename string using \emph{os} library. It contains various utilities for working with your operating system and, in particular, with files and directories. The function we will need for this task is \texttt{join} in \href{https://docs.python.org/3/library/os.path.html}{path} submodule. When you \texttt{import\ os} library, you can then call this function as \texttt{os.path.join()}. It takes path components and joins them to match the OS format. E.g., \texttt{os.path.join("Python\ seminar",\ "Memory\ game",\ "memory01.py")} on Windows will return \texttt{\textquotesingle{}Python\ seminar\textbackslash{}\textbackslash{}Memory\ game\textbackslash{}\textbackslash{}memory01.py\textquotesingle{}}.

As we will need to load multiple files from the same folder later on, modify the code to make it more universal. First, create a constant \texttt{IMAGE\_FOLDER\ =\ "Images"}, which specifies folder with our images, and a \texttt{card\_filename\ =\ "r01.png"}. Then, modify your \texttt{ImageStim(...)} function call by constructing the full filename using \texttt{os.path.join} from the images folder and card filename variables.

Put your code into \emph{exercise03.py}.

\hypertarget{ordnung-muss-sein}{%
\section{Ordnung muss sein!}\label{ordnung-muss-sein}}

When you import libraries, all import statements should be at the top of your file and you should avoid putting them there in random order. The recommended order is 1) system libraries, like \texttt{os} or \texttt{random}; 2) third-party libraries, like \texttt{psychopy}; 3) your project modules (we will use them shortly). And, within each section you should put the libraries \emph{alphabetically}, so

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import}\NormalTok{ os}
\ImportTok{import}\NormalTok{ random}
\end{Highlighting}
\end{Shaded}

This may not look particularly useful for our simple code but as your projects will grow, you will need to include more and more libraries. Keeping them in that order makes it easy to understand which libraries you use and which are non-standard. Alphabetic order means that you can quickly check whether a library is included, as you can quickly find the location where its import statement should appear.

\hypertarget{placing-an-image}{%
\section{Placing an image}\label{placing-an-image}}

By default, our image is placed at the center of the screen, which is a surprisingly useful default for a typical psychophysical experiment that shows stimuli at fixation (center of the screen). However, we will need to draw eight images, each at its designated location. To make our life simpler in the long run, let us create a function that takes image index (from 0 to 7) and returns a tuple with its location on the screen. Here the sketch of how index correspond to the location:

\begin{verbatim}
[0 ][1 ][2 ][3 ]
[4 ][5 ][6 ][7 ]
\end{verbatim}

Name the function \texttt{position\_from\_index}, it should take one argument (\texttt{index}) and return a tuple with coordinates \texttt{(\textless{}x\textgreater{},\ \textless{}y\textgreater{})} in \texttt{"units"} coordinates (because this is our chosen coordinate units system). Then, we can then use this tuple to pass the value to \texttt{pos} argument of the \texttt{ImageStim()}. For example, when called as \texttt{position\_from\_index(0)} it should return \texttt{(-0.75,\ 0.5)}. When called as \texttt{position\_from\_index(6)} it should return \texttt{(0.25,\ 0.5)}, etc.

Think how you compute position from the index given the size of image. My implementation makes use of the \href{https://python-reference.readthedocs.io/en/latest/docs/operators/floor_division.html}{floor division operator \texttt{//}} and \href{https://python-reference.readthedocs.io/en/latest/docs/operators/modulus.html}{modulos, divison remainder \texttt{\%}} operators. The former returns only the integer part of the division, so that \texttt{4//3} is \texttt{1} (because 4/3 is 1.33333) and \texttt{1//4} is \texttt{0} (because 1/4 is 0.25). The latter returns the remaining integers, so that \texttt{4\ \%\ 3} is \texttt{1} and \texttt{1\ \%\ 4} is \texttt{0}.

First, write and debug this function in Jupyter. Initially, you do not even need to have a function. You can just set \texttt{index\ =\ 0} (or some other value) and write the code below. Once it work, you can add the \texttt{def\ position\_from\_index(index):} part and \textbf{document the function}. Once the function works, put it into a new file \emph{utilities.py}, we will use it to implement out custom function without cluttering the main file.

Put your code into \emph{utilities.py}.

\hypertarget{using-your-own-modules}{%
\subsection{Using your own modules}\label{using-your-own-modules}}

We need to add the definition of \texttt{position\_from\_index} function to our code. However, putting all function into the main file means that we would have \textbf{a lot of code} is a single file. This make it harder to navigate and to read. Thus, we will put our utility functions into a separate module and will import them, just like you import functions from other libraries.

By now the code should be in \emph{utilities.py}. So, you need toimport the function from the module as \texttt{from\ utilities\ import\ position\_from\_index}, this way you can call the function directly as \texttt{position\_from\_index(...)}. Alternatively, you can import entire module as \texttt{import\ utilities} and then call the function as \texttt{utilities.position\_from\_index()}. Both approaches are valid and your preference should depend on the readability of the code in each case.

Now that we have the \texttt{position\_from\_index} function in \texttt{utilities.py} file and we imported it, use it to place your image at one of the location. For this, you just need to add \texttt{pos=position\_from\_index(\textless{}index\ value\textgreater{})} to the \texttt{ImageStim} call. Use different hard-coded values (\emph{e.g.}, \texttt{0}) for the index value and see whether image does appear at the correct position.

Put your code into \emph{exercise04.py}.

\hypertarget{back-side-of-the-card}{%
\section{Back side of the card}\label{back-side-of-the-card}}

So far, we have an image of the face, which will be a front side. For the game, we also need the back of the card. For this, create a rectangle (\href{https://psychopy.org/api/visual/rect.html}{Rect} stimulus we used the last time) with same width/height as an image and position computed from an index (just like for the image). Pick a combination of a \texttt{fillColor} (inside) and \texttt{lineColor} (contour) that you like. Modify your code, to draw image (front of the card) and rectangle (back of the card) side-by-side (\emph{e.g.}, if face is at position with index 0, rectangle should be at position 1 or 4). This way you can check that sizes match and that they are position correctly.

Put your code into \emph{exercise05.py}.

\hypertarget{dictionaries}{%
\section{Dictionaries}\label{dictionaries}}

Below, we will use a dictionary to store all relevant card information and stimuli in a single variable. \href{https://docs.python.org/3/library/stdtypes.html\#dict}{Dictionaries} in Python allow you to store information using \emph{key}-\emph{value} pairs. This is similar to how you look up a meaning or translation (value) of the word (key) in the real dictionary, hence the name. To create a dictionary, you use \emph{curly} brackets \texttt{\{\textless{}key1\textgreater{}\ :\ \textless{}value1\textgreater{}\},\ \{\textless{}key2\textgreater{}\ :\ \textless{}value2\textgreater{},\ ...\}} or create it via \texttt{dict(\textless{}key1\textgreater{}=\textless{}value1\textgreater{},\ \textless{}key2\textgreater{}=\textless{}value2\textgreater{},\ ...)}.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{book }\OperatorTok{=}\NormalTok{ \{}\StringTok{"Author"}\NormalTok{ : }\StringTok{"Walter Moers"}\NormalTok{, }\StringTok{"Title"}\NormalTok{: }\StringTok{"Die 13½ Leben des Käpt\textquotesingle{}n Blaubär"}\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

now you can access or modify each field using its key. \emph{E.g.} \texttt{print(book{[}"Author"{]})} or \texttt{book{[}"Author"{]}\ =\ "Moers,\ W."}. You can also add new fields by assigning values to them, \emph{e.g.} \texttt{book{[}"Publication\ year"{]}\ =\ 1999}. In short, you can use a combination of \texttt{\textless{}dictionary-variable\textgreater{}{[}\textless{}key\textgreater{}{]}} just like you would use a normal variable.

Please note that dictionaries are mutable - sticker-on-a-object - variables, just like lists. Take another look at mutable values section, if you forgot the implications of this.

\hypertarget{using-dictionary-to-represent-a-card}{%
\section{Using dictionary to represent a card}\label{using-dictionary-to-represent-a-card}}

Our card has

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  front side (image of a chicken),
\item
  back side (rectangle),
\item
  identity on the card (filename),
\item
  information about which side is up.
\end{enumerate}

We need \#3, so we can later check whether the player opened two identical cards (their filenames match) or two different ones. We need \#4 to know how we should draw it (remember, we will have eight cards to manage by the end of the game). Since all of this information belongs to the same card, it would make sense to store it in a single object or a \emph{dictionary}. For didactic purposes of learning how to use dictionaries, we will use the latter.

Create a dictionary variable (name it \texttt{card}) with the following fields:
* \texttt{"front"}: assign your image stimulus to this field (we used to store in a \texttt{chicken} variable).
* \texttt{"back"}: assign your rectangle stimulus to it (make sure that now rectangle is at the same position, as the front of the card).
* \texttt{"filename"}: filename use used for it.
* \texttt{"index"}: position index of the card (we will use it later for the interaction), pick the one you like.
* \texttt{"side"}: assign it initially to be \texttt{"back"}.

Now, you have both side and all the information you need in the dictionary. Create a code that draws the side of the card as specified in \texttt{"side"} field. Note, you \textbf{do not need an if-statement for this}! Think how you do it using the power of dictionaries.

Put your code into \emph{exercise06.py}.

\hypertarget{card-factory}{%
\subsection{Card factory}\label{card-factory}}

So far, we have been creating the card dictionary within our main code. However, at a certain point of time, we will need to create eight of them. Thus, a better idea would be to spin this code off as a function which takes a window variable, filename, and position index arguments and returns a dictionary, just like the one we created. You are effectively just wrapping the already working code into a function. Call this function \texttt{create\_card} and put it into our \texttt{utilities.py} file (don't forget to document it!). Import and use it in the main script, replacing the card dictionary calls with a single function call. Note that now you need the \texttt{IMAGE\_FOLDER} variable in \emph{utilities.py}, rather than in the main file. Also, think about libraries you will now need import in \emph{utilities.py}.

Put your code into \emph{utilities.py} and \emph{exercise07.py}.

\hypertarget{adding-presentationinputs-loop}{%
\subsection{Adding presentation/inputs loop}\label{adding-presentationinputs-loop}}

In our game, the player will click on a card to ``turn it around''. We will implement a mouse interaction shortly but, first, modify the code to have the main presentation loop as we did on previous seminar. E.g., with \texttt{while\ not\ gameover:} loop and checking whether the player pressed \texttt{"escape"} key to exit the game.

Put your code into \emph{exercise08.py}.

\hypertarget{detecting-a-mouse-click}{%
\subsection{Detecting a mouse click}\label{detecting-a-mouse-click}}

Before you can use a \href{https://psychopy.org/api/event.html\#psychopy.event.Mouse}{mouse} in PsychoPy, you must create it via \texttt{mouse\ =\ event.Mouse(visible=True,\ win=win)} call, where \texttt{win} is the PsychoPy window you already created. This code should appear right after your created the window itself.

Now, you can check whether the left button was pressed using \texttt{mouse.getPressed()} method. It returns a three-item list with \texttt{True}/\texttt{False} values indicating whether each of the three buttons are pressed. Use it the main loop, so that if the player pressed \emph{left} button (its index in the returned list is \texttt{0}), you change \texttt{card{[}"side"{]}} to \texttt{"front"}.

If you run the code and click \emph{anywhere}, this should flip the card.

Put your code into \emph{exercise09.py}.

\hypertarget{position-to-index}{%
\section{Position to index}\label{position-to-index}}

Currently, the card is flipped if you click \emph{anywhere}. But it should flip only when the player clicked on that specific card. For this we need to implement a function \texttt{index\_from\_position} that is inverse of \texttt{position\_from\_index}. It should take an argument \texttt{pos}, which is a tuple of \texttt{(\textless{}x\textgreater{},\ \textless{}y\textgreater{})} values (that would be the mouse position within the window), and return an \textbf{integer} card index. You have float values (with decimal points) in the \texttt{pos} argument (because it ranges from -1 to 1) and by default the values you compute from them will also be float. However, the index is integer, so you will need to wrap it in \texttt{int(\textless{}value\textgreater{})} conversion call, before returning it.

I would recommend debugging the code in Jupyter first. Just set \texttt{pos\ =\ (-0.9,\ 0.9)} (index is, then, 0) or some other values within -1..1 range) and make sure it computes a valid index. Once it works, turn it into a function, test it in Jupyter, document it(!), and copy-paste to \texttt{utilities.py} file.

Put your code into \emph{utilities.py}.

\hypertarget{flip-on-click}{%
\section{Flip on click}\label{flip-on-click}}

Now that you have function that returns an index from position (don't forget to import it), you can check whether the player did click on the card itself. For this, you need to extend the card-flipping code inside the \emph{if left-mouse button was pressed} code.

You can get the position of the mouse within the window by calling \texttt{mouse.getPos()}. This will return a tuple of \texttt{(x,\ y)} values, which you can pass to your \texttt{index\_from\_position()} function. This, in turn will return the index of the card the player click on. If it \emph{matches} the index of your only card (stored in \texttt{"index"} field of the \texttt{card} dictionary), then and only then you flip the card.

Put your code into \emph{exercise10.py}.

\hypertarget{flip-flop}{%
\section{Flip-flop}\label{flip-flop}}

As a final exercise for today, let us make the card flip-flopping back and forth. We won't really use this code for the full version of the game but it will let you learn conditional assignment and \texttt{clock.wait()} function, you will need to use later.

In order for the card to flip-flop, you need to modify your \texttt{card{[}"side"{]}\ =\ "front"} statement, so that it is not \texttt{"front"} but \emph{the other} side of the card, which becomes active. There are several ways to implement this but use an if statement that checks the \emph{current} state of the card and assigns \emph{the other} one. So, if \texttt{card{[}"side"{]}} is current \texttt{"front"} it should become \texttt{"back"} and vice versa. Write and debug this four lines of code in Jupyter. Create card variable in the cell itself, \emph{e.g.} \texttt{card\ =\ \{"side"\ :\ "front"\}}.

As you are only assigning one of the two values to the same variable inside if-statement, you can use a nifty conditional-assignment to simplify the code. The four-line code below

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{if}\NormalTok{ y }\OperatorTok{==} \DecValTok{1}\NormalTok{:}
\NormalTok{    x }\OperatorTok{=} \DecValTok{2}
\ControlFlowTok{else}\NormalTok{:}
\NormalTok{    x }\OperatorTok{=} \DecValTok{3}
\end{Highlighting}
\end{Shaded}

is equivalent to

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x }\OperatorTok{=} \DecValTok{2} \ControlFlowTok{if}\NormalTok{ y }\OperatorTok{==} \DecValTok{1} \ControlFlowTok{else} \DecValTok{3}
\end{Highlighting}
\end{Shaded}

Use this conditional assignment to implement flip-flopping of the card. First, test it in a Jupyter cell below and then copy-paste it to your code, replacing \texttt{card{[}"side"{]}\ =\ "front"} statement. It will work kinda weirdly, do not worry about this and read on!

By now the flip-flopping should work and, like, \emph{real fast}! This is because \texttt{mouse.getPressed()} tells us whether the mouse button is pressed right now. Even if you are very fast in clicking it, you still hold it for a few frames (dozens of milliseconds) before releasing it. Hence, your card-flipping code is also invoked multiple times. There are several way to solve this problem. One would be to create a \texttt{is\_pressed} variable to keep track of whether the button was already pressed or released and act accordingly. Here, we will implement a simpler quick (and, admittedly, very dirty) solution. We will simply pause the code for 0.1 seconds giving the player enough time to release the button. This won't help the player who stubbornly keeps holding the button down (then the card will flip-flop every 0.1 seconds) but will take care of simple clicks.

For this, you need to use \href{https://psychopy.org/api/clock.html\#psychopy.clock.wait}{wait()} function in \texttt{clock} module of PsychoPy. Import the module (alongside \texttt{visual} and \texttt{event}) and call this function right after you flipped the card. Use \texttt{0.1} seconds waiting time but you can experiment using shorter or longer ones.

Put your code into \emph{exercise11.py}.

\hypertarget{to-be-continued}{%
\section{To be continued\ldots{}}\label{to-be-continued}}

Well done! By now, we have the code that creates a card with a given image and at a given position, we can draw it based on which side should be shown, and we can detect when the player clicked on that card. Next time, we will use these abilities to add more cards and turn it into a real game.

\hypertarget{seminar10}{%
\chapter{Memory game, part 2}\label{seminar10}}

By the time we finished our previous seminar, you had the code that created a single ``card'' with a given image at a given location and you were able to interact with it (flip-flopping it). Now, we need to extend the code so that we have eight cards that we can open only two at a time. If cards match (have same \texttt{"filename"} field), we remove them. If cards do not match, we simply turn them over.

Before we start, create a new folder \emph{Memory02} for exercise files. Copy \emph{Images} subfolder, as well as the \texttt{utilities.py} and \emph{exercise11.py} (rename it to \emph{exercise01.py}, as we will use the latter as the staring point). Also, download the \href{notebooks/Seminar\%2010.\%20Memory\%20game,\%20part\%202.ipynb}{Jupyter notebook}, which you will use to experiment with functions and do exercises. You will need to upload it along with other files.

\hypertarget{getting-list-of-image-files.}{%
\section{Getting list of image files.}\label{getting-list-of-image-files.}}

For a single card, we simply hard-coded the name of the image file, as well as its location. However, for a real game (or an experiment) we would like to be more flexible and automatically determine which files we have in the \emph{Images} folder. For this, you need to use \href{https://docs.python.org/3/library/os.html\#os.listdir}{os.listdir(path=``.'')} function that, you've guess it, returns a list with filenames of \emph{all} the files in a folder specified by path. By default, it is a current path (\texttt{path="."}). However, you can use either a relative path - \texttt{os.listdir("Images")}, assuming that \emph{Images} is a subfolder in your current directory - or an absolute path \texttt{os.listdir("E:/Teaching/Python/MemoryGame/Images")} (in my case). In Jupyter, write a single line code to get the list of files in the \emph{Images} folder. Use \emph{relative} path, if it is in a subfolder relative to your Jupyter notebook, or use an \emph{absolute} path, if it is in a different folder. Do not forget to \texttt{import\ os} before you run the code, of course!

Do exercise \#1 in Jupyter notebook.

You should have gotten a list of 8 files that are coded as \emph{{[}r\textbar l{]}{[}index{]}.png}, where \emph{r} or \emph{l} denote the side the chicken is looking at. However, for our game we need only four images (4 × 2 = 8 cards). Therefore, we need to select a subset of them. For example, a random four or chicken looking to the left or to the right only. Here, let us work with chicken looking to the left, meaning that we need only to pick files that start with ``l''. To make this list filtering more efficient, we will use \href{https://docs.python.org/3/tutorial/datastructures.html\#list-comprehensions}{list comprehensions}.

\hypertarget{list-comprehension}{%
\section{List comprehension}\label{list-comprehension}}

List comprehension provide an elegant and easy-to-read way to create, modify and/or filter elements of the list creating a new list. The general structure is

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{new\_list }\OperatorTok{=}\NormalTok{ [}\OperatorTok{\textless{}}\NormalTok{transform}\OperatorTok{{-}}\NormalTok{the}\OperatorTok{{-}}\NormalTok{item}\OperatorTok{\textgreater{}} \ControlFlowTok{for}\NormalTok{ item }\KeywordTok{in}\NormalTok{ old\_list }\ControlFlowTok{if} \OperatorTok{\textless{}}\NormalTok{condition}\OperatorTok{{-}}\NormalTok{given}\OperatorTok{{-}}\NormalTok{the}\OperatorTok{{-}}\NormalTok{item}\OperatorTok{\textgreater{}}\NormalTok{]}
\end{Highlighting}
\end{Shaded}

Let us look at examples to understand how it works. Imagine that you have a list \texttt{numbers\ =\ {[}1,\ 2,\ 3{]}} and you need increment each number by 1\footnote{A very arbitrary example!}. You can do it by creating a new list and adding 1 to each item in the part:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{numbers }\OperatorTok{=}\NormalTok{ [}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{]}
\NormalTok{numbers\_plus\_1 }\OperatorTok{=}\NormalTok{ [item }\OperatorTok{+} \DecValTok{1} \ControlFlowTok{for}\NormalTok{ item }\KeywordTok{in}\NormalTok{ numbers]}
\end{Highlighting}
\end{Shaded}

Note that this is equivalent to

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{numbers }\OperatorTok{=}\NormalTok{ [}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{]}
\NormalTok{numbers\_plus\_1 }\OperatorTok{=}\NormalTok{ []}
\ControlFlowTok{for}\NormalTok{ item }\KeywordTok{in}\NormalTok{ numbers:}
\NormalTok{    numbers\_plus\_1.append(item }\OperatorTok{+} \DecValTok{1}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Or, imagine that you need to convert each item to a string. You can do it simply as

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{numbers }\OperatorTok{=}\NormalTok{ [}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{]}
\NormalTok{numbers\_as\_strings }\OperatorTok{=}\NormalTok{ [}\BuiltInTok{str}\NormalTok{(item) }\ControlFlowTok{for}\NormalTok{ item }\KeywordTok{in}\NormalTok{ numbers]}
\end{Highlighting}
\end{Shaded}

What would be an equivalent form using a normal for loop? Write both versions of code in Jupiter cells and check that the results are the same.

Do exercise \#2 in Jupyter notebook.

Now, implement the code below using list comprehension. Check that results match.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{strings }\OperatorTok{=}\NormalTok{ [}\StringTok{\textquotesingle{}1\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}2\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}3\textquotesingle{}}\NormalTok{]}
\NormalTok{numbers }\OperatorTok{=}\NormalTok{ []}
\ControlFlowTok{for}\NormalTok{ astring }\KeywordTok{in}\NormalTok{ strings:}
\NormalTok{    numbers.append(}\BuiltInTok{int}\NormalTok{(astring) }\OperatorTok{+} \DecValTok{10}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Do exercise \#3 in Jupyter notebook.

As noted above, you can also use conditional statement to filter which items are passed to the new list. In our numbers example, we can retain numbers that are greater than 1

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{numbers }\OperatorTok{=}\NormalTok{ [}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{]}
\NormalTok{numbers\_greater\_than\_1 }\OperatorTok{=}\NormalTok{ [item }\ControlFlowTok{for}\NormalTok{ item }\KeywordTok{in}\NormalTok{ numbers }\ControlFlowTok{if}\NormalTok{ item }\OperatorTok{\textgreater{}} \DecValTok{1}\NormalTok{]}
\end{Highlighting}
\end{Shaded}

Sometimes, the same statement is written in three lines, instead of one, to make reading easier:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{numbers }\OperatorTok{=}\NormalTok{ [}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{]}
\NormalTok{numbers\_greater\_than\_1 }\OperatorTok{=}\NormalTok{ [item }
                          \ControlFlowTok{for}\NormalTok{ item }\KeywordTok{in}\NormalTok{ numbers}
                          \ControlFlowTok{if}\NormalTok{ item }\OperatorTok{\textgreater{}} \DecValTok{1}\NormalTok{]}
\end{Highlighting}
\end{Shaded}

You can of course combine the transformation and filtering in a single statement. Create code that filters out all items below 2 and adds 4 to them.

Do exercise \#4 in Jupyter notebook.

\hypertarget{getting-list-of-relevant-files}{%
\section{Getting list of relevant files}\label{getting-list-of-relevant-files}}

Now that you know about list comprehensions, you can easily create a list of files of chicken looking left, \emph{i.e.} with filenames that start with ``l''. Use \href{https://docs.python.org/3/library/stdtypes.html\#str.startswith}{str.startswith()} for filtering, store the list in \texttt{filenames} variable. Put you code into a Jupyter cell.

Do exercise \#5 in Jupyter notebook.

This gives us a nice list of eight files but we need each name twice. There are several ways of making but we will use list operations for this.

\hypertarget{list-operations}{%
\subsection{List operations}\label{list-operations}}

Python lists implement two operations:

\begin{itemize}
\tightlist
\item
  Adding two lists together: \texttt{\textless{}list1\textgreater{}\ +\ \textless{}list2\textgreater{}}.
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{a }\OperatorTok{=}\NormalTok{ [}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{]}
\NormalTok{b }\OperatorTok{=}\NormalTok{ [}\DecValTok{4}\NormalTok{, }\DecValTok{5}\NormalTok{, }\DecValTok{6}\NormalTok{]}
\NormalTok{a }\OperatorTok{+}\NormalTok{ b}
\end{Highlighting}
\end{Shaded}

gives a \emph{new} list with items \texttt{{[}1,\ 2,\ 3,\ 4,\ 5,\ 4,\ 5,\ 6{]}}. Note that this is not equivalent to \href{https://docs.python.org/3/tutorial/datastructures.html\#more-on-lists}{extend} method \texttt{a.extend(b)}! The \texttt{+} creates a \emph{new} list, \texttt{.extend()} extends the original list \texttt{a}.

\begin{itemize}
\tightlist
\item
  List multiplication/replication: \texttt{\textless{}list\textgreater{}\ *\ \textless{}integer-value\textgreater{}} creates a \emph{new} list by replicating the original one \texttt{\textless{}integer-value\textgreater{}} times. For example:
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{a }\OperatorTok{=}\NormalTok{ [}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{]}
\NormalTok{b }\OperatorTok{=} \DecValTok{4}
\NormalTok{a }\OperatorTok{*}\NormalTok{ b}
\end{Highlighting}
\end{Shaded}

will give you \texttt{{[}1,\ 2,\ 3,\ 1,\ 2,\ 3,\ 1,\ 2,\ 3,\ 1,\ 2,\ 3{]}}.

Use either operations or \texttt{.extend()} method to create the new list where each filename is repeated twice. Hint, you can apply list multiplication directly to the filenames list you created via list comprehension.

Do exercise \#6 in Jupyter notebook.

\hypertarget{lots-of-cards-using-list-enumeration}{%
\section{Lots of cards, using list enumeration}\label{lots-of-cards-using-list-enumeration}}

Now that we have a list of filenames, we can create a list of cards out of it. This list will replace your single \texttt{card} variable. Name the new list \texttt{cards} and create it either using an empty list + for loop or using list comprehensions. Inside the loop you creating each card using its filename and index (see below) and append it to the \texttt{cards} list (or it is added automatically, if you use comprehensions).

You can get the index of each filename (and, therefore, it position on the screen) via \href{https://docs.python.org/3/library/functions.html\#enumerate}{enumerate()}, which is a generator that returns a tuple of \texttt{(index,\ item)}. For example, test the example below that prints one letter at a time with its index:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{letters }\OperatorTok{=}\NormalTok{ [}\StringTok{\textquotesingle{}a\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}b\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}c\textquotesingle{}}\NormalTok{]}
\ControlFlowTok{for}\NormalTok{ index, letter }\KeywordTok{in} \BuiltInTok{enumerate}\NormalTok{(letters):}
    \BuiltInTok{print}\NormalTok{(}\StringTok{\textquotesingle{}}\SpecialCharTok{\%d}\StringTok{: }\SpecialCharTok{\%s}\StringTok{\textquotesingle{}}\OperatorTok{\%}\NormalTok{(index, letter))}
\end{Highlighting}
\end{Shaded}

Once you created the list of cards, you should draw \emph{all} of them inside the main loop. You already have a line that draws a single \texttt{single\_card}. You should wrap this call with a for loop that loops over all \texttt{cards} and uses \texttt{single\_card} as an iterator variable. Your code should look roughly as this

\begin{verbatim}
# import libraries
# open window and create the mouse
# get filenames for chicken looking left 
# create all cards

gameover = False
while not gameover:
    # draw all cards
    
    # check keys
    
    # mouse processing - COMMENT IT OUT FOR A MOMENT
\end{verbatim}

Put your code into \emph{exercise01.py}.

\hypertarget{mouse-interaction-for-every-card}{%
\section{Mouse interaction for every card}\label{mouse-interaction-for-every-card}}

Our mouse interaction was based on the index of our only card and checking that it matches the mouse click. However, now we have eight cards that cover the \emph{entire} window. Thus, it does not matter where exactly the player clicked, there is a card which needs to be turned over. Modify your mouse click processing code so that if mouse left button is pressed, it computes an index of that location (it would be from 0 to 7), flips the card with that index in the list, waits for 0.1 seconds (our hack from last time, we won't need it soon).

Put your code into \emph{exercise02.py}.

\hypertarget{limiting-flipping-to-just-two-cards}{%
\section{Limiting flipping to just two cards}\label{limiting-flipping-to-just-two-cards}}

In the actual game, we are allow to only turn around \emph{two} cards at a time. We will either need an extra variable to know how many cards are face up already or do an on-the-fly scan through the list. Let us implement the extra variable solution. Create a new variable \texttt{faceup\_n\ =\ 0} before the loop. Inside the mouse-click processing code, you need to implement the following logic:

\begin{verbatim}
if mouse.getPressed()[0]:
    # compute index of the mouse click
    # if card with this index is not face up already:
        # turn the card face up
        # increment the faceup_n variable
        # if faceup_n is equal to 2:
            # --- draw all cards ---
            # insert a pause of 0.5 seconds
            # turn all cards back
            # reset faceup_n to zero (as all cards are now with their backs up)
\end{verbatim}

Note that we need to explicitly draw the cards again inside the condition (and don't forget to flip the window)! Otherwise, we turn the card back before we ever get to the drawing stage.

Put your code into \emph{exercise03.py}.

\hypertarget{remembering-which-cards-were-turned}{%
\section{Remembering which cards were turned}\label{remembering-which-cards-were-turned}}

Our initial implementation was to count the number of cards that player turned. This, however, means that we don't know which cards these were. Let us now store face-up cards in a new list called \texttt{faceup} that would replace the \texttt{faceup\_n} variable. Initialize \texttt{faceup} with an empty list (just like you initialized \texttt{faceup\_n} with 0). And, once the card is flipped, add it to this list. Once \texttt{faceup} list is 2 items long (use \href{https://docs.python.org/3/library/functions.html?highlight=len\#len}{len()} function to get the length of the list), show the cards, wait for 0.5 seconds, turn cards in \texttt{faceup} list back, and \href{https://docs.python.org/3/tutorial/datastructures.html\#more-on-lists}{clear} the list.

\begin{verbatim}
if mouse.getPressed()[0]:
    # compute index of the mouse click
    # if card with this index is not face up already:
        # turn the card face up
        # add card to faceup list
        # if faceup list length is equal to 2:
            # --- draw all cards ---
            # insert a pause of 0.5 seconds
            # turn cards in faceup list back
            # clear faceup list
\end{verbatim}

Put your code into \emph{exercise04.py}.

\hypertarget{visible-card-flag}{%
\section{``Visible'' card flag}\label{visible-card-flag}}

In our next step, we will remove the matching cards. However, in reality, we won't actually remove them, we just won't draw them and won't allow user to interact with them once they are ``removed''. To know whether we need to draw a particular card, we will add a new field \texttt{visible}. There are three (well, four) pieces of code which needs to be modified.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Add \texttt{visible} field to the dictionary in the \texttt{create\_card()} function when making the card and set it to \texttt{True} by default.
\item
  When drawing cards, draw it only if \texttt{visible} field is \texttt{True}. By now you draw card in \emph{two} places, so both need to be appended.
\item
  In the code that processes the mouse click, when checking if the card hasn't been turned over yet, add ``and it is visible'' to the condition (in Python syntax, of course). So that it can be turned face up only if it is current face down and visible.
\end{enumerate}

You should see no difference in the game, because as long as all cards are visible (and, at the moment, they always are) it works just like before.

Put your code into \emph{utilities.py} and \emph{exercise05.py}.

\hypertarget{removing-matching-cards}{%
\section{``Removing'' matching cards}\label{removing-matching-cards}}

By now we now which two cards were turned over (these are in \texttt{faceup} list) and if they match, which means that their filenames match, we can ``remove'' them by setting their \texttt{visible} field to \texttt{False}.

\begin{verbatim}
# if faceup list length is equal to 2:
    # --- draw all cards ---
    # insert a pause of 0.5 seconds

    # if cards match:
        # set cards visibility to False
    # else:
        # turn them back

    # clear faceup list
\end{verbatim}

Test this and remember that we didn't shuffle the faces so they repeat in an orderly fashion, making it easy to open the pairs.

Put your code into \emph{exercise06.py}.

\hypertarget{game-over-if-you-run-out-of-cards}{%
\section{Game over, if you run out of cards}\label{game-over-if-you-run-out-of-cards}}

Currently, our game can be exited by pressing \emph{Escape}. Let's add a more positive game-over outcome when you win because you matched all the cards! For this, we need to count how many cards are left on the table and modify the loop, so that it iterates only as long as the number of cards left is more than zero. For this,

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Create a new variable \texttt{cards\_left} before the loop start and set it to the total number of cards (length of the cards list).
\item
  Modify the while loop, adding the second condition that \texttt{cards\_left} must be more than zero.
\item
  Decrease \texttt{cards\_left} by 2, every time two cards are matched and ``removed''.
\end{enumerate}

Put your code into \emph{exercise07.py}.

\hypertarget{game-over-message}{%
\section{Game over message}\label{game-over-message}}

Currently, our game abruptly closes once all cards are removed. It would be much friendlier to add a simple ``Game over'' message and show it for couple of seconds. After the main loop but before closing the window, create and draw the {[}TextStim{]}((\url{https://psychopy.org/api/visual/textstim.html}) and use either \texttt{clock.wait(2)} or \texttt{event.waitKeys()} (your choice). However, make sure that this message is only shown if there were no cards left. Otherwise it was the escape button press and so no ``game over'' message for people who are too lazy to finish the game!

Put your code into \emph{exercise08.py}.

\hypertarget{counting-attempts}{%
\section{Counting attempts}\label{counting-attempts}}

It would be even more fun to check how many attempts it required for the player to match all cards. Create a new variable \texttt{attempts} and initialize it to zero before the main loop. Increase it by 1 every time the player turned two cards over (irrespective of whether they matched). Add the number of attempts to the ``Game over'' message.

Put your code into \emph{exercise09.py}.

\hypertarget{record-time}{%
\section{Record time}\label{record-time}}

Let us record the time it took the player to complete the task. For this we will use PsychoPy's \href{https://psychopy.org/api/clock.html\#psychopy.clock.Clock}{Clock} class, which is very straightforward. Simply create the \texttt{timer\ =\ clock.Clock()} before the main loop and then call its \href{https://psychopy.org/api/clock.html\#psychopy.clock.MonotonicClock.getTime}{getTime()} method to get the elapsed time in seconds. Add this information to the ``game over'' message.

Put your code into \emph{exercise10.py}.

\hypertarget{randomness}{%
\section{Randomness}\label{randomness}}

The only boring thing about our game is that we know exactly where each chicken is. \href{https://docs.python.org/3/library/random.html\#random.shuffle}{Shuffle} the filenames list before you create the cards to turn it into a proper memory game.

Put your code into \emph{exercise11.py}.

Yay! Awesome game!

\hypertarget{seminar11}{%
\chapter{Memory game, part 3}\label{seminar11}}

During our previous seminar, we competed the core \textbf{Memory Game}. Today we will put more bells-and-whistles on it.

Before we start, create a new folder \emph{Memory03} for exercise files. Copy \emph{Images} subfolder, as well as the \texttt{utilities.py} and \emph{exercise11.py} (rename it to \emph{exercise01.py}, as we will use the latter as the staring point) from the previous seminar. Also, download \href{material/sounds.zip}{sounds}\footnote{The files are public domain from \href{https://freesound.org/}{freesound.org}.} file and unzip it into a \emph{Sounds} subfolder in the seminar directory.

\hypertarget{sound-effects}{%
\section{Sound effects}\label{sound-effects}}

Let us add ``clicking'' sounds whenever the player turns the card. For this, we will use \href{https://psychopy.org/api/sound.html}{sound} module of PsychoPy library. If your sound does not play, ask me and we will try to set your sound libraries up.

First, you need to import the \texttt{Sound} class as suggested in the manual:

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{from}\NormalTok{ psychopy.sound }\ImportTok{import}\NormalTok{ Sound}
\end{Highlighting}
\end{Shaded}

Next, create a new sound and assign it to a variable \texttt{click\_sound}, just like you created the visual stimuli. Use a note name (\emph{e.g.} \texttt{"C"} or \texttt{"A"}) and a short duration (\emph{e.g.}, \texttt{0.1} or \texttt{0.2} seconds). Do this at the beginning, right after we have created the mouse.

Finally, you need to \texttt{.play()} this sound just like you \texttt{.draw()} the visual stimuli. However, in PsychoPy by default the sound will not rewind back to the beginning after it finished playing (at least not for the generated sound and the setup I have). So once you play it once, it is ``at the end'' and the next time you try to play it, there will be no sound (because it has finished playing already). To ``rewind'' the sound to the beginning, you first \texttt{.stop()} it and then, immediately, \texttt{.play()} it (a bit counterintuitive but works). Do it when the player turns the card over (not just clicks somewhere).

Put your code into \emph{exercise01.py}.

\hypertarget{sound-from-file}{%
\section{Sound from file}\label{sound-from-file}}

Now, let us use more complex prerecorded sounds. Put the files from the \textbf{sounds.zip} folder into a \emph{Sounds} subfolder of the Memory game. Mixing generated sounds (like we used in the example above) with prerecorded does not always work and it is the limitation of the libraries that PsychoPy relies upon. Thus, let us replace the way the create the \texttt{click\_sound} by using \emph{click.wav} instead of the note value. Note that you must specify the path to that file (it is in the \texttt{"Sounds"} folder), so use use \texttt{os.join.path()}.

Interestingly, at least for my setup, the sound it reset automatically, so you do not need to \texttt{.stop()} it before you \texttt{.play()} it. Thus, you can drop that extra \texttt{.stop()} call.

Put your code into \emph{exercise02.py}.

\hypertarget{feedback-sounds}{%
\section{Feedback sounds}\label{feedback-sounds}}

Now let us add two more sounds: \texttt{correct\_sound} variable that uses \texttt{"correct.wav"} and \texttt{error\_sound} that uses \texttt{"error.wav"}. They should be played when two cards are opened, right before the delay. Play \texttt{correct\_sound} if the cards matched, \texttt{error\_sound} otherwise.

\begin{verbatim}
if two cards are opened:
    draw cards
    
    if cards match:
        play correct_sound
    else:
        play error_sound
        
    clock.wait(0.5)
\end{verbatim}

Put your code into \emph{exercise03.py}.

\hypertarget{keeping-sounds-organized-dictionary-comprehension}{%
\section{Keeping sounds organized: dictionary comprehension}\label{keeping-sounds-organized-dictionary-comprehension}}

We now have three variables for three different sounds. We could be tidier than that by putting them into a dictionary \texttt{sounds} and using them as \texttt{sounds{[}\textquotesingle{}correct\textquotesingle{}{]}.play()}. This is a more general, tidier (just one variable rather than lots), and more future-proof approach. You can create this dictionary in a direct way \texttt{sounds\ =\ \{"click"\ :\ Sound(...),\ ...\}} but will learn and use \href{https://www.python.org/dev/peps/pep-0274/}{dictionary comprehension} instead.

Dictionary comprehensions are very similar to list comprehensions. You also loop over a list but you use \texttt{\{\}} instead of \texttt{{[}{]}} and you use an item to generated both a key and the value for a dictionary entry. For example:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{index\_letters }\OperatorTok{=}\NormalTok{ \{i : }\BuiltInTok{chr}\NormalTok{(}\DecValTok{65}\OperatorTok{+}\NormalTok{i) }\ControlFlowTok{for}\NormalTok{ i }\KeywordTok{in} \BuiltInTok{range}\NormalTok{(}\DecValTok{4}\NormalTok{)\}}
\end{Highlighting}
\end{Shaded}

Here, you use the item as a key \texttt{i} and generate a string value for it. Note that although keys \textbf{must be unique}, the values are not, so you can use the same value for all entries. Imagine that you are keeping the score in the game and all players start with a zero:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{players }\OperatorTok{=}\NormalTok{ [}\StringTok{\textquotesingle{}Anna\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}Bob\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}Chris\textquotesingle{}}\NormalTok{]}
\NormalTok{score }\OperatorTok{=}\NormalTok{ \{player : }\DecValTok{0} \ControlFlowTok{for}\NormalTok{ player }\KeywordTok{in}\NormalTok{ players\}}
\end{Highlighting}
\end{Shaded}

Change the code to generate \texttt{sounds} dictionary via comprehension and use it instead of variables. In our case, the three keys should be \texttt{"click"}, \texttt{"correct"}, and \texttt{"error"}. You can generate the filename from these keys, just do not forget to \href{https://www.w3schools.com/python/gloss_python_string_concatenation.asp}{add} the \texttt{".wav"} extension.

Put your code into \emph{exercise04.py}.

\hypertarget{logging-data}{%
\section{Logging data}\label{logging-data}}

Although we recorded basic stats like the number of attempts or the total amount of time a player required, for a real experiment you would want to record as much information as possible. In our case, we would want to record every card flip. In the real experiment, that would inform us which chicken that are easier or harder to memorize.

For this, we will use \href{https://psychopy.org/api/data.html\#experimenthandler}{ExperimentHandler}, which is a part of experimental scheduling and data logging tools of PsychoPy. Basically, we need to have three additional pieces of code: 1) one that creates the handler, 2) one that logs the information about the click (card, time, and attempt number), 3) one that save the log to a file.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Create an \texttt{ExperimentHandler()} object and assign it to the \texttt{exp} variable. Do it near the place where you created the window. There are multiple options you can specify but for out intents and purposes the defaults will do.
\item
  To log information about each click, you need to first \href{https://psychopy.org/api/data.html\#psychopy.data.TrialHandler.addData}{.addData(key, value)} for each variable (key) and value you want to record. In our case you need to call it three times for \texttt{"card"} (value is the \texttt{"filename"} of the card the player clicked on), \texttt{"attempt"} (value is the index of the current attempt), and \texttt{"time"} (value is the time since the start, you already have a \texttt{timer} variable that you can use for this). After all three \texttt{.addData()} calls, you need to tell the handler to advance to the next row of you log table using \href{https://psychopy.org/api/data.html\#psychopy.data.ExperimentHandler.nextEntry}{.nextEntry()} method. Put this code right after your ``flipped'' the card.
\item
  To save information to a file, you need to call \href{https://psychopy.org/api/data.html\#psychopy.data.ExperimentHandler.saveAsWideText}{.saveAsWideText(\ldots)} method of the \texttt{exp}. You need to supply the \texttt{filename} parameter and, possibly, further options such as a delimiter (\texttt{delim}). My suggestion would be to use a filename such as \texttt{"log.csv"} and \texttt{","} for a delimiter symbol (this would make a standard comma-separated-values file that any program can read). Put this code at the very end after the game over message.
\end{enumerate}

Put your code into \emph{exercise05.py}.

\hypertarget{more-rounds}{%
\section{More rounds}\label{more-rounds}}

We have been using left-facing chicken (the image files that start with \texttt{"l"}) but we also have right-facing chicken (the image files that start with \texttt{"r"}). Let us use both sets, so that games run for two rounds, first left- then right-facing chicken.

For this, we will need to create a variable with the list of conditions. Let us, inventively, call it \texttt{conditions} and it will be a simple list of two items: \texttt{"\textquotesingle{}l\textquotesingle{}"} and \texttt{"r"}. Create this variable in the beginning, \textbf{before} you create cards.

Next, create an outer loop over the conditions. You code should look roughly like that

\begin{verbatim}
imports
creating window, mouse, sounds, experiment handler, etc.
create conditions list
for condition in conditions:
    create cards using condition letter to filter files
    prepare everything for the round (gameover variable, timer, attempts counter, etc.)
    while not gameover:
        visuals
        mouse handling
        keyboard handling
    game over message (change it to block results message)
        
save logs
close window
\end{verbatim}

When you create cards use the \texttt{condition} (assuming that you used \texttt{for\ condition\ in\ conditions:}) instead of the hardcoded \texttt{"l"} to filter the files. You also to need to log the condition. Add a \texttt{exp.addData()} call for it along the other ones.

Finally, modify your ``game-over'' message to be ``end-of-the-block'' message. You still should show the stats, change only with wording.

Put your code into \emph{exercise06.py}.

\hypertarget{random-order}{%
\section{Random order}\label{random-order}}

Randomize order of conditions before the main loop.

Put your code into \emph{exercise07.py}.

\hypertarget{abba-order}{%
\section{ABBA order}\label{abba-order}}

When running an actual experiment, you may want to account for the learning effect. If conditions are presented in separate blocks (as in our case), the ones that occur later will benefit from learning (although they will also suffer because of fatigue). One way to even things out, is present conditions twice in a direct and, then, a reverse order (ABBA). This way, a condition which was used first (no learning) is also the last one (maximal learning).

Once you randomized the order of the first two blocks, you need to add the same list but in a reverse order. One possibility is a \href{https://docs.python.org/3/tutorial/datastructures.html}{.reverse()} method. However, it reverses the list itself in-place. Instead you should use \href{https://docs.python.org/3/reference/expressions.html?highlight=slicing\#slicings}{slicing} to create a \emph{new} reversed list before adding it to the original one. Read again on \protect\hyperlink{lists}{lists}, if you forgot how it works. The idea is simply to \texttt{conditions\ =\ conditions\ +\ conditions-that-are-sliced-to-be-in-reverse-order}. You can test this code in a Jupyter cell, before putting into the main code.

Put your code into \emph{exercise08.py}.

\hypertarget{we-want-more}{%
\section{We want more!}\label{we-want-more}}

Now you have a real working experiment with randomized condition order, logging, feedback, etc. Think about how you can improve it further. Instructions? More/less feedback?

\hypertarget{the-skill-of-programming}{%
\chapter{The skill of programming}\label{the-skill-of-programming}}

\hypertarget{writing-the-code}{%
\section{Writing the code}\label{writing-the-code}}

Programming is not about writing code that works. That, obviously, must be true but it is only the minimal requirement. Programming is about writing a clear easy-to-read code that others and, perhaps even more importantly, you-two-weeks later can understand. Below are several suggestions on how you can improve your code.

\begin{itemize}
\tightlist
\item
  \textbf{Use a linter.} In VS Code, press \emph{Ctrl + Shift + P} and start typing \texttt{Python:\ Select\ linter}. You will be offered a number of choices, pick \emph{pylint} (that's the one I use) or \emph{flake8} (it is more strict). VS Code will offer you to install the actual linter package, if it is missing. Then, the linter will analyze your code after every save and highlight issues it finds: spaces where should be none, no spaces where should be some, wrong names, trailing spaces, overly long lines, etc. Try to address all the problems as it will make you code look consisten, ``standard'', and, therefore, readable. However, use your better judgment because sometimes longer-than-linter-likes line is more readable than two shorter ones. Similarly, a ``bad'' variable name by linter standards can be a meaningful name for a psychologist. Remember, your code is for people, not for the linter.
\item
  \textbf{Document your code.} Every time you create a new function: document it. New class: document it. New constant: unless it is super clear from the name alone, document it. First, VS Code is smart enough to parse Numpy docstring on the fly, so it will show this help to you whenever you use your own functions. Second, it forces you to think and formulate (in human language!) what the function is doing, what type the arguments are, what is the range of valid values, what are the defaults, what should it return, etc. More often than not, you will realize that you have overlook some important detail that is not apparent from the code itself.
\item
  \textbf{Add some air.} Separate chunks of code with some empty lines. Think paragraphs in the normal text, you wouldn't your book to be a single paragraph nightmare? Put a comment before each chunk that explains what it does but not \emph{how} it does it. E.g., in our typical PsychoPy-based game there is a point when we draw all stimuli and flip the window buffers. That is a nice self-contained chunk that can be described as \texttt{\#\ drawing\ all\ stimuli}. The code provides details on what exactly is drawn, what is the drawing order, etc. But that single comment will help you understand what this chunk is about and whether it is relevant for you at the moment. Same goes for \texttt{\#\ processing\ key\ presses} or \texttt{\#\ checking\ gameover\ conditions}, etc. But be careful and make sure that the comment describes the code correctly. E.g., if the comment says \texttt{\#\ drawing\ all\ stimuli} where should be no stimuli-drawing code anywhere else!
\item
  \textbf{Write your code one teeny-tiny step a time.} Your motto should be ``Slow but steady''. This is the way I guide you through the assignments. Start with a something simple like a static rectangle or image. Make sure it works. Add a minor functionality (change in color, position, another rectangle, storing it as an attribute, etc.). Make sure it works. Never go to the next step unless you fully understand what your current code is doing and you are 100\% certain that it behaves as it should. This tortoise-speed approach may feel silly and overly slow but it is still faster than writing a large chunk of code and then trying to make sure that it all works. It is much easier to solve simple problems one at a time than a lot of them simultaneously.
\end{itemize}

Unfortunately, these tricks won't work it you do not use them! So you should \emph{always} use them and they should become your \emph{good habits}, like using a seat belt. It does nothing on most (hopefully, all) days but you wear it because it might suddenly become extremely useful and you can never be sure when this will happen. Same with coding. Quite often you will be tempted to write ``quick-n-dirty'' code because this is just a ``simple test'', temporary solution, a prototype, pilot experiment, etc. But, as they say in Russia ``There is nothing more permanent than a temporary solution'', and you may find that your toy code grew into a full blown experiment and it is a mess. Or you want to come back to that pilot experiment but realize that it is easier to start from scratch than to understand how that monster works\footnote{Happened to me more often than I dare to admit.}. Thus, resist the temptation! Form the good habits and you future-you will be very grateful!

\hypertarget{reading-the-code}{%
\section{Reading the code}\label{reading-the-code}}

My experience with programming in general and on this seminar in particular is that most problems you get stuck with are simple (to be point of being dumb) and obvious in retrospect\footnote{Hindsight is always 20/20!}. Unfortunately, this knowledge is of little comfort while you are trying to figure out why the bloody thing does not work! Here are several suggestions that could help you to resolve them faster.

\begin{itemize}
\item
  \textbf{Think like a computer.} Read the code line-by-line and ``execute'' it the way the compute would. Use pen-and-paper to keep the track of variables. Trace which chunks of code can be reached when. Slow yourself down and make sure you understand each line and are able to keep track of the variables. Once you do that it will be easy to spot a mistake.
\item
  \textbf{Pretend that you've never seen this code in your life.} Assume that you have no idea what it is doing. Quite often you \emph{literally} do not see a mistake because your brain fills-in details and bends the reality to match your expectations. You \emph{know} what this chunk of code should be doing, so instead of reading it you skim through it and, unless it looks obviously terribly wrong, assume that it does what it should. This is not just programming-specific thing but a general feature of our perception. If you ever proof-read your writing for typos, you know how mind-boggling difficult it is to spot them\footnote{Advice, read each paragraph backwards: Last sentence, penultimate sentence, etc. This breaks the flow of the text and helps you concentrate on words rather than on the meaning and the story.}! Turning your expectations off is hard but is immensely helpful.
\item
  \textbf{Use the debugger.} Put breakpoints and execute the code step-by-step. Check values of variables using ``Watch'' tab. Use debug console to check whether functions return the results that they should. For complex conditions or mathematical formulas, split them into small bits, copy and execute these bits in the debug console and check whether numbers add up. Make sure that a code chunk checks out and then proceed to analyze the next one. Debugging is particularly helpful to identify the code that is not reached or reached at the wrong moment.
\end{itemize}

\hypertarget{zen-of-python}{%
\section{Zen of Python}\label{zen-of-python}}

I also found \href{https://www.python.org/dev/peps/pep-0020/}{Zen of Python} to be good inspiration on how to approach programming.

\hypertarget{seminar-02-01}{%
\chapter{Snake game}\label{seminar-02-01}}

Welcome back! The purpose of today's seminar to refresh your knowledge of Python acquired previously. We will use dictionaries and lists, as well as conditional statements and loops. Plus, you will need to write functions.\footnote{Sneaky preview: You will start learning about object-oriented programming during our next seminar and we will turn it into object-based game.}

\hypertarget{assignments}{%
\section{Assignments}\label{assignments}}

For this and following projects, use Python IDE of your choice (I would recommend \protect\hyperlink{install-vs-code}{Visual Studio Code}). You still could and should use Jupyter for playing with and testing small code snippets, though. I've added a section on setting up \protect\hyperlink{debug-in-vs-code}{debugging in VS Code} in \protect\hyperlink{getting-started}{Getting Started}, take a look once you are ready to run the code.

From now on, create a separate subfolder for each seminar (e.g.~\emph{Seminar 01} for today) and create a separate file (or files, later on) for each exercise\footnote{You can ``Save as\ldots{}'' the previous exercise to avoid copy-pasting things by hand.} (e.g., \emph{exercise01.py}, \emph{exercise02.py}, etc.). This is not the most efficient implementation of a version control and will certainly clutter the folder. But it would allow me to see your solutions on every step, which will make it easier for me to comment on them. For submitting the assignment, just zip the folder and upload the zip-file.

\hypertarget{snake-game-an-overview}{%
\section{Snake game: an overview}\label{snake-game-an-overview}}

Today, we will program a good old classic: the snake game! The story is simple: you control a snake trying to eat as many apples as you can. Every time you consume an apple, snake's length increases. However, if you hit the wall or bite yourself, the game is over (or you lose one of your lives and game is over once you run out of lives).

Here is how the final product will look like.

As before, we will program the game step by step, starting with an empty gray PsychoPy window. Here is the general outline of how we will proceed:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Create boilerplate code to initialize PsychoPy.
\item
  Figure out how to place a square. We need this because our snake is made of square segments and lives on a rectangular grid made of squares.
\item
  Create a single segment stationary snake\footnote{Not very exciting, I know. But one has to start somewhere!}.
\item
  Make the snake move assuming a rectangular grid.
\item
  Implement ``died by hitting a wall''.
\item
  Add apples and make the snake grow.
\item
  Add check for biting itself (and dying).
\item
  Add bells-and-whistles to make game look awesome.
\end{enumerate}

As you can see, each new step builds on the previous one. Because of that, remember, do not proceed to the next step until the current one works and you fully(!) understand what each line of code does. Any leftover uncertainty will linger, grow and complicate your life disproportionately!

\hypertarget{initializing-psychopy}{%
\section{Initializing PsychoPy}\label{initializing-psychopy}}

To remind yourself on how you initialize PsychoPy window, see \protect\hyperlink{seminar08}{here}. Let us plan ahead and decide on windows size and its units. Recall that PsychoPy has \protect\hyperlink{psychopy-units}{five different units} for size and position. Given that our snake will be composed of square segments and move on a grid made out of squares, which units should we pick? Read on \protect\hyperlink{psychopy-units}{units} and think which units you would pick before continuing

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

My suggestion would be \texttt{"norm"} units as they make sizing squares easy, as long as we use a suitable aspect ratio. Thus, let us think about the grid. We can define its width and height in \emph{squares}, e.g., a 30 × 20 grid should give us enough space to try things out but we can always increase the resolution of the game later. Create a \protect\hyperlink{constants}{constant} \texttt{GRID\_SIZE} and assign a \href{https://docs.python.org/3/tutorial/datastructures.html\#tuples-and-sequences}{tuple} of \texttt{(width,\ height)} to it. Note that window's aspect ratio will depend on the size of the grid that we pick. If you want to have a square window, use a 30 × 30 grid.

We also need to define an \emph{absolute} size of a square in pixels (call the constant \texttt{SQUARE\_SIZE\_PIX}), which will determine how large each square will look on the screen and, therefore, will determine the absolute size of the window: \(window~height = window~height~in~squares * square~size~in~pixels\) (same goes for the width). Note that this parameter determines how the game looks, double the size of the square in pixels and that will double both width and height of the window.

Put it all together. You could should look roughly as follows:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# import all libraries and modules you need}

\CommentTok{\# define constants GRID\_SIZE and SQUARE\_SIZE\_PIX}

\CommentTok{\# create PsychoPy window, computing it size in pixels from the two constants}

\CommentTok{\# wait for any key press (just so that window stays on the screen)}

\CommentTok{\# close PsychoPy window}
\end{Highlighting}
\end{Shaded}

Experiment with different grid and square sizes and pick the one that fits your screen.

Put your code into \emph{exercise01.py}.

\hypertarget{adding-a-square}{%
\section{Adding a square}\label{adding-a-square}}

As I already wrote, our game will be made of squares. Snake is made of squares. Grid it lives on is made of squares. An apple is a square. Which means we need to know the size of that square in the units of the window and we need to know \emph{where} should each square go in the window, based on its coordinates on the grid.

Computing the size of the square in units of window size is easy, so let us start with it first. If you used \texttt{"norm"} units for the PsychoPy window, we know that both its width and its height go from -1 (bottom) to 1 (top). We also know that we have to fit in \texttt{GRID\_SIZE{[}0{]}} squares horizontally and \texttt{GRID\_SIZE{[}1{]}} vertically (recall that \texttt{GRID\_SIZE} defines the size of our grid in number of squares). Create a new constant \texttt{SQUARE\_SIZE} that is a \emph{tuple} and compute square size in units of \texttt{"norm"} based on total width/height of the window in the \texttt{"norm"} units (not the pixels!) and number of squares we need to fit in horizontally/vertically.

Next, let us create a function that maps a position on the grid to a position in the window. This way, we can think about position of the snake or apples in terms of the grid but draw them in the window coordinates. Create a new file \emph{utilities.py} and create a function \texttt{map\_grid\_to\_win()} that takes a tuple of integers \texttt{(x\_index,\ y\_index)} with grid position (I called this argument \texttt{ipos}) plus a second parameter with a square size (that we just computed) and returns a tuple of floats \texttt{(x\_pos,\ y\_pos)} with the coordinates of the \emph{center} of the square in \emph{window} coordinates. Take a look at the drawing below to see the logic of the computation. The red text show location of red points in \emph{window norm} units, whereas the black font shows location of a square in \emph{grid index} units. Note that you need to compute where the \emph{center} of the square should go.

\includegraphics[width=14.74in]{images/snake-grid}

I suggest using Jupyter notebook to create and debug this function and then copying it into \emph{utilities.py}. Remember to document the function following \href{https://numpydoc.readthedocs.io/en/latest/format.html}{NumPy docstring format}.

Put function map\_grid\_to\_win into \emph{utilities.py}.

Now, test this function by creating a square (you remember which constant defines its size, right?) and placing it at different locations of the grid. Check \protect\hyperlink{seminar08-add-square}{here}, if you forgot how to create squares in PsychoPy. Run the code several times, using different grid indexes or adding several squares to check that it work as intended. Your code should look roughly as follows

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# import all libraries and modules you need}

\CommentTok{\# import map\_grid\_to\_win function from utilities.py file}

\CommentTok{\# define constants GRID\_SIZE and SQUARE\_SIZE\_PIX}
\CommentTok{\# compute SQUARE\_SIZE constant}

\CommentTok{\# create PsychoPy window, computing it size in pixels from the two constants}

\CommentTok{\# create a square (Rect stimulus) with size of SQUARE\_SIZE and position computed}
\CommentTok{\#   via grid\_to\_win function from a pair of grid coordinates}

\CommentTok{\# draw square and flip the window}

\CommentTok{\# wait for any key press (just so that window stays on the screen)}

\CommentTok{\# close PsychoPy window}
\end{Highlighting}
\end{Shaded}

Put your code into \emph{exercise02.py}.

\hypertarget{adding-the-snake}{%
\section{Adding the snake}\label{adding-the-snake}}

Now, let us think about how can we represent a snake. It consist of one or more segments. The first one is its head, while the last one is its tail\footnote{A single segment snake is a special case, as its head is also its tail!}. Thus, we can think about it as a \href{https://docs.python.org/3/tutorial/datastructures.html\#more-on-lists}{list} of individual segments.

Now let us consider an individual segment. We need to 1) keep track of its location in \emph{grid} coordinate system and 2) have its visual representation --- a square, just like the one you create during the previous exercise --- positioned in \emph{window} coordinate system. Good news is, you already have a function that maps the former on the latter, so as long as you know where the segment is on the grid, placing its square within the window is easy. As each segment has \emph{two} pieces of information associated with it, it makes sense to represent it as a \href{https://docs.python.org/3/tutorial/datastructures.html\#dictionaries}{dictionary} with two keys: \texttt{"pos"} (tuple of x and y in grid coordinates) and \texttt{"visuals"} (the square).

To keep code nicely compartmentalized and isolated, add a new function to \emph{utilities.py} called \texttt{create\_snake\_segment}. It should take three arguments:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  a variable with PsychoPy window, which you need to create an square visual.
\item
  a tuple \texttt{(x,\ y)} with segment position within the grid.
\item
  a square size, which you need for \texttt{map\_grid\_to\_win} function.
\end{enumerate}

It should return a dictionary with \texttt{"pos"} and \texttt{"visuals"} field, as we agreed upon above.

In the main code, create a variable \texttt{snake} that is a list with a single segment in the center of the screen (you need to compute it from \texttt{GRID\_SIZE} using floor division operator \href{https://python-reference.readthedocs.io/en/latest/docs/operators/floor_division.html}{//}). Instead of drawing a single square one call at a time, as in the previous exercise, you will need to draw all segments of the snake using a \emph{for} loop\footnote{You don't \emph{really} need it for a single segment snake we have now but there is no other way to do it later, so let us do it properly from the start}. Here is the outline:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# import all libraries and modules you need}

\CommentTok{\# import map\_grid\_to\_win and create\_snake\_segment functions from utilities.py file}

\CommentTok{\# define constants GRID\_SIZE and SQUARE\_SIZE\_PIX}
\CommentTok{\# compute SQUARE\_SIZE constant}

\CommentTok{\# create PsychoPy window, computing it size in pixels from the two constants}

\CommentTok{\# create the snake variable as a list with a single segment at the center of the screen }


\CommentTok{\# draw all snake segments using for loop  }
\CommentTok{\# flip the window}

\CommentTok{\# wait for any key press (just so that window stays on the screen)}

\CommentTok{\# close PsychoPy window}
\end{Highlighting}
\end{Shaded}

Put function \emph{create\_snake\_segment} into \emph{utilities.py} and your modified code into \emph{exercise03.py}.

\hypertarget{adding-main-game-loop}{%
\section{Adding main game loop}\label{adding-main-game-loop}}

Our current game is not \emph{very} dynamic: it draws the (very small) snake once and waits for a key press before closing the window. Let us add the necessary scaffolding of a main game loop. The game should run \href{https://docs.python.org/3/reference/compound_stmts.html\#the-while-statement}{while} variable \texttt{gameover} is \texttt{False}. Inside the main loop, on each iteration you should draw the snake (and flip the window after that) and check whether participant press \texttt{"escape"} key via \href{https://www.psychopy.org/api/event.html\#psychopy.event.getKeys}{event.getKeys()}. If they did, \texttt{gameover} should become \texttt{True}.

The code outline is

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# import all libraries and modules you need}

\CommentTok{\# import map\_grid\_to\_win and create\_snake\_segment functions from utilities.py file}

\CommentTok{\# define constants GRID\_SIZE and SQUARE\_SIZE\_PIX}
\CommentTok{\# compute SQUARE\_SIZE constant}

\CommentTok{\# create PsychoPy window, computing it size in pixels from the two constants}

\CommentTok{\# create the snake variable as a list with a single segment at the center of the screen }

\CommentTok{\# set gameover to False}

\CommentTok{\# while not gameover:}
\CommentTok{\#     draw all snake segments using for loop  }
\CommentTok{\#     flip the window}

\CommentTok{\#     if escape key was pressed:}
\CommentTok{\#         set gameover to True}

\CommentTok{\# close PsychoPy window}
\end{Highlighting}
\end{Shaded}

Put your code into \emph{exercise04.py}.

\hypertarget{get-a-move-on}{%
\section{Get a move on!}\label{get-a-move-on}}

Now we need to understand how we will move the snake given that it consist of many segments. Assume that we have a four segment snake that moves up, as in the picture below.

\includegraphics[width=14.36in]{images/snake-movement}

Technically, we need to move each segment to a new position. The very first ``head'' segment moves to the position above the snake. The second segment moves to where the head was before. The third moves into the previous position of the forth one, etc. We \emph{can} implement movement like that but instead we will utilize the fact that, unless colored as in the figure above, all segments look identical. Look at the uniformly colored snake below. We can ``move'' it by adding a new segment at a new location (growing a new head at the bity end of the snake, marked as red) and clipping off the last tail segment (marked by the cross), so that the previously penultimate segment becomes the tail. The rest can stay where they are, saving us a lot of hustle when the snake is long!

\includegraphics[width=14.36in]{images/snake-movement-2}

In the program, we \href{https://docs.python.org/3/tutorial/datastructures.html\#more-on-lists}{list.insert(index, value)}\footnote{We could also have used \texttt{dqueue} class from \emph{collections} library instead of the \texttt{list}. It is, essentially, a list that allows appending and poping from the left as well.} the new head segment at index 0 and we remove the tail via \href{https://docs.python.org/3/tutorial/datastructures.html\#more-on-lists}{list.pop()}.

To keep things neat and tidy, we will implement two functions: \texttt{grow\_snake()} and \texttt{trim\_snake()}. Why not combine both actions into a single function? Strategic thinking! Once we add apples to the game, the snake will grow after consuming them by not shedding the tail. Thus, separating these two functions now will simplify our lives later on\footnote{To be honest, I have initially implemented it as a single \texttt{move\_snake()} function , wrote things up to eating apples, realized the problem, returned and rewrote the notes. So, it is a hindsight type of strategic thinking.}.

The \texttt{grow\_snake()} function should take the following parameters:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  parameter for the snake itself, which we will modify. To minimize the potential confusion, do not call it \texttt{snake} but something (slightly) different, e.g., \texttt{the\_snake}. This way it will be easier to remember that this is a parameter, not the global vairable.
\item
  a variable with PsychoPy window, which you need to create a new head segment.
\item
  a tuple \texttt{(x,\ y)} with \emph{direction of movement} (call it \texttt{dxy} for change in xy coordinates). I.e., it will be \texttt{(-1,\ 0)} for leftward moving snake, \texttt{(1,\ 0)} for right moving, \texttt{(-1,\ 0)} for up, and \texttt{(1,\ 0)} for down.
\item
  a square size, which you need for \texttt{create\_snake\_segment} function.
\end{enumerate}

Inside the function, you compute the coordinates for the new head segment based on the position of the current head (the very first element of the snake) and the direction of motion, (the third parameter \texttt{dxy},) create a new snake segment at that location (you wrote a function for that!) and insert it before all other elements.

Somewhat counterintuitively, this function does not need to return anything because the snake, which we are passing to it as a first parameter, is a \emph{mutable} list. Therefore, it is passed \emph{by reference} and any changes that we apply to it inside the function will affect the global variable itself\footnote{Re-read about \protect\hyperlink{mutable-objects}{mutable objects}, if you forgot how it works.}.

The \texttt{trim\_snake()} function is even simpler as it takes the snake as the only parameter and trims its tail. Again, because the snake is a mutable list, you do not need to return anything.

To test these functions, let us create a three-segment long snake at location \texttt{(10,9)}, \texttt{(11,\ 9)}, and \texttt{(12,\ 9)} and move it (grow, then trim) upwards every time the player presses \texttt{"space"} button. This does not look like a real game but will make it easier to debug, as you can put a break-point to check computation step-by-step. Also note that, eventually, the snake will crawl out of the window but we will worry about this later. Here is the code outline:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# import all libraries and modules you need}

\CommentTok{\# import all functions you need from from utilities.py file}

\CommentTok{\# define constants GRID\_SIZE and SQUARE\_SIZE\_PIX}
\CommentTok{\# compute SQUARE\_SIZE constant}

\CommentTok{\# create PsychoPy window, computing it size in pixels from the two constants}

\CommentTok{\# create the snake variable as a list with three segments}

\CommentTok{\# set gameover to False}

\CommentTok{\# while not gameover:}
\CommentTok{\#     draw all snake segments using for loop  }
\CommentTok{\#     flip the window}

\CommentTok{\#     if escape key was pressed:}
\CommentTok{\#         set gameover to True}
\CommentTok{\#     else if the key was "space":}
\CommentTok{\#         move snake up  }
\CommentTok{\#}
\CommentTok{\#}
\CommentTok{\# close PsychoPy window}
\end{Highlighting}
\end{Shaded}

Put functions \emph{grow\_snake} and \emph{trim\_snake} into \emph{utilities.py} and your modified code into \emph{exercise05.py}.

\hypertarget{self-motion}{%
\section{Self-motion}\label{self-motion}}

Our snake should move by itself, not when the player presses \emph{space} button. For this, we can call \texttt{grow\_snake()} and \texttt{trim\_snake()} functions on every iteration of the main game loop. However, by default, when you call \texttt{win.flip()} it will synchronize your loop with the refresh rate of the screen (typically, 60 Hz). This means that we would call these functions 60 times per second or, to put it differently, the snake will move 60 squares per second. This is waaaay too fast, given that our original grid size was just 30×20 squares. To appreciate just how fast this is, remove \texttt{if\ key\ was\ space:...} conditional statement, and call grow/trim snake functions on every iteration and see the snake fly off the screen.

Instead, we should decide on snake's speed, e.g., 4 squares per second, and define it as a new constant \texttt{SNAKE\_SPEED}\footnote{Note that speed does not need to be an integer number of squares per second. It can move at 1.5 squares per second, so 3 squares every two seconds.}. From that we can compute a new constant (\texttt{SNAKE\_TIME\_INTERVAL}) that expresses the time interval between calls of grow/trim functions, so that it is called \texttt{SNAKE\_SPEED} times per second\footnote{Why two constants that express the same information? We could define only the \texttt{SNAKE\_TIME\_INTERVAL} but for a human it makes it harder to understand just how fast the movement will be. In cases like these, I prefer to have two constants, one human-oriented, another computer-oriented. Remember, it is not just about writing a working code, it is about writing a code that is easy for a human to understand.}. For 4 squares/second, that time interval will be 0.25 seconds. Do not hard code it, compute it from \texttt{SNAKE\_SPEED}!

Now, we just need to use a \href{https://www.psychopy.org/api/clock.html\#psychopy.clock.Clock}{clock} or a \href{https://www.psychopy.org/api/clock.html\#psychopy.clock.CountdownTimer}{countdown timer}\footnote{They work the same they, it is just a question of whether you start from zero and check whether time is over \texttt{SNAKE\_TIME\_INTERVAL} (\href{https://www.psychopy.org/api/clock.html\#psychopy.clock.Clock}{clock}) or you start at \texttt{SNAKE\_TIME\_INTERVAL} and check whether the time ran out/is already negative (\href{https://www.psychopy.org/api/clock.html\#psychopy.clock.CountdownTimer}{timer}).} We create it just before the main loop. Inside the loop, we check whether the elapsed time is equal to or greater than \texttt{SNAKE\_TIME\_INTERVAL}. If it is, move the snake and reset the timer. Try setting different speed and see whether the snake moves consistently.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# import all libraries and modules you need}

\CommentTok{\# import all functions you need from from utilities.py file}

\CommentTok{\# define constants GRID\_SIZE and SQUARE\_SIZE\_PIX}
\CommentTok{\# compute SQUARE\_SIZE constant}
\CommentTok{\# define SNAKE\_SPEED and compute SNAKE\_TIME\_INTERVAL}

\CommentTok{\# create PsychoPy window, computing it size in pixels from the two constants}

\CommentTok{\# create the snake variable as a list with three segments}

\CommentTok{\# set gameover to False}
\CommentTok{\# create a clock or a countdown timer}
\CommentTok{\# while not gameover:}
\CommentTok{\#     draw all snake segments using for loop  }
\CommentTok{\#     flip the window}

\CommentTok{\#     if escape key was pressed:}
\CommentTok{\#         set gameover to True}
\CommentTok{\#}
\CommentTok{\#     Check whether elapsed time is greater than SNAKE\_TIME\_INTERVAL, }
\CommentTok{\#         move snake up and reset clock or countdown timer, if that is the case}
\CommentTok{\#}
\CommentTok{\#}
\CommentTok{\# close PsychoPy window}
\end{Highlighting}
\end{Shaded}

Put your code into \emph{exercise06.py}.

\hypertarget{describing-direction-using-words}{%
\section{Describing direction using words}\label{describing-direction-using-words}}

In our current design, we describe direction as a tuple \texttt{(dx,\ dy)}. Let us change it, so that it is described using words \texttt{"up"}, \texttt{"down"}, \texttt{"left"}, and \texttt{"right"}. This is not strictly necessary but will make our lives somewhat easier later on when we add steering controls. More importantly, it will serve a didactic purpose as well, showing how you can use dictionaries to translate values from one representation to another.

Thus, let us create a new string variable \texttt{direction} and set it to \texttt{"up"} (or any other direction you like). We will keep the \texttt{grow\_snake()} function as is and will translate individual strings to pairs of \texttt{(dx,\ dy)} values. E.g., \texttt{"up"} corresponds to \texttt{(0,\ -1)}, \texttt{"right"} to \texttt{(1,\ 0)}, etc.

We can implement this translation via if-elif conditional statements:

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{if} \BuiltInTok{dir} \OperatorTok{==} \StringTok{"up"}\NormalTok{:}
\NormalTok{  dxy }\OperatorTok{=}\NormalTok{ (}\DecValTok{0}\NormalTok{, }\OperatorTok{{-}}\DecValTok{1}\NormalTok{)}
\ControlFlowTok{elif} \BuiltInTok{dir} \OperatorTok{==} \StringTok{"right"}\NormalTok{:}
\NormalTok{  dxy }\OperatorTok{=}\NormalTok{ (}\DecValTok{1}\NormalTok{, }\DecValTok{0}\NormalTok{)}
\NormalTok{  ...}
\end{Highlighting}
\end{Shaded}

However, this approach introduces a lot of repetitive code and does not scale particularly well. Instead, we can use a dictionary (let us call it \texttt{DXY} as it is another constant) with \texttt{"up"}, \texttt{"right"}, etc. string as keys and tuples \texttt{(0,\ -1)}, \texttt{(1,\ 0)}, etc. as values. This way, we can use current value of \texttt{dir} variable as a key to get the \texttt{(dx,\ dy)} pair from \texttt{DXY} dictionary. Note that you should do it in the function call, \textbf{do not} create a temporary variable as in the if-elif examples above.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# import all libraries and modules you need}

\CommentTok{\# import all functions you need from from utilities.py file}

\CommentTok{\# define constants GRID\_SIZE and SQUARE\_SIZE\_PIX}
\CommentTok{\# compute SQUARE\_SIZE constant}
\CommentTok{\# define SNAKE\_SPEED and compute SNAKE\_TIME\_INTERVAL}

\CommentTok{\# define DXY dictionary with (dx, dy) entries for each "up", "down", "right",}
\CommentTok{\#     and "left" keys}

\CommentTok{\# create PsychoPy window, computing it size in pixels from the two constants}

\CommentTok{\# create the snake variable as a list with three segments}

\CommentTok{\# initialize direction variable to one of the four directions}
\CommentTok{\# set gameover to False}
\CommentTok{\# create a clock or a countdown timer}
\CommentTok{\# while not gameover:}
\CommentTok{\#     draw all snake segments using for loop  }
\CommentTok{\#     flip the window}

\CommentTok{\#     if escape key was pressed:}
\CommentTok{\#         set gameover to True}
\CommentTok{\#}
\CommentTok{\#     Check whether elapsed time is greater than SNAKE\_TIME\_INTERVAL, }
\CommentTok{\#         move snake translating direction variable into (dx, dy) pair from DXY}
\CommentTok{\#         reset clock or countdown timer, if that is the case}
\CommentTok{\#}
\CommentTok{\#}
\CommentTok{\# close PsychoPy window}
\end{Highlighting}
\end{Shaded}

Put your code into \emph{exercise07.py}.

\hypertarget{it-is-all-about-control}{%
\section{It is all about control}\label{it-is-all-about-control}}

Playing the game would be more fun, if we could steer the snake! If the player presses \emph{right arrow} key, the snake should turn \emph{clockwise}. Conversely, \emph{left arrow} key, should turn the snake \emph{counterclockwise}. We need to figure out two things. First, how to determine a new direction of motion given the current one and the key that was pressed. Second, we must decide when and how to change the value of \texttt{direction} variable. Let us tackle these problems one at a time.

Determining the new direction of motion is fairly straightforward. If current is \texttt{"up"} and key was \emph{right} (\emph{clockwise} rotation), the new direction should be \texttt{"right"}. If current is \texttt{"down"} and key was \emph{left}, the new direction is again \texttt{"right"}, etc. You could implement it as a bunch of \texttt{if-elif} statements or, better still, use the dictionary look up approach we implemented in the previous exercise. Here, you need a nested dictionary (dictionary inside a dictionary) \texttt{NEW\_DIRECTION{[}key{]}{[}direction{]}}. The first level has two keys \texttt{"left"} and \texttt{"right"} (so, effectively, counterclockwise and clockwise rotation) that selects which translation should be used and the second level is the dictionary that translates current direction into the new direction of motion. E.g., if current direction is \texttt{"down"} and key was \texttt{"right"}, \texttt{NEW\_DIRECTION{[}"right"{]}{[}"down"{]}} should be \texttt{"left"} (rotating clockwise from \texttt{"down"} gets us to \texttt{"left"}). You know how define a simple dictionary. Good news, defining nested dictionaries follows the same rules, so should be straightforward.

Now let us think about when and how should we change value of \texttt{direction} variable. The simplest approach would be to change it as soon as the player presses the key. However, because our snake does not move on every frame this could lead to some odd behavior. Imagine that our game is on ``easy'' mode, so that the snake moves very slowly (one square per second). In this case, the player could easily press \emph{left} twice during that second that would make snake move backwards, because direction was changed by 180°. Snakes, at least our snake, cannot do this. Thus, we need a temporary variable, let us call it \texttt{new\_direction}, which we will set every time the player presses the key but whose value will be transferred to \texttt{direction} only when it is time to move the snake. We will compute it from the current \texttt{direction} and the key pressed. This way, even when the player presses \emph{left} key several times, the snake would still turn only once because we compute the each turn using the same \texttt{direction} value but not the changing \texttt{new\_direction} variable. This also means that players can ``change their mind'', as the last key press before the snake moves will determine the direction of motion.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# import all libraries and modules you need}

\CommentTok{\# import all functions you need from from utilities.py file}

\CommentTok{\# define constants GRID\_SIZE and SQUARE\_SIZE\_PIX}
\CommentTok{\# compute SQUARE\_SIZE constant}
\CommentTok{\# define SNAKE\_SPEED and compute SNAKE\_TIME\_INTERVAL}

\CommentTok{\# define DXY dictionary with (dx, dy) entries for each "up", "down", "right",}
\CommentTok{\#     and "left" keys}

\CommentTok{\# define NEW\_DIRECTION nested dictionary}

\CommentTok{\# create PsychoPy window, computing it size in pixels from the two constants}

\CommentTok{\# create the snake variable as a list with three segments}

\CommentTok{\# initialize direction variable to one of the four directions}
\CommentTok{\# initialize new\_direction(!!!!) to the same value as direction, why do you need to do this?}

\CommentTok{\# set gameover to False}
\CommentTok{\# create a clock or a countdown timer}
\CommentTok{\# while not gameover:}
\CommentTok{\#     draw all snake segments using for loop  }
\CommentTok{\#     flip the window}

\CommentTok{\#     if escape key was pressed:}
\CommentTok{\#         set gameover to True}
\CommentTok{\#     if key is left or right:}
\CommentTok{\#         set new\_direction based on direction and pressed key using NEW\_DIRECTION dictionary }
\CommentTok{\#}
\CommentTok{\#     Check whether elapsed time is greater than SNAKE\_TIME\_INTERVAL, }
\CommentTok{\#         set direction to new\_direction}
\CommentTok{\#         move snake translating direction variable into (dx, dy) pair from DXY}
\CommentTok{\#         reset clock or countdown timer, if that is the case}
\CommentTok{\#}
\CommentTok{\#}
\CommentTok{\# close PsychoPy window}
\end{Highlighting}
\end{Shaded}

Put your code into \emph{exercise08.py}.

\hypertarget{turning-the-hard-way}{%
\section{Turning the hard way}\label{turning-the-hard-way}}

Let us implement the same ``figure out new direction'' code in a more complicated way. The purpose of the exercise is to challenge you, show you new methods of the list, and to demonstrate how you can think about a change of the direction as moving through the list. We won't use this in the main code, so implement it as a function \texttt{compute\_new\_direction(current\_direction,\ pressed\_key)}, which will take two parameters (current direction and pressed key) and will return the new direction of rotation. I strongly recommend writing and debugging code in Jupyter Notebook first and copying it to \emph{utilities.py} at the very end. Also, do not implement it as a function to begin with. Define parameters as two variable with some preset values and debug the rest of the code.

Here is the idea. Imagine that you have a list \texttt{{[}"left",\ "up",\ "right",\ "down"{]}}. For this list, rotation clockwise would correspond to moving through the list to the right (assuming that you jump to the beginning once you move past the last item). Conversely, rotation counterclockwise corresponds to moving to the left (again, assuming that you jump to the end of the list, once you went past the first item). As you see, rotation is expressed as a very intuitive ``motion through the list''.

For the actual implementation, first, define a constant list in the order I've described. Next, you need to identify the location of the current direction within the list using \href{https://docs.python.org/3/tutorial/datastructures.html\#more-on-lists}{index()} method. Then, you need to figure out whether you increase or decrease that index (to move to the right or to the left), based on \texttt{pressed\_key} parameter (you can use dictionary approach or a conditional assignment). Finally, you need to control for range, so that index of \texttt{-1} becomes \texttt{3} (you went too far to the left) and index of \texttt{4} should become \texttt{0}. The most elegant way to do this, is using \texttt{\%} \href{https://python-reference.readthedocs.io/en/latest/docs/operators/modulus.html}{modulus} operation. Hint, \texttt{4\ \%\ 4} is \texttt{0}. What about \texttt{1\ \%\ 4}, \texttt{0\ \%\ 4}, or even \texttt{-1\ \%\ 4}? Check it by hand to get an idea of what I am hinting at. And, of course, do not use \texttt{4} for division, use the length of the list, as it determines the range of values.

Put function compute\_new\_direction into \emph{utilities.py}.

\hypertarget{to-be-continued-1}{%
\section{To be continued\ldots{}}\label{to-be-continued-1}}

We covered a lot of ground today. Next time, we will continue by adding the possibility of killing yourself but also of growing into a longer and cooler snake by eating apples.

\hypertarget{seminar-02-02}{%
\chapter{Snake game, part 2}\label{seminar-02-02}}

Our plan for today is to continue developing the snake game. Our original plan was as follows and we got up to \#4.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Create boilerplate code to initialize PsychoPy.
\item
  Figure out how to place a square. We need this because our snake is made of square segments and lives on a rectangular grid made of squares.
\item
  Create a single segment stationary snake.
\item
  Make the snake move assuming a rectangular grid.
\item
  Implement ``died by hitting a wall''.
\item
  Add apples and make the snake grow.
\item
  Add check for biting itself.
\item
  Add bells-and-whistles to make game look awesome.
\end{enumerate}

As before, create a new folder for this seminar, copy the latest version of \emph{utilities.py} to it and base your further development code on the latest exercise from the previous seminar (should be \emph{exercise08.py}).

\hypertarget{hitting-the-wall}{%
\section{Hitting the wall}\label{hitting-the-wall}}

The last thing that we implemented during the previous seminar was our ability to control the snake. However, you could steer it off the screen and make it go through itself. Let us fix the former!

Develop a new function \texttt{hit\_the\_wall} and put it into \emph{utilities.py}. The function should take \texttt{snake} variable as a first parameter and check whether the head of the snake (which segment is it?) is still within the grid that we defined (how do you check for that?). The function should return a logical value. \texttt{True}, if the head of the snake is outside of the grid limits (so, it is true that the snake hit the wall). \texttt{False}, if it is still inside. I mentioned that you should definitely pass the \texttt{snake} as an obvious parameter of the function but do you need other parameters? If yes, which ones? Document the function!

Test the function by adding a new condition inside the main game loop. Check whether the snake \texttt{hit\_the\_wall()} and, if that is the case, the game should be over. Think about the optimal place where to check for this. You could do it on every iteration but there is a more logical place for it, inside that main loop. Where is it?

Put function \emph{hit\_the\_wall} into \emph{utilities.py} and your updated code into \emph{exercise01.py}.

\hypertarget{is-this-the-snake}{%
\section{Is this the snake?}\label{is-this-the-snake}}

In the next section, we will be adding apples to the game. The catch is that these apples should appear at a location that is \emph{not} occupied by the snake. Otherwise, we would generate apples directly into snake's stomach. Practical for the snake but defeats the purpose of the game. To rephrase this problem, we need a function that checks whether a particular grid location is occupied by the snake.

Develop a new function \texttt{is\_inside\_the\_snake} that takes the snake as a first parameter and a tuple with a grid location as a second parameter and returns a logical value whether that grid location is occupied by the snake (\texttt{True}) or not (\texttt{False}). Document the function!

My approach would be to work on this function in a Jupyter Notebook first. To debug it, create a snake by hand hardcoding the list of dictionaries. Note that you only need \texttt{pos} part of the segment's dictionary for this function, so can happily ignore the \texttt{visuals} key. Once you feel the function works, copy it to \emph{utilities.py}.

Put function \emph{is\_inside\_the\_snake} into \emph{utilities.py}.

\hypertarget{an-inedible-apple}{%
\section{An inedible apple}\label{an-inedible-apple}}

Let us add that highly desirable fruit: the apple! We will represent it as a \emph{differently} colored square and snake won't be able to eat it yet. I assume that you used green color for the snake, so apples would yellow, red, or orange (but feel free to pick any color of your fancy). Just like a snake segment, an apple is characterized by its position on the grid and by its visuals, so you can use the same dictionary structure as for the snake's segment.

You need to write a new function \texttt{create\_apple} that will be fairly similar to \texttt{create\_snake\_segment()} function you developed the last time. It should also return a dictionary with \texttt{pos} and \texttt{visuals} field. However, instead of taking a predefined grid location, it should generate one randomly within the grid making sure it is \emph{not} on the snake. The \texttt{is\_inside\_the\_snake} function will help you to ensure the latter. Think about parameters that you need for this function. Remember to document it!

In the main loop, create a new variable \texttt{apple} and initialize it via \texttt{create\_apple()} function. Think about where and when do you need to initialize it. Also, you need to drawi the apple in the main loop. Again, think about where should you do it.

Put function \emph{create\_apple} into \emph{utilities.py} and your updated code into \emph{exercise02.py}.

\hypertarget{eating-an-apple}{%
\section{Eating an apple}\label{eating-an-apple}}

Apples exist for snakes to eat them! Let us add this functionality. The general idea is very simple. If the \emph{head} of the snake moves on to the grid location with an apple, you should not trim its tail. See how useful it was to split growing and trimming into two separate functions? Told you, strategic thinking!

You need to add a conditional statement that if the snake's head \emph{is} on the apple, you should generate a new one the same way as you generated it initially (add the next apple). What should you do, if there is no apple at that location?

Also, if you haven't already done that, modify you code so that you start with a single segment snake.

Put your updated code into \emph{exercise03.py}.

\hypertarget{eating-yourself}{%
\section{Eating yourself}\label{eating-yourself}}

Once our snake grows beyond four segments, it has an opportunity to bite itself\footnote{Why at least five? Draw it on the grid and figure out whether it can do so with four.}. For this, we need to check that, \emph{after} the snake moved, its head is \emph{not} at the same location as one of the segments of its body. Create a new function \texttt{snake\_bit\_itself()} that takes the snake as a single parameter and returns \texttt{True} or \texttt{False} based on whether that is the case. The function is very similar but not identical to \texttt{is\_inside\_the\_snake()} function you implemented earlier. What is the critical difference and why cannot you simply reuse that function?

Once you implemented \texttt{snake\_bit\_itself()} function, you should check for that eventually after it moved and, if that is the case, the game should be over.

Put function \emph{snake\_bit\_itself} into \emph{utilities.py} and your updated code into \emph{exercise04.py}.

\hypertarget{bells-and-whistles-score}{%
\section{Bells and whistles: score}\label{bells-and-whistles-score}}

Now that we have a fully functional game, we can start adding non-essential but nice features to it. The first one will be the score that is equal to the length of the snake. It should read \emph{Score: XXX}. Place it at the top of the window. You will need to use \href{https://www.psychopy.org/api/visual/textstim.html\#psychopy.visual.TextStim}{TextStim} class for this. Think about when to create the text stimulus, when to draw it, and how and when to update the text.

Put your updated code into \emph{exercise05.py}.

\hypertarget{bells-and-whistels-three-lives}{%
\section{Bells and whistels: three lives}\label{bells-and-whistels-three-lives}}

Let us give the player three attempts to achieve the top score. They have three lives, every time the snake dies, the game \emph{but not the score} resets: A single segment snake appears at the center and a new random apple appears elsewhere (where should you put the code to create them?). Once the snake dies three times, the game is over. Think how you can implement this three repetitions.

The score should be cumulative, so at the beginning of round two it should be equal to the final score of round one plus current length of the snake (1 at the very beginning). Think how you can achieve this. \emph{Another important point}: now you have two nested loop, one is for the game, one is for the round. When the snake dies, the round is over and, if you run out of lives, the game as well. When the player presses \emph{escape} both round \textbf{and} the game are over. Think about how you can implement it.

Put your updated code into \emph{exercise06.py}.

\hypertarget{bells-and-whistels-showing-lives}{%
\section{Bells and whistels: showing lives}\label{bells-and-whistels-showing-lives}}

Let us not just repeat the game three times but show the player how many lives they still have. Download the \href{material/heart.png}{heart.png}\footnote{This image was downloaded from \href{https://openclipart.org/}{openclipart.org} and was created by \href{https://openclipart.org/artist/cliparteles}{cliparteles}} and use it show remaining lives at the top-left corner of the screen: three hearts in round one, two hearts in round two, and just a single heart in round three. You will need to use (ImageStim){[}\url{https://www.psychopy.org/api/visual/imagestim.html\#psychopy.visual.ImageStim}{]} for this. Think about the size of images and their location.

Put your updated code into \emph{exercise07.py}.

\hypertarget{bells-and-whistles-difficulty}{%
\section{Bells and whistles: difficulty}\label{bells-and-whistles-difficulty}}

At the moment, the difficulty of the game, the speed with which the snake moves, is fixed and the player has no way of choosing it. Let us create dialog that appears \emph{before} we create the window and start the game that will allow the player to choose between \emph{easy}, \emph{normal}, and \emph{difficult}\footnote{Or, if you played Doom, between \emph{I'm Too Young To Die}, \emph{Hey, Not Too Rough}, \emph{Hurt Me Plenty}, \emph{Ultra-Violence}, and \emph{Nightmare}.}. I leave it up to you to decide which snake speeds correspond to each difficulty (and you can have more than three options, if you want).

To create and run the dialog, use \href{https://www.psychopy.org/api/gui.html\#dlg}{Dlg} class from
\href{https://www.psychopy.org/api/gui.html}{giu} module of PsychoPy. Your challenge for today is to figure out how to use it based on the manual along. Take a look at the example and experiment with in a separate file.

Put your updated code into \emph{exercise08.py}.

\hypertarget{bells-and-whistles-sounds}{%
\section{Bells and whistles: sounds}\label{bells-and-whistles-sounds}}

Download \href{material/game-over-arcade.wav}{game-over-arcade.wav}\footnote{Downloaded from \href{https://freesound.org/}{freesound.org} and created by \href{https://freesound.org/people/myfox14/}{myfox14}} and \href{material/8-bit-game-over-sound.wav}{8-bit-game-over-sound.wav}\footnote{Also downloaded from \href{https://freesound.org/}{freesound.org} and created by \href{https://freesound.org/people/EVRetro/}{EVRetro}}. Use the former whenever the snake dies and use the latter when the player runs out of lives. You will need to use \href{https://www.psychopy.org/api/sound.html\#sound}{Sound} class from \href{https://www.psychopy.org/api/sound.html}{sound} module of PsychoPy.

Put your updated code into \emph{exercise09.py}.

\hypertarget{bells-and-whistles-blinking-game-over-message}{%
\section{Bells and whistles: blinking game over message}\label{bells-and-whistles-blinking-game-over-message}}

Once the game is over, show a blinking ``Game Over'' message \emph{superimposed} over the final static game screen. Thus, you need to draw all the game objects and messages (but without moving the snake) plus you show a text message that is on for 0.5 second and off for 0.5 seconds until the player presses \emph{Space} button. Hint, it should be a separate loop after the main game loop over rounds and clock/timers have definitely something to do with it.

Put your updated code into \emph{exercise10.py}.

\hypertarget{next-stop-classes-and-objects}{%
\section{Next stop: classes and objects}\label{next-stop-classes-and-objects}}

Nice game! Next time you will learn about classes and objects and you will rewrite the Snake Game using them. This way, we can concentrate on figuring out classes, as you already know how the game works.

\hypertarget{seminar-02-03}{%
\chapter{Snake game: object-oriented programming}\label{seminar-02-03}}

We will not be programming a new game today. Rather, you will learn about object-oriented approach in Python and will use it to simplify your code of the Snake game that you already programmed. Yes, it would be more fun to program a new game but this way you get to concentrate on the concepts rather than on the game logic.

\hypertarget{object-oriented-programming}{%
\section{Object-oriented programming}\label{object-oriented-programming}}

The core idea is in the name: Instead of having variables/data and functions separately, you combine them in an object that has attrbutes/properties (its own variables) and methods (functions). This approach uses our natural tendency to perceive the world as a collection of interacting objects and has several advantages that I will discuss below.

\hypertarget{classes-and-objects-instances-of-classes}{%
\subsection{Classes and objects (instances of classes)}\label{classes-and-objects-instances-of-classes}}

Before we continue, I need to make an important distinction between \emph{classes} and \emph{objects}. A \emph{class} is a ``blue print'' that describes properties and behavior (methods) of objects of that class. This ``blue print'' is used to create an \emph{instance} of that class, which is called an \emph{object}. For example, Homo sapiens is a \emph{class} that describes species that have certain properties, such as height, and can do certain things, such as running. However, Homo sapiens as a class only has a concept of height but no specific height itself. E.g., you cannot ask ``What is height of Homo sapiens?'' only what is an average (mean, median, etc.) height of individuals of that class. Similarly, you cannot say ``Run, Homo sapiens! Run!'' as abstract concepts have trouble with real actions like that. Instead, it is Alexander Pastukhov who is an \emph{instance} of Homo sapiens class with a specific height and a specific (not particularly good) ability to run. Other instances of Homo sapiens (other people) will have different height and a different (typically better) ability to run. Thus, class describes what kind of properties and methods objects have. This means that whenever you meet a Homo sapien, you could be sure that they have height. However, individual objects have different values for this properties and so calling their methods may result in different outcomes.

Another, a more applied, example would be your use of \texttt{ImageStim} \emph{class} to create multiple \emph{instances} of front side of a card in ``Memory'' game. Again, the \emph{class} defines properties (\texttt{image}, \texttt{pos}, \texttt{size}, etc.) and methods (e.g., method \texttt{draw()}) that individual \emph{objects} will have. You created these objects to serve as front side of cards. You set \emph{different} values for same properties (\texttt{image}, \texttt{pos}) and that ensured that when you call their method \texttt{draw()}, each card was drawn at its own location and with it own image.

\hypertarget{encapsulation}{%
\subsection{Encapsulation}\label{encapsulation}}

Putting all the data (properties) and behavior (methods) inside the class simplifies programming by ensuring that all relevant information can be found in its definition. Thus, you have a single place that should hold \emph{everything} that defines object's behavior. Contrast this with our approach in previous two seminars where snake data (e.g., variable \texttt{snake}) was defined at one place and functions that used and altered it (e.g., \texttt{snake\_bit\_itself()} or \texttt{grow\_snake()}) were defined elsewhere. Moreover, we had to resort to using \emph{snake} or \emph{apple} in function names just to remind ourselves that they belong to the snake or an apple. This also necessitated creating functions with multiple arguments that ensured that all information is available within each function. And, we modified \texttt{snake} inside the function creating further uncertainty about when and where it can be changed. Today, you will see how encapsulating everything into classes turns this mess into a simpler and easier-to-understand code.

\hypertarget{inheritance-generalization}{%
\section{Inheritance / Generalization}\label{inheritance-generalization}}

In object-oriented programming, a class can be derived from some other \emph{ancestor} class and thus \emph{inherit} its properties and methods. Moreover, several classes can be derived from a single ancestor producing a mix of unique and shared functionality. This means that instead of rewriting the same code for each class, you can define a common code in an ancestor class and focus on differences or additional methods and properties in descendants.

Using the Homo sapiens example from above. Humans, chimpanzees and gorillas are all different species but we share a common ancestor. Hence, we are different in many respect, yet, you could think about all of us as ``apes'' that have common properties such as binocular trichromatic vision. On other words, if you are interested in color vision, you do not care what specific species you are looking it, as all apes are the same in that respect. Or, you can move further down the evolution tree and think about us as ``mammals'' that, again, have common properties and behavior, such as thermoregulation and lactation. Again, if you are interested \emph{only} in whether an animal has thermoregulation, knowing that it is a mammal is enough.

Similarly, in PsychoPy various visual stimuli that we used (\texttt{ImageStim}, \texttt{TextStim}, \texttt{Rect}) have same properties (e.g., \texttt{pos}, \texttt{size}, etc.) and methods (most notably, \texttt{draw()}). This is because they are all descendants from a common ancestor \texttt{BaseVisualStim} that defines their common properties and methods\footnote{\texttt{BaseVisualStim} does not actually define \texttt{draw()} method, only that it must be present.}. This means that you can assume that \emph{any} visual stimulus (as long as it descends from \texttt{BaseVisualStim}) will have \texttt{size}, \texttt{pos}, \texttt{ori} and can be drawn. This, in turn, means that you can have a list of various PsychoPy visual stimuli and move or draw all of them in a single loop without thinking which \emph{specific} visual stimulus you are moving or drawing. Also note that you cannot assume these same proporties of \emph{sound} stimuli because they are \emph{not} descendants of \texttt{BaseVisualStim} but of \texttt{\_SoundBase} class.

Where is another way of achieving common behavior (generalization) in Python without inheritance. It is called ``duck typing''\footnote{Yes, it is really called ``duck typing''.} and it will be the topic of a different seminar.

\hypertarget{polymorphism}{%
\section{Polymorphism}\label{polymorphism}}

As you've learned in the previous section, inheritance allows different descendants to share common properties and behavior, so that in certain cases you can view them as being equivalent to an ancestor. E.g., any visual stimulus (a descendant of \texttt{BaseVisualStim} class) can be drawn, so you just call its \texttt{draw()} method. However, it is clear that these different stimuli implement drawing \emph{differently}, as the \texttt{Rect} stimulus looks different from the \texttt{ImageStim} or \texttt{TextStim}. This is called ``polymorphism'' and the idea is to keep the common interface (same \texttt{draw()} call) while abstracting away the actual implementation. This allows you to think about what you want an object to do (or what to do with an object), instead of thinking how exactly it is implemented.

\hypertarget{a-minimal-class-example}{%
\section{A minimal class example}\label{a-minimal-class-example}}

Enough of the theory, let us see how classes are implemented in Python. Here is a very simple class that has nothing but the \emph{constructor} \texttt{\_\_init\_\_()} method, which is called whenever a new object (class instance) is created, and a single attribute / property \texttt{total}.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{class}\NormalTok{ Accumulator:}
    \CommentTok{"""}
\CommentTok{    Simple class that accumulates (sums up) values.}

\CommentTok{    Properties}
\CommentTok{    {-}{-}{-}{-}{-}{-}{-}{-}{-}{-}}
\CommentTok{    total : float}
\CommentTok{        Total accumulated value}
\CommentTok{    """}

    \KeywordTok{def} \FunctionTok{\_\_init\_\_}\NormalTok{(}\VariableTok{self}\NormalTok{):}
        \CommentTok{"""}
\CommentTok{        Constructor, initializes the total value to zero.}
\CommentTok{        """}
        \VariableTok{self}\NormalTok{.total }\OperatorTok{=} \DecValTok{0}
        
\CommentTok{\# here we create an object number\_sum, which is an instance of class Accumulator.}
\NormalTok{number\_sum }\OperatorTok{=}\NormalTok{ Accumulator()}
\end{Highlighting}
\end{Shaded}

Let's go through it line by line. First line \texttt{class\ Accumulator:} shows that this is a declaration of a \texttt{class} whose name is \texttt{Accumulator}. Note that the first letter is capitalized. This is not required per se, so Python police won't be knocking on your door if you write it all in lower or upper case. However, the general recommendation is that \textbf{class} names are written using \texttt{UpperCaseCamelCase} whereas \textbf{object} (instances of the class) names are written using \texttt{lower\_case\_snake\_case}. This makes distinguishing between classes and objects easier, so you should follow this convention.

The definition of the class are the remaining \emph{indented} lines. As with functions or loops, it is the indentation that defines what is inside and what is outside of the class. The only method we defined is \texttt{def\ \_\_init\_\_(self):}. This is a \emph{special} method\footnote{There are more special methods that you will learn about later, they all follow \texttt{\_\_methodname\_\_()} convention.} that is called when an object (instance of the class) is created. This allows you to initialize the object based on parameters that were passed to this function (if any). You do not call this function directly, rather it is called whenever an object is created, \emph{e.g.} \texttt{number\_sum\ =\ Accumulator()} (last line). Also, it does not return any value explicitly via \texttt{return}. Instead, \texttt{self} (the very first parameter, more on it below) is returned automatically.

All class methods (apart from special cases we currently do not concern ourselves with) must have one special first parameter that is \emph{the object} itself. By convention it is called \texttt{self}\footnote{Again, you can use any name but that will surely confuse everyone.}. It is passed to the method automatically, so whenever you write \texttt{square.draw()} (no explicit parameters written in the function call), the actual method still receives one parameter that is the \emph{reference} to the \texttt{square} variable whose method you called. Inside a method, you use this variable to refer to the object itself.

Let us go back to the constructor \texttt{\_\_init()\_\_} to see how you can use \texttt{self}. Here, we add a new \emph{persistent} attribute/property to the object and assign a value to it: \texttt{self.total\ =\ 0}. It is \emph{persistent}, because even though we created it inside the method, the mutable object is passed by reference and, therefore, we assigned it to the object itself. Now you can use this property either from inside \texttt{self.total} or from outside \texttt{number\_sum.total}. You can think of properties as being similar to field/value pairs in the dictionary we used during previous seminar but for syntax: \texttt{object.property} versus \texttt{dictonary{[}"field"{]}}\footnote{This is actually how all properties and methods are stored, in a \texttt{\_\_dict\_\_} attribute, so you can write \texttt{number\_sum.\_\_dict\_\_{[}"total"{]}} to get it.}. Technically, you can create new properties in any method or even from outside (e.g., nothing prevents you from writing \texttt{number\_sum.color\ =\ "red"}). However, this makes understanding the code much harder, so the general recommendation is to create \emph{all} properties inside the constructor \texttt{\_\_init\_\_()} method, even if this means assigning \texttt{None} to them\footnote{If you use a linter, it will complain whenever it sees a property not defined in the constructor}.

\hypertarget{add-method}{%
\section{\texorpdfstring{\texttt{add} method}{add method}}\label{add-method}}

Let us add a method that adds 1 to the \texttt{total} property.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{class}\NormalTok{ Accumulator:}
\NormalTok{    ... }\CommentTok{\# I am skipping all previous code here}
    
    \KeywordTok{def}\NormalTok{ add(}\VariableTok{self}\NormalTok{):}
        \CommentTok{"""}
\CommentTok{        Add 1 to total}
\CommentTok{        """}
        \VariableTok{self}\NormalTok{.total }\OperatorTok{+=} \DecValTok{1}
\end{Highlighting}
\end{Shaded}

It has first special argument \texttt{self} that is the object itself and we simply add 1 to its \texttt{total} property. Again, remember that \texttt{self} is passed automatically whenever you call the method, meaning that an actual call looks like \texttt{number\_sum.add()}.

Create a Jupyter notebook (you will need to submit it as part of the assignment) and copy-paste the code for \texttt{Accumulator} class, including the \texttt{.add()} method. Create \textbf{two} objects, call them \texttt{counter1} and \texttt{counter2}. Call \texttt{.add()} method twice for \texttt{counter2} and thrice for \texttt{counter1} (bonus: do it using \texttt{for} loop). What is the value of the \texttt{.total} property of each object? Check it by printing it out.

Copy-paste and test \texttt{Accumulator} class code in a Jupiter notebook.

\hypertarget{flexible-accumulator-with-a-subtract-method}{%
\section{\texorpdfstring{Flexible accumulator with a \texttt{subtract} method}{Flexible accumulator with a subtract method}}\label{flexible-accumulator-with-a-subtract-method}}

Now lets us create a new class that is a \emph{descendant} of the \texttt{Accumulator}. We will call it \texttt{FlexibleAccumulator} as it will allow you to also \emph{subtract} from the total count. You specify ancestors (could be more than one!) in round brackets after the class name

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{class}\NormalTok{ FlexibleAccumulator(Accumulator):}
    \ControlFlowTok{pass} \CommentTok{\# You must have at least one non{-}empty line, and pass means "do nothing"}
\end{Highlighting}
\end{Shaded}

Now you have a new class that is a descendant of \texttt{Accumulator} but, so far, is a perfect copy of it. Add \texttt{subtract} method to the class. It should subtract \texttt{1} from the \texttt{.total} property (don't forget to \emph{document} it!). Check that it works. Create one instance of \texttt{Accumulator} and another one of \texttt{FlexibleAccumulator} class and check that you can call \texttt{add()} on both of them but \texttt{subtract()} only for the latter.

Add \texttt{subtract} method to the \texttt{FlexibleAccumulator} class in a Jupiter notebook. Add testing.

\hypertarget{method-arguments}{%
\section{Method arguments}\label{method-arguments}}

Now, create a new class \texttt{SuperFlexibleAccumulator} that will be able to both \texttt{add()} and \texttt{subtract()} \emph{arbitrary} value! Think about which class it should inherit from. Redefine both \texttt{.add()} and \texttt{.subtract()} method in that new class by adding \texttt{value} argument to both method and add/subtract this value rather than \texttt{1}. Note that now you have \emph{two} arguments in each method \texttt{(self,\ value)} but when you call you only need to pass the latter (again, \texttt{self} is passed automatically). Don't forget to document \texttt{value} argument (but you do not need to document \texttt{self} as its meaning is fixed).

Create \texttt{SuperFlexibleAccumulator} class and define super flexible \texttt{add} and \texttt{subtract} methods that have \texttt{value} parameter ( in a Jupiter notebook). Test them!

\hypertarget{constructor-arguments}{%
\section{Constructor arguments}\label{constructor-arguments}}

Although constructor \texttt{\_\_init(...)\_\_} is special, it is still a method. Thus, you can pass arguments to it just like you did it for other methods. You pass these arguments when you create an object, so in our case, you put it inside the bracket for \texttt{counter\ =\ SuperFlexibleAccumulator(...)}.

Modify the code so that you pass the initial value that total is set to, instead of zero.
::: \{.infobox .program\}
Add \texttt{initial\_value} parameter to the constructor of the \texttt{SuperFlexibleAccumulator} class in a Jupiter notebook. Test it!
:::

\hypertarget{calling-methods-from-other-methods}{%
\section{Calling methods from other methods}\label{calling-methods-from-other-methods}}

You can call a function or object's method at any point of time, so, logically, you can use methods inside methods. Let's modify our code, realizing that \emph{subtracting} a value is like \emph{adding a negative} value. Modify your code, so that \texttt{.subtract()} only negates the value before passing is to \texttt{.add()} for actual processing. Thus, \texttt{total} is modified \emph{only} inside the \texttt{add()} method.

Modify \texttt{subtract()} method of \texttt{SuperFlexibleAccumulator} to utilize \texttt{add()} in a Jupiter notebook. Test it!

\hypertarget{local-variables}{%
\section{Local variables}\label{local-variables}}

Just like normal functions, you methods can have local variables. They are local (visible and accessible only from within the method) and are not persistent (their values do not survive between the calls). Conceptually, you separate variables that need to be persistent (retain their value the whole time object exists) as attributes/properties and temporary variables that are need only for the computation itself as local method variables. What would be value of property \texttt{.total} in this example:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{class}\NormalTok{ Accumulator:}
    \KeywordTok{def} \FunctionTok{\_\_init\_\_}\NormalTok{(}\VariableTok{self}\NormalTok{, initial):}
\NormalTok{        temp }\OperatorTok{=}\NormalTok{ initial }\OperatorTok{*} \DecValTok{2}
        \VariableTok{self}\NormalTok{.total }\OperatorTok{=}\NormalTok{ inital}
        
\NormalTok{counter }\OperatorTok{=}\NormalTok{ Accumulator(}\DecValTok{1}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

What about in this case?

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{class}\NormalTok{ Accumulator:}
    \KeywordTok{def} \FunctionTok{\_\_init\_\_}\NormalTok{(}\VariableTok{self}\NormalTok{, initial):}
\NormalTok{        temp }\OperatorTok{=}\NormalTok{ initial }\OperatorTok{*} \DecValTok{2}
        \VariableTok{self}\NormalTok{.total }\OperatorTok{=}\NormalTok{ temp}
        
\NormalTok{counter }\OperatorTok{=}\NormalTok{ Accumulator(}\DecValTok{1}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\hypertarget{refactoring-the-snake-game}{%
\section{Refactoring the Snake game}\label{refactoring-the-snake-game}}

Got the basic idea about using classes? Let us practice by partially refactoring the snake game. In principle, we can factor it into three classes / objects:

\begin{itemize}
\tightlist
\item
  a window class that will incorporate grid information and mapping
\item
  an apple class
\item
  a snake class
\end{itemize}

Here, we will cover the first two but I encourage you to think about how to convert snake-bits into a class as well. Before you begin, create a new folder (\emph{snake2}, \emph{snake-oop}, etc.) and copy your old code where.

\hypertarget{gridwindow-class}{%
\section{GridWindow class}\label{gridwindow-class}}

One of the most annoying things about our current code was the necessity to pass grid information (\texttt{GRID\_SIZE}, \texttt{SQUARE\_SIZE}, etc.) as well as window variable every time we needed to create a new segment, or an apple, or grow snake, etc. It would be much simpler, if our window object would also include information on the grid (grid and square sizes) as well as the function that maps grid-to-window coordinates (\texttt{map\_grid\_to\_win()}). In this case, we would only need to pass the window variable that has all information that snake or apple function and classes will need.

We still want the window to behave like PsychoPy window, so our \texttt{GridWindow} will \emph{inherit} from it. Create a new file \emph{gridwindow.py} and create a new class as follows. We will discuss the specific bits below.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# 1. import }

\KeywordTok{class}\NormalTok{ GridWindow(Window):}
    \CommentTok{"""}
\CommentTok{    Grid window, inherits from PsychoPy window and adds grid attributes and functions.}
\CommentTok{    """}

    \KeywordTok{def} \FunctionTok{\_\_init\_\_}\NormalTok{(}\VariableTok{self}\NormalTok{, grid\_size, square\_size\_pix):}
        \CommentTok{"""}
\CommentTok{        Parameters}
\CommentTok{        {-}{-}{-}{-}{-}{-}{-}{-}{-}{-}}
\CommentTok{        grid\_size : tuple}
\CommentTok{            Size of the grid}
\CommentTok{        square\_size\_pix : integer}
\CommentTok{            size of a single square in pixels}
\CommentTok{        """}
        
        \CommentTok{\# 2. store grid\_size as an attribute, so that later on you}
        \CommentTok{\#     could use it as self.grid\_size (from inside) and }
        \CommentTok{\#     win.grid\_size (from outside)}
        
        \CommentTok{\# 3. compute square\_size attribute}
        
        \CommentTok{\# 4. call the constructor of the ancestor}
        \BuiltInTok{super}\NormalTok{().}\FunctionTok{\_\_init\_\_}\NormalTok{(units}\OperatorTok{=}\StringTok{"norm"}\NormalTok{, size}\OperatorTok{=}\NormalTok{(however}\OperatorTok{{-}}\NormalTok{you}\OperatorTok{{-}}\NormalTok{computed}\OperatorTok{{-}}\NormalTok{it))}
        
    \KeywordTok{def}\NormalTok{ map\_grid\_to\_win(}\VariableTok{self}\NormalTok{, ipos):}
        \CommentTok{"""}
\CommentTok{        Converts grid coordinates to window coordinates in height units.}

\CommentTok{        Parameters}
\CommentTok{        {-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}}
\CommentTok{        ipos : tuple}
\CommentTok{            (x, y) coordiantes on the grid}

\CommentTok{        Returns}
\CommentTok{        {-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}}
\CommentTok{        tuple}
\CommentTok{            (norm\_x, norm\_y) coordinates in the window}
\CommentTok{        """}
        
        \CommentTok{\# 5. code that computed the transformation but that uses}
        \CommentTok{\#    class attribute for square size}
        
\end{Highlighting}
\end{Shaded}

Let us go through the code!

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  You do need to import some modules, which ones?
\item
  We pass the \texttt{grid\_size} as a parameter to the constructor but we need to retain in for future computation. Hence, we should store it as a persistent attributed of the class. You can (should) use the same name but remember this is an attribute not a constant, so you should use \texttt{snake\_lower\_case} for the name.
\item
  In the original code, you store the computed square size as a constant. Here, you store it as a persistent attribute but, otherwise, the idea is the same.
\item
  New and somewhat complicated bit! In the original code, we created a window and specified its size in pixels (computing it from the grid size and size of the square in pixels) and \texttt{"norm"} units. We still need to do this, so that the window is initialized properly. In the constructor we wrote the code that takes care of \emph{new} bits but we need to ensure that the ancestor class does the \emph{old} bits. For this, we need to call its constructor (\texttt{\_\_init\_\_()} method). But there is a catch, we \emph{overwrote} it with a brand new \texttt{\_\_init\_\_()} method of our own, so we cannot just call it via \texttt{self.\_\_init\_\_()}\footnote{Well, we can write that but we will be calling out brand new \texttt{\_\_init\_\_()} again.}. Instead, Python has \texttt{super()} function that refers to the ancestor of the class. Hence, \texttt{super().\_\_init\_\_(your-arguments-inside)} initializes the window. Note that you need \texttt{super()} only if you \emph{override} the original method, as we did with \texttt{\_\_init\_\_()}. E.g., you do not need it to call \texttt{flip()} method defined in the original class.
\item
  The code is essentially the same but you can use square size attribute, so no need to pass it as a separate argument.
\end{enumerate}

And in the main code, you now create the window as

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{win }\OperatorTok{=}\NormalTok{ GridWindow(GRID\_SIZE, SQUARE\_SIZE\_PIX)}
\end{Highlighting}
\end{Shaded}

\hypertarget{apple-class}{%
\section{Apple class}\label{apple-class}}

Create it in a separate \emph{apples.py} file. The apple class has no ancestors and we just need to put all methods and variables together. Here are lists of attributes and methods.

Attributes:

\begin{itemize}
\tightlist
\item
  \texttt{win} : you should pass window variable to the constructor of an \texttt{Apple} class and store it as an attribute for later use when you (re)create the apple at random position.
\item
  \texttt{pos} : same as the field in the original dictionary but now as an attribute.
\item
  \texttt{visuals} : same as the field in the original dictionary but now as an attribute.
\end{itemize}

Methods:

\begin{itemize}
\tightlist
\item
  \texttt{\_\_init\_\_(self,\ win)} should store window as attribute and create \emph{empty} attributes \texttt{pos} and \texttt{visuals}.
\item
  \texttt{reset(self,\ snake)} : modified version of \texttt{create\_apple()} function but you use grid size and square size attributes of the \texttt{self.win} instead of passing them as arguments. It should overwrite any old values of \texttt{self.pos} and \texttt{self.visuals} instead of returning the dictionary.
\item
  \texttt{draw()} : should draw the apple!
\end{itemize}

Now, you need to create an \texttt{apple} object \emph{after} you create the window and \texttt{reset()} it whenever you need a new apple (at the beginning of each round and once the snake ate the apple).

\hypertarget{refactoring-the-code}{%
\section{Refactoring the code}\label{refactoring-the-code}}

Start by changing with window class to \texttt{GridWindow} without doing anything else. The code should ``just work'' as our \texttt{GridWindow} has all the functionality of PsychoPy \texttt{Window} that we relied upon. Next, go through the \emph{snake} code (the apple has its own class, so we will deal with it later) to use window attributes instead of constants and simplify functions. E.g., \texttt{create\_snake\_segment(win,\ ipos,\ square\_size)} does not need the third argument anymore, as you can get it from \texttt{win} itself. Similarly, you do not need it for \texttt{grow\_snake()} function. Alter one function at a time and test your code.

Next, use \texttt{Apple} class for the apple and adjust the code accordingly using attributes and \texttt{draw()} method. Here, you have to do all alterations in one go, of course, as changes we introduced are breaking.

Remember, one step at a time, check your code before continuing. Put breakpoints and use debug console, if you are unsure about the changes.

\hypertarget{seminar-02-04}{%
\chapter{Moon lander game}\label{seminar-02-04}}

Today we will create a moon lander game. You job is simple: land your ship on the pad but do not crash it! Here is a brief video of my implementation of the game

We will program it using object-oriented approach from the beginning by defining two classes: the \texttt{MoonLander} and the \texttt{LandingPad}. Here is the general outline of how we will proceed:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Create a basic PsychoPy window and main experimental loop.
\item
  Define a basic \texttt{MoonLander} class with a static image and add its drawing to the main loop.
\item
  Randomize position of the lander.
\item
  Add gravity pull.
\item
  Add vertical thruster that counter-act gravity.
\item
  Add horizontal thrusters, so you can maneuver around.
\item
  Define \texttt{LandingPad} class.
\item
  Learn about virtual attributes and implement them for both classes.
\item
  Implement landing / crashing checks.
\item
  Add more runs.
\item
  Limit the fuel.
\end{enumerate}

This time most of the code will be in classes, so making versions of them will be quite cumbersome. Thus, submit only the final game. I would suggest calling files \emph{main.py} (main script), \emph{moonlander.py} (\texttt{MoonLander} class), and \emph{landingpad.py} (\texttt{LandingPad} class).

\hypertarget{create-window}{%
\section{Create window}\label{create-window}}

Create our usual boilerplate code in \emph{exercise01.py} (you will use the same files for classes but use versioning of the main file, it makes it easier for me to check your code). Create a PsychoPy window 640 × 480 in size. Add a main game loop with \texttt{gameover} variable that can be exited by pressing \emph{escape}.

Put your code into \emph{exercise01.py}.

\hypertarget{create-moonlander-class}{%
\section{Create MoonLander class}\label{create-moonlander-class}}

In \emph{moonlander.py}, create a new \texttt{MoonLander} class. It should have an \texttt{ImageStim} attribute (that will be the visuals of the ship) created using \href{material/ufo.png}{ufo.png} image. For the moment, place it at its default location at the center. Also, implement \texttt{draw()} method that should draw all visual elements of the lander (we have one now but there will be more later on).

Create an instance of \texttt{MoonLander} class in the main script and draw it in the main game loop. You should see a static picture of the ship at the center of the screen.

Put updated code into \emph{exercise02.py}. Create \texttt{MoonLander} class and use it in the main game loop.

\hypertarget{randomize-position}{%
\section{Randomize position}\label{randomize-position}}

Implement a new method \texttt{reset()} that resets the lander for the next round. At the moment, the only thing it should do is to randomize position of the image. Use range of -0.5..0.5 horizontally and 0.8..0.9 vertically. Call it in the constructor and test it in the main loop by calling it every time you press \emph{space} button.

Put updated code into \emph{exercise03.py}. Add \texttt{reset()} method to \texttt{MoonLander} class and use it in the main game loop.

\hypertarget{gravity}{%
\section{Gravity}\label{gravity}}

Next we need to create a gravitational force that will pull the lander down. Create a constant \texttt{GRAVITY\ =\ 0.0001}\footnote{The constant itself does not mean anything, I adjusted it to be reasonable for the image and window size that we are using.} and create a new attribute \texttt{speed\ =\ {[}0,\ 0{]}} that is horizontal and vertical speed of the lander. Note that it should be reset to \texttt{(0,\ 0)} in the \texttt{reset()} method.

The position of the lander (\texttt{self.image.pos}) must adjusted based on the the speed on every frame. But before that, speed itself must be adjusted based on the forces from gravity and thrusters that act upon the lander. Create a new method \texttt{update()} where you first adjust \emph{vertical} speed based on gravity alone (we will add the effect of thrusters later) and when adjust \emph{vertical} position based on vertical speed (we will worry about the horizontal speed, once we start working on horizontal thrusters). Call \texttt{update()} method before the \texttt{draw()} in the main loop. Your lander should fall down at accelerated rate (you can play with \texttt{GRAVITY} constant to see how it changes the speed of falling). Once it is off the screen, press space and see it go again.

Put updated code into \emph{exercise04.py}. Update \texttt{MoonLander} class for the effect of gravity and use this in the main loop.

\hypertarget{vertical-thurster}{%
\section{Vertical thurster}\label{vertical-thurster}}

PsychoPy allows you to get key presses or, using \href{https://www.psychopy.org/api/hardware/keyboard.html}{hardware.keyboard} to get both press and release time. Unfortunately, you get both only \emph{after} the key was released. But in our game, the thursters must be active for as long as the player presses the key. Thus, we need to know whether a key is \emph{currently} pressed, not that it was pressed and released at some time in the past. For this, we will use \emph{pyglet} library (that is a backend used by PsychoPy) directly. First, in your \emph{moonlander.py} add \texttt{import\ pyglet} and then include the following code inside the constructor of the class.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# setting up keyboard monitoring}
\VariableTok{self}\NormalTok{.key }\OperatorTok{=}\NormalTok{ pyglet.window.key}
\VariableTok{self}\NormalTok{.keyboard }\OperatorTok{=} \VariableTok{self}\NormalTok{.key.KeyStateHandler()}
\NormalTok{win.winHandle.push\_handlers(}\VariableTok{self}\NormalTok{.keyboard)}
\end{Highlighting}
\end{Shaded}

This installs a ``handler'' that monitors the state of the keyboard. Now, you can read out the state of, say, \emph{down arrow} key as\texttt{self.keyboard{[}self.key.DOWN{]}} (\texttt{True} if pressed, \texttt{False} otherwise). We will use \texttt{DOWN} for the vertical thruster and \texttt{LEFT} and \texttt{RIGHT} for the horizontal ones.

Define a \texttt{VERTICAL\_ACC} to be twice the gravity (but you can use some other number, of course) and update the \texttt{update()}\footnote{Pun intended.}, so that the total vertical acceleration is \texttt{VERTICAL\_ACC\ +\ GRAVITY} if the the user is pressing \emph{down} key (use \texttt{self.keyboard} and \texttt{self.key} to figure that out) but \texttt{GRAVITY} alone, if not.

Test you that vertical thruster works!

Put updated code into \emph{exercise05.py}. Update \texttt{MoonLander} class for the counter-effect of a vertical thruster.

\hypertarget{horizontal-thursters}{%
\section{Horizontal thursters}\label{horizontal-thursters}}

Now implement the same logic, computing acceleration, speed, and position but for horizontal thrusters (define \texttt{HORIZONTAL\_ACC}, decide on its value yourself). Remember, the \emph{right} thruster pushes the lander to the \emph{left} and vice versa! Assume that only one of the keys, \emph{left} or \emph{right}, can be pressed at a time. Test it by flying around!

Put updated code into \emph{exercise06.py}. Add horizontal thrusters to \texttt{MoonLander}.

\hypertarget{landing-pad-visuals}{%
\section{Landing pad: visuals}\label{landing-pad-visuals}}

The purpose of the game is to land on a landing pad. A landing pad is just a rectangle with some additional methods and properties. So it stands to reason to make it a descendant of the \texttt{visual.Rect} class. This way, the original class will do all the heavy lifting and provide properties like \texttt{size} and \texttt{pos} and we can concentrate on the added value. Unfortunately, for some technical reason I have not figured out yet, this does not work for shape classes like \texttt{Rect} or \texttt{Circle}. It \emph{does} work for classes like \texttt{ImageStim} and we will use this opportunity when we program out next game.

Create a new file \emph{landing\_pad.py} and a new class \texttt{LandingPad}. In the constructor, create a rectangle and store it in attribute (you pick the name). It should be \texttt{0.5} units wide and located at the bottom of the window but at a random position within the window horizontally. Pick the fill and line colors that you like. The only other method the class needs is \texttt{draw()}.

In the main code, create an object of class \texttt{LandingPad} and draw it in the main loop, along with the lander itself.

Put updated code into \emph{exercise07.py}. Create \texttt{LandingPad} class and use it in the main loop.

\hypertarget{computing-edges-of-game-objects}{%
\section{Computing edges of game objects}\label{computing-edges-of-game-objects}}

The aim of the game is a soft touchdown on a landing pad. For this, we need to know where the \emph{top} of the landing pad is, as well as where the \emph{bottom} of the lander is and where \emph{left} and \emph{right} limits of each object are. Let us think about \emph{bottom} of the lander first, as the rest are very similar.

We do not have information about it \emph{directly}. We have the vertical position of the lander in \texttt{self.image.pos{[}1{]}} (I assume here that the visuals attribute is called image) and its height in \texttt{self.image.size{[}1{]}}. From this, it is easy to compute the bottom edge (but remember that position is about the \emph{center} of the rectangle). Accordingly, you could create a method called \texttt{bottom()} that would return the computed value when it is called (e.g., \texttt{lander.bottom()}).

Implement \texttt{bottom()} method for the \texttt{MoonLander} class.

\hypertarget{getter-setter}{%
\section{Virtual attributes via getters and setters}\label{getter-setter}}

Our approach of using \texttt{lander.bottom()} works but it is \emph{semantically} inconsistent. Calling methods is about manipulating objects, e.g., drawing them, updating them, comparing them. However, \texttt{bottom} is, effectively, an \emph{attribute} of an object, like its position or size. We \emph{could} create and compute a \texttt{bottom} attribute inside the constructor, solving the problem of semantics, as now you could write \texttt{lander.bottom}. Note that as the lander moves all of its edge attributes (\texttt{bottom}, \texttt{left} and \texttt{right}) need to be recomputed after every update. This is unavoidable but a \emph{real} attribute approach still creates another problem: What if someone \emph{changes} it? In that case, its value will not be correct, as \texttt{bottom} value depends on both position and size, so changing it without a corresponding change in those two attributes makes no sense! And it is really hard to decide whether change in the \texttt{bottom} should mean a change in position, or size, or, perhaps, both? Thus, ideally, it should be a read-only attribute.

For cases like these, Python has special \emph{decorators}\footnote{These are functions that ``decorate'' you function and are called \emph{before} your function is called. They are like gatekeepers or face control, so they can alter whether or how your function is executed. They are very useful in certain scenarios and we will meet them again later. However, we will not talk about them in detail here.}: \texttt{@property} and \texttt{@\textless{}name\textgreater{}.setter}. The former one decorates a method that allows you to \emph{get} an attribute's value and, typically, is called a ``getter''. The latter one, is for a ``setter'' method that \emph{sets} a new value to an attribute. The idea is to isolate an actual attribute value from the outside influence. It is particularly helpful, if you need to control whether a new value of an attribute is a valid one, needs to converted, etc. For example, \texttt{color} attribute of the rectangle stimulus uses this approach, which is why it can take RGB triplets, hexadecimal codes, or plain color names as a value and set the color correctly.

Here is a sketch of how it could work but note that today, we will only use the \emph{getter} bit. To have a virtual attribute for \texttt{color}, one typically creates an \emph{internal} attribute with almost the same name, e.g., \texttt{\_color} or \texttt{\_\_color} (see below for the difference). The value is stored and read from that internal attribute by getter and setter methods:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{class}\NormalTok{ ExampleClass:}

  \KeywordTok{def} \FunctionTok{\_\_init\_\_}\NormalTok{(}\VariableTok{self}\NormalTok{):}
    \VariableTok{self}\NormalTok{.\_\_color }\OperatorTok{=} \StringTok{"red"}

  \AttributeTok{@property}
  \KeywordTok{def}\NormalTok{ color(}\VariableTok{self}\NormalTok{):}
    \CommentTok{"""}
\CommentTok{    This is a getter method for virtual color}
\CommentTok{    attribute.}
\CommentTok{    """}
    \CommentTok{\# Here, we simply return the value. But we could }
    \CommentTok{\# compute it from some other attribute(s) instead.}
    \ControlFlowTok{return} \VariableTok{self}\NormalTok{.\_\_color}
    
  \AttributeTok{@color.setter} \CommentTok{\# not the most elegant syntax, IMHO}
  \KeywordTok{def}\NormalTok{ color(}\VariableTok{self}\NormalTok{, newvalue):}
    \CommentTok{"""}
\CommentTok{    Note that the setter name has THE SAME name as the getter!}
\CommentTok{    It sets a new value and does not return anything.}
\CommentTok{    """}
  
    \CommentTok{\# Here, you can have checks, conversion, }
    \CommentTok{\# additional changes to other attributes, etc.}
    \VariableTok{self}\NormalTok{.\_\_color }\OperatorTok{=}\NormalTok{ newvalue}
    
    
\NormalTok{example }\OperatorTok{=}\NormalTok{ ExampleClass()}

\CommentTok{\# get the value, note the lack of () after color}
\BuiltInTok{print}\NormalTok{(example.color)}

\CommentTok{\# set the value}
\NormalTok{example.color }\OperatorTok{=} \StringTok{"blue"}
\end{Highlighting}
\end{Shaded}

Note that there is no \emph{actual} attribute \texttt{color}\footnote{Just like there is no physical phenomenon called ``color''.}, yet, our code works as if it does exist.

There is another twist to the story. If you only define the getter \texttt{@property} method but no setter method, your property is read-only\footnote{Note that you cannot have write-only property, you must have either getter alone or both.}! And this exactly what we wanted. Turning our \texttt{bottom()} method into a getter of an attribute is as easy as adding the \texttt{@property} decorator above it. After that, we can use it as a read-only attribute \texttt{lander.bottom}. Do this and also create similar read-only attributes for \texttt{top}, \texttt{left}, and \texttt{right} of the pad and for \texttt{left}, and \texttt{right} of the lander class.

Implement virtual properties for \texttt{MoonLander} and \texttt{LandingPad} classes.

\hypertarget{access-restrictions}{%
\section{Access restrictions}\label{access-restrictions}}

In the example on getter/setter methods, I used \texttt{\_\_color} name with \emph{two} leading underscores. This is a Python way to make things (almost) private, that is, invisible from outside. If you copy-paste the class code from above and try to access the attribute directly via \texttt{example.\_\_color}, you will get an error "`ExampleClass' object has no attribute '\_\_color'". However, as I wrote, it is \emph{almost} private, so you still can access it! The code format is \texttt{object.\_\textless{}ClassName\textgreater{}\textless{}hidden\ attribute\ name\textgreater{}}, so in our case \texttt{example.\_ExampleClass\_\_color}\footnote{Try it and see that it works.}. However, this is a last resort sort of thing that you should use only if you absolutely must access that attribute or method and, hopefully, know what you doing.

You can also come across attributes with a \emph{single} leading underscore in the name, e.g.~\texttt{\_color}. These are not private and are fully visible. However, the leading underscore \emph{hints} that this attribute or method should be \emph{considered} private. So, if you see an attribute like \texttt{\_color}, you should pretend that you know not of its existence and, therefore, you never read or modify it directly. Of course, this is only an \emph{agreement}, so you can always ignore it and work with that attribute directly\footnote{On a side note of doing crazy things that you shouldn't: You can replace a class method without inheritance with your own at run time, this is called ``monkey patching''!}. However, this almost certainly will break the code in unexpected and hard-to-trace ways.

\hypertarget{landing}{%
\section{Landing}\label{landing}}

We should check for landing whenever the bottom edge of the lander is at or below the top edge of the landing pad. A successful landing must satisfy several conditions:

\begin{itemize}
\tightlist
\item
  The lander must be within the limits of the lander pad horizontally.
\item
  The vertical speed must be zero or negative (otherwise, the lander flies up) but below a certain threshold that we will define as a constant \texttt{VERTICAL\_SPEED\_THRESHOLD\ =\ 0.05}.
\item
  The absolute horizontal speed must be below a certain threshold, also defined as a constant \texttt{HORIZONTAL\_SPEED\_THRESHOLD\ =\ 0.05}.
\end{itemize}

If \emph{any} of these three conditions are false, the lander has crashed. Either way, the game is over, so you should record the outcome (whether the landing was successful) and set \texttt{gameover} to \texttt{False}. After the loop, inform the player about the outcome. Draw all game objects plus the message about the outcome (e.g., ``You did it!'' / ``Oh, no!'' or something else) and wait for a space key press.

The condition above will be quite long, so fitting it into a single line will make it hard to read. In Python, you can split the line by putting \texttt{\textbackslash{}} at the end of it. So here, a multiline if statement will look as follows:

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{if}\NormalTok{ lander\_is\_within\_horizontal\_limits }\KeywordTok{and} \OperatorTok{\textbackslash{}}
\NormalTok{   lander\_vertical\_speed\_is\_good }\KeywordTok{and} \OperatorTok{\textbackslash{}}
\NormalTok{   lander\_horizontal\_speed\_is\_good:}
\NormalTok{   ...}
\ControlFlowTok{else}\NormalTok{:}
\NormalTok{  ...}
\end{Highlighting}
\end{Shaded}

Put updated code into \emph{exercise08.py}. Implement landing checks.

\hypertarget{more-rounds-1}{%
\section{More rounds}\label{more-rounds-1}}

Extend the game to have more than one round after the player either landed or crashed. Remember to reset the position of the lander before each new round. You can also add a \texttt{reset()} method to the landing pad as well, randomizing it horizontal position. Importantly, \emph{escape} key should quit the game, not just the round, and there should be no ``success''/``failure'' message in that case. Think how you would implement this.

Put updated code into \emph{exercise09.py}. Add more rounds. Add \texttt{reset()} method to the \texttt{LandingPad} class.

\hypertarget{limited-fuel}{%
\section{Limited fuel}\label{limited-fuel}}

Let us add a fuel limit to make things more interesting, so that thrursters would work \emph{only} if there is any fuel left. For this, define a new constant \texttt{FULL\_TANK} (I've picked it to be \texttt{100} but you can have more) and add a new attribute \texttt{fuel} to the \texttt{Lander} class (remember that you need to explicitly define all attributes in the constructor). The \texttt{fuel} level should be set to \texttt{FULL\_TANK} whenever you reset the lander.

Every use of a thruster should reduce this by 1 and thrusters should work \emph{only} if there is fuel. You need to take care of this in the \texttt{update} method. Think about how you would do it for both vertical and horizontal thrusters.

We also need to tell the player how much the fuel is left. I've implemented it as a bar gauge but you can implement it as text stimulus as well. Create the appropriate visual attribute in the constructor and remember to update it every time the level of the fuel changes and to draw it whenever you draw the lander itself. As a nice touch, you can change the color to indicate how much of the fuel is left. I've used \emph{green} for more than 2/3, \emph{yellow} for more than 1/3, and \emph{red} if less than that.

Put updated code into \emph{exercise10.py}. Add fuel and fuel gauge to \texttt{Lander} class.

\hypertarget{add-to-it}{%
\section{Add to it!}\label{add-to-it}}

We already have a functioning game but you can add so much more to it: visuals for the thrusters, sounds, background, etc. Experiment at will!

\hypertarget{seminar-02-05}{%
\chapter{Space invaders: mixins and duck typing}\label{seminar-02-05}}

Today we will program a classic Space Invaders game with a twist. We will be using object-oriented programming but you will learn about \emph{mixins} and \emph{duck typing}. Previously, you have learned how to ensure generalization --- common behavior for different classes --- via inheritance. E.g., when all visual stimuli inherit from the save \texttt{BaseVisualStim} class, you can be sure that they all have \texttt{size}, \texttt{ori}, and \texttt{pos} properties and that you can \texttt{draw()} them. However, this approach may not be best suited for cases when the same class must behave as different several classes. One solution is to use \emph{multiple inheritance}, so that a class is a descendant of several classes and, thus, get behavior from many of them. This is the canonical way of ensuring generalization but you can achieve same means differently.

\hypertarget{mixins}{%
\section{Mixins}\label{mixins}}

One way to infuse \emph{common} behavior into \emph{different} classes is via a mixin classes. These are classes that only define a single \emph{behavior} and nothing else. No constructor, typically no attributes. Thus, they are too limited to be used on their own but can be inherited from (mixed into the proper class) enabling that single behavior in the descendant.

Think about all creatures that can fly: insects, birds, bats, astronauts, etc. They do have a common ancestor but that common ancestor did not have the ability to fly. Instead, each line evolved that ability independently and all have evolutionary ``cousins'' that cannot fly. When programming, you can follow the same pattern of creating a common ancestor for flying and non-flying insects, then implementing ability to fly in the former. Do the same for birds, bats, astronauts, etc. If your implementation must be very detailed and creature-specific, this might be unavoidable. However, if your ability to ``fly'' is very abstract and, therefore, the same for all creatures in question, you will end up writing the same code for every insect, bird, bar class. An easy copy-paste, of course, but that means you get multiple places with identical implementation, so when you need to change it, you will have to make sure that you do it in all the places (and you gonna miss some, I always do). Alternative? Mixins! You create a class \texttt{FlightAbility} that implements that common abstract ``flying'' and, then, you inherit from that class whenever you need a flying someone. Mix a non-flying bird with the \texttt{FlightAbility} and it can fly! Mix it with an insect: Flying insect! You may also mix in more than one ability. Again, start with a bird that just walks around (chicken?). Add a mixin \texttt{FlightAbility} and you get a flying bird (pigeon?). Take the walking bird again and mix in \texttt{SwimAbility} and you get a swimming bird (penguin?). Mix in \emph{both} and you get a bird that can both fly and swim (swan?)!

You may not need mixins frequently but they are a powerful way of creating an isolated behavior that different classes might need without enforcing strict inheritance structure. PsychoPy is big on mixins. For example, it has \texttt{ColorMixin} that could be mixed-in to a visual class that needs to work with color, so it implements all the repetitive\footnote{boilerplate} code for translating an arbitrary color representation (string, hexadecimal code, RGB triplet, HSL triplet, single grayscale value, etc.) into the internal RGB color value. It also has \texttt{TextureMixin} for classes that use textures for drawing objects. In our \emph{Space Invaders} game, we will use a Mixin class to mix in a ``boom sound when exploded'' behavior, common to both aliens and the player's ship.

\hypertarget{duck-typing}{%
\section{Duck typing}\label{duck-typing}}

Alternatively, you might need your object to behave in a certain way but having a proper class hierarchy is an overkill because this is only one class and you might want some but not all the functionality. The idea is to use ``duck typing'', which comes from saying ``If it walks like a duck, and it quacks like a duck, then it must be a duck.'' In other words, if the only things you care about are walking and quacking, do you need it to be an actual duck\footnote{A man is hailing a taxi on a sidewalk. A car stops next to him. The guy looks at it and says ``But there is the taxi sign on the roof?''. The driver replies: ``Do you need a taxi sign on the roof or a ride?''}? Will a goose that can walk and quack the same way do? Will a \emph{dog} that can walk and quack like a duck do? Obviously, the correct answer is ``it depends'' but in a lot of situations you are interested in a common behavior rather than in a common ancestor.

Duck typing is a popular method in Python. For example, \texttt{len(object)} is a canonical way to compute length of an object. That object could be a string \texttt{len("four")}, or a list \texttt{len({[}1,\ 2,\ 3,\ 4{]})}, a tuple \texttt{len(tuple(1,\ 4,\ 2))}, a dictionary \texttt{len(\{"A":\ 1,\ "B":\ 5\})}, etc. The idea is that as long as a class has a concept of length (number of elements, number of characters, etc.), you should be able compute length via \texttt{len()}. This is achieved by adding a special methodto the class \texttt{\_\_len\_\_(self)} that must return an integer. This is called a ``hook method'', as it is never called directly but is ``hooked'' to the \texttt{len()} function call. Thus, whenever you write \texttt{len(object)}, it is actually translated into \texttt{object.\_\_len()\_\_}\footnote{Why not implement it as a method \texttt{object.len()} or, even better, as a read-only property \texttt{object.len}? Read \href{https://mail.python.org/pipermail/python-3000/2006-November/004643.html}{here} for the justification.}.

Another popular duck typing application is an implementation of an iterator: an object that yields one item at a time, so you can do lazy computation\footnote{Lazy computation means that you compute or get only what is necessary right now, rather than computing or getting all items in one go.} or loop over them. It must implement two special methods to enable iteration over its items: \texttt{\_\_iter\_\_(self)} and \texttt{\_\_next\_\_(self)}. The former is called when iteration starts and it should perform all necessary initializations (e.g., setting internal counter to 0, reshuffling elements, etc.) and must return an iterator object (typically, a reference to itself)\footnote{This is what function \texttt{range()} returns, not a list but an iterator object.}. The \texttt{\_\_next()\_\_} method is called whenever the next item is needed: if you use iterator in the \texttt{for} loop, it is called automatically or you can call it yourself via \texttt{next(iterator\_object)} (try it on a \texttt{range()} iterator). \texttt{\_\_next()\_\_} must return the next item or \texttt{raise\ StopIteration()} exception, signalling that it ran out of items.

Note that iterator does not require an implementation of the \texttt{\_\_len()\_\_} method! How come? If you have items you can iterate over, doesn't it make sense to also know their number (length of an object)? Not necessarily! First, if you use an iterator in a \texttt{for} loop and you just want to iterate over all of the items until you run out of them (which is signalled by the \texttt{StopIteration()} exception). Thus, their total number and, hence, \texttt{len()} method is of little interest. Accordingly, why implement a function that you do not need\footnote{Of course, if you \emph{do} need it, you should implement it. The point is that quite often you do not.}? Second, what if your iterator is endless (in that case, it is called a \emph{generator})? E.g., every time \texttt{\_\_next\_\_()} is called it returns one random item or a random number. This way, it will never run out of items, so the question of ``what is its length'' is meaningless (unless you take ``infinity'' for an answer). This lack of need for \texttt{\_\_len\_\_()} for iterators is the spirit of duck typing: implement only the methods you need from your duck, ignore the rest.

Below, you will practice duck typing by implementing both \texttt{\_\_len()\_\_} and two special iterator methods as part of our \texttt{AlienArmada} class.

\hypertarget{which-one-to-use}{%
\section{Which one to use?}\label{which-one-to-use}}

Now you know \emph{three} methods to produce common behavior: proper inheritance, mixins, and duck typing. Which one should you use? Depends on what you need. If you have many classes and you can have a well defined inheritance tree, use it. However, if you have some specific behavior that you need in some classes that is hard to fit with the inheritance tree, use mixins. If you have a single class that needs very specific functionality: use duck typing. Any one of them, does not preclude you using others. But be moderate, using too many different paradigms will be confusing for you and a reader.

\hypertarget{space-invaders}{%
\section{Space Invaders}\label{space-invaders}}

We will program a simply version of the game with aliean armada going gradualy descending. You task is to capture all aliens by firing a teleport beam before one of them rams your ship. Below, you can see my version of the game.

As per usual, the plan is to move slowly in small increments to keep the complexity of changes low. For the assignment, you will need to submit the final product. However, I strongly recommend an iterative \emph{submit-get comments-adjust-add another step or two-submit-get comments-\ldots{}} approach. It will be much easier, both for you and for me, if we catch errors or potentially problematic code early\footnote{Number of submissions is unlimited with reason.}.

Before we start, grab images that we will use for the game \href{material/space-invaders.zip}{space-invaders.zip}, created specifically for our seminar by Andrej Pastukhov, who said you absolutely must look at this link: \href{https://youtu.be/dQw4w9WgXcQ}{Wie die Pixelarts meines Sohnes Andrej entstanden sind}\footnote{No worries, it is safe. He says, you should understand. But I have no idea as, evidently, I am out of touch with modern trends.}.

\hypertarget{boilerplate}{%
\section{Boilerplate}\label{boilerplate}}

Create our usual boilerplate code in \emph{exercise01.py} (you will use the same files for classes but use versioning of the main file, it makes it easier for me to check your code):

\begin{itemize}
\tightlist
\item
  Import what is needed from PsychoPy
\item
  Create a window. I've picked 640×480, as our sprites are 32×32 but chose whatever looks good on your screen.
\item
  Create our usual main game loop with \texttt{gamover} variable, flipping the window, and checking for \emph{escape} button press.
\end{itemize}

Put your boilerplate code into \emph{exercise01.py}.

\hypertarget{the-shapeship}{%
\section{The shapeship}\label{the-shapeship}}

Craete a new file for \texttt{Shapeship} class. It is remarkably boring as it just an image that moves left-right on a horizontal line. Thus, we will create it as a descendant of \texttt{visual.ImageStim} class. The only method that you need to define right now is the constructor \texttt{\_\_init()}. It should take \texttt{win} as the only parameter (apart from \texttt{self}, of course) and call \texttt{super().\_\_init\_\_(...)} with \texttt{win} variable that you've got as a parameter, name of the image (\emph{raumschiff.png}, don't forget to add the relative path to it), and the \texttt{pos}ition of the image.

In the main code, create an object and draw it in the main loop. Experiment with the vertical placement. The ship should be somewhere just above the lower edge of the window. For me, vertical position of -0.9 worked quite nicely.

Put your updated code into \emph{exercise02.py}, plus an \texttt{Spaceship} class into a separate file.

\hypertarget{the-shapeship-moves}{%
\section{The shapeship moves}\label{the-shapeship-moves}}

Now, let us use the \href{https://psychopy.org/api/event.html\#psychopy.event.Mouse}{mouse} to control the horizontal position of the ship and, later on, left button to shoot. In the main loop, use \href{https://psychopy.org/api/event.html\#psychopy.event.Mouse.getPos}{getPos()} method to get the position of the mouse and use \emph{horizontal} component to alter the position of the ship. We want it to remain at the same position vertically, so we want to keep it constant. Note, however, that you cannot assign just a horizontal or vertical components to the position via \texttt{.pos{[}0{]}\ =\ ...}. In my PsychoPy 2020.2.10 it does not generate an error but does not change the actual position either. Thus, you need to assign a tuple/list of \texttt{{[}new\ horizontal\ component,\ original\ vertical\ component{]}}. Test moving your spaceship around. You can make mouse invisible (see documentation on the parameter) to make it more immersive.

Put your updated code into \emph{exercise03.py}.

\hypertarget{an-alien-appears}{%
\section{An alien appears}\label{an-alien-appears}}

Before we create an alien armada, let us start by creating a single alien. The class will be very basic, just like \texttt{Spaceship}. This is why, we will put both \texttt{Alien} and \texttt{AlienArmada} into the same file (so, think about its filename). The class itself will very similar to the \texttt{Spaceship}. The only differences are that it should take (and pass) \texttt{pos} parameter (unlike the spaceship that always appears at the same location) and that the image should be randomly picked, either \emph{alien-1.png} or \emph{alien-2.png}. For testing, place a few alians at arbitrary locations on the screen to check that the image is randomly picked. Do not forget to draw them in the main loop.

Put your updated code into \emph{exercise04.py}, plus an \texttt{Alien} class into a separate file.

\hypertarget{an-alien-armada-appears}{%
\section{An alien armada appears}\label{an-alien-armada-appears}}

One alien is neither scary, nor challenging enough. We want more! For this, we will create an \texttt{AlienArmada} class with a twist. It will be responsible for creating a grid of aliens, moving them around (we will use getter/setter functions for that), allowing outside processes to iterate over them (iterator duck typing), and reporting the number of remaining aliens (length duck typing). As usual, we will do this one step at a time.

Start by creating an \texttt{AlienArmada} class, below the \texttt{Alien} class. Our initial version will have constructor, \texttt{spawn()}, and \texttt{draw()} methods plus \texttt{win}, \texttt{\_\_pos} (a tuple with the position within the window) and \texttt{aliens} attributes. The latter will be a list with alien objects. Let us go through methods implementation.

Constructor \texttt{\_\_init()\_\_}. We will create and place aliens in a separate method \texttt{spawn()}. Thus, our constructor will be very simple. You only need to store its only \texttt{win} parameter as an attribute, initialize \texttt{\_\_pos} to some predefined value (I've picked \texttt{(0,\ 0.5)} but you can always optimize it later on), initialize \texttt{aliens} attribute to an empty list, and call \texttt{spawn()} method.

\texttt{spawn()}. Here, create aliens on 7×3 grid with a step of 0.2 units centered at \texttt{AlienArmada}'s position. All aliens go to \texttt{aliens} attribute, of course. It should look like this:

\includegraphics[width=8.89in]{images/alien-armada}

\texttt{draw()}. You simply draw all aliens.

Put your updated code into \emph{exercise05.py}, plus create the \texttt{AlienArmada} class.

\hypertarget{a-laser-shot-appears}{%
\section{A laser shot appears}\label{a-laser-shot-appears}}

Now we need to create \texttt{Laser} class (in a separate file). Eventually, when a player presses left mouse button, the laser should appear at the location just above and fly up with a certain speed. Let us take care of the first step. Create \texttt{Laser} class as a descendant of \texttt{visual.ImageStim} (just like our \texttt{Spaceship} and \texttt{Alien} classes). It should take \texttt{win} and \texttt{pos} as arguments and call the ancestor constructor. The \texttt{pos} argument will hold the position of the ship but the laser must appear \emph{above} it, so you need to adjust \texttt{pos{[}1{]}} for that. Hint, you can get window height from \texttt{win.size{[}1{]}} and you know sprites are 32 pixels high. The algebra should be straightforward.

For testing, create a laser object right after you create the ship itself and draw it in the main loop. It won't move but you will be able to see whether you've got the height right.

Put your updated code into \emph{exercise06.py}, plus create the \texttt{Laser} class.

\hypertarget{the-laser-shot-flies}{%
\section{The laser shot flies}\label{the-laser-shot-flies}}

Let us add \texttt{fly()} method to the laser. It will be very simple, every time it is called the laser should move upwards by some arbitrary value of units (I've used 0.05 but pick the speed you like). Once it flies off the screen, we should be mark it for deletion, as we won't need it anymore. Thus, create a new attribute \texttt{expired} and set to \texttt{False}. In the \texttt{fly()} method, move the laser only if laser has not \texttt{expired} and, once you move it, check whether it is off the screen (its vertical position is 1 + half-height). If it is, mark it as expired.

Remember to call \texttt{fly()} method in the main loop and see how the laser flies up and off the screen. Once it is gone, set a breakpoint to check that its \texttt{expired} flag is indeed \texttt{True}.

Put your updated code into \emph{exercise07.py}, update the \texttt{Laser} class.

\hypertarget{we-want-more-lasers}{%
\section{We want more lasers!}\label{we-want-more-lasers}}

Now we will create a \texttt{LaserGun} class that will take care of individual laser shots. It will 1) create a new \texttt{Laser} object whenever it is \texttt{fire()}d, 2) ensure that it does not overheat by allowing only one shot every N seconds (let's say 0.3), 3) call \texttt{draw()} and \texttt{fly()} methods for all laser shots, and 4) remove the expired ones via \texttt{cleanup()}.

Create the class \texttt{LaserGun} in the same file as the \texttt{Laser}.

Constructor \texttt{\_\_init()\_\_}. In the constructor, pass PsychoPy window variable and store it as an attribute (you will need it when you create a new laser object), initialize \texttt{lasershots} attribute with empty list, and create a \texttt{timer} attribute via \texttt{clock.CountdownTimer()} (decode on the minimal interval between the shots, I've picked 300 ms). We will use it inside the \texttt{fire()} method later on.

\texttt{fire(self,\ pos)}. It should take \texttt{pos} tuple with position of the ship as a single parameter. If enough time passed since the last shot (check \texttt{.timer} for that), create a new \texttt{Laser} at the supplied position, add it to the \texttt{lasershots} list, and reset the timer.

\texttt{draw()} and \texttt{fly()} simply draw or fly all \texttt{lasershots}.

\texttt{cleanup()}. This is both simple and tricky! Conceptually simple: you loop over \texttt{lasershots} and delete any object that is \texttt{expired}. You can do it via list comprehension (deleting objects by not including them in the updated list) but for didactic reasons we will use \href{https://docs.python.org/3/tutorial/datastructures.html\#the-del-statement}{del} instead. If you have a list and you want to delete a second element, you write

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x }\OperatorTok{=}\NormalTok{ [}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{, }\DecValTok{4}\NormalTok{, }\DecValTok{5}\NormalTok{]}
\KeywordTok{del}\NormalTok{ x[}\DecValTok{1}\NormalTok{]}
\BuiltInTok{print}\NormalTok{(x)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1, 3, 4, 5]
\end{verbatim}

However, there is a catch. Imagine that you want to delete second and forth elements, so that the result should be \texttt{{[}1,\ 3,\ 5{]}}. If you just delete second and then forth elements, you won't get what you want:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x }\OperatorTok{=}\NormalTok{ [}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{, }\DecValTok{4}\NormalTok{, }\DecValTok{5}\NormalTok{]}
\KeywordTok{del}\NormalTok{ x[}\DecValTok{1}\NormalTok{]}
\KeywordTok{del}\NormalTok{ x[}\DecValTok{3}\NormalTok{]}
\BuiltInTok{print}\NormalTok{(x)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1, 3, 4]
\end{verbatim}

Do you see why? Solution: start deleting from the end, this way indexes of earlier elements won't be affected:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x }\OperatorTok{=}\NormalTok{ [}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{, }\DecValTok{4}\NormalTok{, }\DecValTok{5}\NormalTok{]}
\KeywordTok{del}\NormalTok{ x[}\DecValTok{3}\NormalTok{]}
\KeywordTok{del}\NormalTok{ x[}\DecValTok{1}\NormalTok{]}
\BuiltInTok{print}\NormalTok{(x)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1, 3, 5]
\end{verbatim}

Note that you must use \texttt{del\ list{[}index{]}} format, so you need to use indexing for loop for the \texttt{cleanup()} function:

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{for}\NormalTok{ ishot }\KeywordTok{in}\NormalTok{ backwards}\OperatorTok{{-}}\NormalTok{index}\OperatorTok{{-}}\NormalTok{built}\OperatorTok{{-}}\NormalTok{via}\OperatorTok{{-}}\BuiltInTok{range}\OperatorTok{{-}}\NormalTok{function:}
  \ControlFlowTok{if} \VariableTok{self}\NormalTok{.lasershots[ishot] needs to be deleted:}
\NormalTok{    delete that }\VariableTok{self}\NormalTok{.lasershots[ishot]}
\end{Highlighting}
\end{Shaded}

For testing, use \texttt{LaserGun} in place of the \texttt{Laser}. Both have same \texttt{draw()} and \texttt{fly()} methods that you should be calling already. Add \texttt{cleanup()} call to the main loop right after the \texttt{fly()} (that will automatically delete expired shots). Also in the main loop, check if left mouse button is \href{https://psychopy.org/api/event.html\#psychopy.event.Mouse.getPressed}{pressed}. If it is, \texttt{fire()} the laser gun, passing current position of the ship to it. Once you fired a few shots and they are off the screen, put a breakpoint and check that the \texttt{.lasershots} is empty (you \texttt{cleanup()} works as it should).

Put your updated code into \emph{exercise07.py}, update the \texttt{Laser} class.

\hypertarget{i-am-hit-i-am-hit}{%
\section{I am hit! I am hit!}\label{i-am-hit-i-am-hit}}

Now we need to check whether a lasershot hit an alien. In that case, all the relevant aliens and shots must be removed. It is easy for lasershots, we just set them as \texttt{expired} and \texttt{cleanup()} does the rest. Clearly, we need the same mechanism for the aliens.

Add \texttt{teleported} attribute to the \texttt{Alien} class and initialize to \texttt{False}. In \texttt{AlienArmade} class, implement a \texttt{cleanup()} method, analogous to one in \texttt{LaserGun} that will delete any \texttt{teleported} aliens. Add the call to it in the main loop at the same location as for the \texttt{LaserGun}. You can test it by setting \texttt{teleported} to \texttt{True} for one of the aliens and it should be missing.

Now for the actual check. You should loop over all aliens and laser shots checking whether whether they \href{https://psychopy.org/api/visual/imagestim.html\#psychopy.visual.ImageStim.overlaps}{overlap}. If they do, set laser shot to \texttt{expired} and the alien as \texttt{teleported}. Do this check \emph{before} the clean up but after the laser shots fly.

Test it!

Put your updated code into \emph{exercise08.py}, update \texttt{Alien} and \texttt{AlienArmade} classes.

\hypertarget{duck-typiing-iterators}{%
\section{Duck typiing iterators}\label{duck-typiing-iterators}}

In the precious exercise, you used \texttt{aliens} and \texttt{lasershots} attributes directly in the loop. However, let us inject some coolness into our code and turn \texttt{AlienArmada} and \texttt{LaserGun} classes into iterators. Recall that you need to implement two special methods for this: \texttt{\_\_iter\_\_(self)} and \texttt{\_\_next\_\_(self)\_\_}. The first one, initializes the loop, the second one yields the next item. The actual implementation is very simple. You need to create a new attribute that will be used to track which item you need to yield, call it \texttt{iter}. Initialize it to \texttt{None} in the constructor.

In the \texttt{\_\_iter\_\_(self)}, initialize the counter to \texttt{0} and return \texttt{self}, returning the reference to the iterator, which is the object itself\footnote{You can cheat and return the reference to the list attribute itself and it'll do the rest. Don't do it for didactic purposes.}. In the \texttt{\_\_next\_\_(self)}, check if \texttt{iter} is within the list length. If it is not (i.e., you ran out aliens/shots to iterate over), \texttt{raise\ StopIteration()}. If it is, increase the iteration counter and return the element it was indexing \emph{before} that: Think about why you need to return \texttt{self.aliens{[}self.iter-1{]}} rather than \texttt{self.aliens{[}self.iter-1{]}} or how you can use a different starting value and range check to avoid this.

Do this for both classes and use them in for loops directly, instead of \texttt{aliens.aliens} and \texttt{laser.lasershots}.

Test it! It should work as before, of course, but with cooler duck typing inside!

Put your updated code into \emph{exercise09.py}, update \texttt{LaserGun} and \texttt{AlienArmade} classes.

\hypertarget{gotem-all}{%
\section{Got'em all!}\label{gotem-all}}

Now, implement \texttt{\_\_len()\_\_} method for \texttt{AlienArmada} class that so returns the number of remaining aliens. In the main loop, use it via \texttt{len()} function to check whether you won: no aliens left, the game is over. Use \texttt{len()} with the object, not with the list attribute!

Put your updated code into \emph{exercise10.py}, update \texttt{LaserGun} and \texttt{AlienArmade} classes.

\hypertarget{ping}{%
\section{Ping!}\label{ping}}

Now let us use a \texttt{TeleportSoundMixin} class that defines a single \texttt{teleport()} method that plays the \emph{teleport.wav} sound (created by Sergenious and obtained from \href{https://freesound.org/people/Sergenious/sounds/55853/}{freesound.org}) is in \href{material/space-invaders.zip}{materials}. Thus, it can be a single line method when you both create and play the sound in one go, no temporary variable or an attribute are required. Then, use it as an ancestor for the \texttt{Alien} class. Now it has that \texttt{teleport()} method. Call it when you set \emph{teleported} to \texttt{True}.

Put your updated code into \emph{exercise11.py}, create \texttt{TeleportSoundMixin} class and update \texttt{Alien} class.

\hypertarget{the-alien-armada-jumps}{%
\section{The alien armada jumps}\label{the-alien-armada-jumps}}

Currently, our aliens are sitting ducks. No fun! They need to get a move on. But before we can move alien armada around, we need to be able to change its position. Recall that we have \texttt{\_\_pos} attribute in \texttt{AlienArmada} class. I've made it (kinda) private via \texttt{\_\_pos} on purpose, so we can define getter and setter methods for it and call the virtual attribute \texttt{pos} to make it consistent with the rest. If you forgot what getter/setter methods are, \protect\hyperlink{getter-setter}{read again}.

To start with, define a getter. It only needs to return the value of the hidden position attribute.

Now, to more complicated and, hence, fun bit! Remember, we need to move \emph{all} individual aliens relative to the center of the armada. For this, 1) compute the \emph{change} in position, 2) use it to alter position of individual aliens based on their current position, 3) store the new position in the hidden attribute.

Test it by making armada jump to a random location every time you press \emph{space} button. The armada should keep its formation!

Put your updated code into \emph{exercise12.py}, update \texttt{AlienArmada} class.

\hypertarget{the-alien-armada-moves}{%
\section{The alien armada moves}\label{the-alien-armada-moves}}

Our alien armada will move downwards along a sine trajectory. Thus, we need to define a \texttt{fly()} method that will move it downwards by some small step (I've used 0.001, which is quite fast for 60 Hz, as it will move 0.06 units per second). And the horizontal position will be computed as a sine wave. The general formula is:
\[x = x_{max} \cdot sin(2 \pi f \cdot (y-y_{origin})) \]
where \(x_{max}\) is maximal deviation of the armada from the middle of the screen (I've set it to 0.25), the \(f\) is the frequency, i.e., how fast is horizontal movement (I've set to 3), \(y\) is the current vertical coordinate of the armada and \(y_{origin}\) is the initial one (0.5 in my case). Experiment with values to see how they affect the movement.

Once you computed both components, assign the tuple to the \texttt{pos} and it will move the entire armada. In the main loop, call \texttt{fly()} when you call it for laser gun.

Put your updated code into \emph{exercise13.py}, update \texttt{AlienArmada} class.

\hypertarget{the-alien-armada-wins-crash}{%
\section{The alien armada wins: crash!}\label{the-alien-armada-wins-crash}}

So far, the player always wins. Let us make it more dangerous! They will lose if either an alien crashes into the spaceship or if the armada goes past the ship. Implement the former the same way as you checked whether laser shot hit an alien: loop of aliens and see if the overlap with the spaceship (game over if they do). Implement and test.

Put your updated code into \emph{exercise14.py}.

\hypertarget{the-alien-armada-wins-missed-them}{%
\section{The alien armada wins: missed them!}\label{the-alien-armada-wins-missed-them}}

The second way to lose the game, is if at least one alien got past the ship. For this, we need to check the position of the \emph{lowest} alien and if it is lower than that of the spaceship, the game is over. You can do it in the same loop you are checking for the hit but, for didactic reasons, let us practice \texttt{@proprety} a bit more. Implement a new read-only property \texttt{lowest\_y} of the \texttt{AlienArmada} class that will return the y-coordinate of the lowest alien in the armada. You need to loop over individual aliens to find the lowest y and return it. There are different way to do it, come up with one yourself! In the main code, add the check and make sure the game is over, if aliens got past the player.

Put your updated code into \emph{exercise15.py}, update \texttt{AlienArmada} class.

\hypertarget{mixin-teleport}{%
\section{Mixin teleport}\label{mixin-teleport}}

Mix in the teleport sound method to the \texttt{Spaceship} and play it if alien crashed into it.

Put your updated code into \emph{exercise16.py}, update \texttt{Spaceship} class.

\hypertarget{game-over-message-1}{%
\section{Game over message}\label{game-over-message-1}}

Create a game over message (a blinking one would be cool but this is up to you) that will reflect the outcome. Something like this but use your imagination:

\begin{itemize}
\tightlist
\item
  ``Coward!'', if the player pressed escape.
\item
  ``Congrats!'', if the player won.
\item
  ``Crash! Boom! Bang!'', if the player was hit.
\item
  ``They got away!'', if the armada got past the player.
\end{itemize}

One way to simplify you life is to rename \texttt{gameover} variable into the \texttt{gamestate} variable. Initially, it could be \texttt{"playing"}, so your loop repeats \texttt{while\ gamestate\ ==\ "playing"}. Then, you can set it based on the type of the event, e.g., \texttt{"abort"} for \emph{escape} button press, \texttt{"victory"} when player wins, etc. and use it after the main loop to determine which message to show. Better still, use dictionary for this instead of if-else. Or ``cheat'' and store the message in the variable itself.

Put your updated code into \emph{exercise17.py}.

\hypertarget{we-want-more-1}{%
\section{We want more!}\label{we-want-more-1}}

You have a solid game but it can be improved in many ways. Currently, we move all game object assuming constant frame rate. That might not be the case, so it would be wiser to use inter-frame timer and use time elapsed since the last update. And it can use more feature. Score? Difficulty? More levels? Aliens shooting back at you? Anything is possible!

\hypertarget{seminar-02-06}{%
\chapter{Guitar Hero: staircase and iterator functions}\label{seminar-02-06}}

\hypertarget{getting-the-difficulty-just-right}{%
\section{Getting the difficulty just right}\label{getting-the-difficulty-just-right}}

One of the hardest things to get right in game design is the game difficulty. Make your game too easy and it will be boring. Make it too hard and only hardcore fans will play and only for \href{https://www.imdb.com/title/tt4975856/}{an achievement}. Thus, you would like to make your game hard enough to push a player to the limit but not much harder than that, so not to frustrate them. One way to solve this conundrum is to create different preset difficulty levels, something we did in our \emph{Snake} game. An alternative way is to make the game that adopts its difficulty to the player.

The same is true for psychophysical experiments. You want to test ability of your participants to perform the task at their limit for one simple reason: At this \emph{threshold} point influence of any additional factor, whether positive or negative, is maximal. E.g., use an unusual stimulus configuration or increase attentional load and performance will drop. Allow to preallocate attention via cuing or use a prime that is congruent with a target and performance will improve. Of course, these manipulations will have the same overall effect also when the task is particularly easy or maddeningly hard but it will much more difficult to \emph{measure} this effect. It is one thing if performance drops from 75\% to 65\% than if it goes from 98\% to \%95 or from \%53 to \%52 (here, I assume that 50\% is chance level performance) or vice versa. The silliest thing you can do is to \emph{hope} that the performance would allow you too see the effect of the factors that you manipulated. In things like these, knowledge and careful design is definitely superior to hope.

Thus, you want performance of your participants to be approximately in the middle between the ceiling (100\% performance, fastest response times, super easy) and the floor (chance level performance, slowest response times, super hard). But how do you know where this magic point is for that \emph{particular} person. Particularly, if the task is novel so you have little to guide to? The solution is to adjust the difficulty on the fly. If you have a two-alternatives-forced-choice task, you can use two-up-one-down staircase (difficulty increases after two correct responses and decreases after one mistake) that targets 70.7\% performance threshold. There different methods and even different ways to use the same core method (e.g., does the step stays constant or changes in 2-up-1-down, what is the run termination criteria, etc.), so it is always a good idea to refresh your memory and read about \href{https://doi.org/10.3758/BF03194543}{adaptive procedures} when designing your next experiment.

In our game, we will use a very simple 3-up-1-down staircase: get the three responses correct on a row and things get faster, make a mistake and the game slows down. We'll see how fast you can go!

\hypertarget{guitar-hero}{%
\section{Guitar Hero}\label{guitar-hero}}

Today, we will program Guitar Hero game. In the original game, you must play notes on guitar-shaped controller at the right time, just like when you actually play music on a guitar. On the one hand, it is a straightforward and repetitive motor task. On the other hand, take a fast and complicated music piece and it'll take many minutes or hours of practice to get it right. It is a lot of fun, as music cues and primes your responses. The same idea of music-synchronized-actions was used in \emph{Raymon Legends} music-run levels where jumps or hits are timed to drums or bass. It is bizarrely cool and satisfying experience, also when watching pros to do it (I happened to have one in my household).

We will program this game sans Guitar and Hero, you can see it in the video below. The player must press a correct key whenever the target crosses the line. Press it to early or too late and you make a mistake. Of course, the faster the targets go, the harder it is to respond on time and with a correct key. As I wrote above, we will use the 3-up-1-down staircase procedure to control for that.

As per usual, we will take gradual approach:

\begin{itemize}
\tightlist
\item
  Boilerplate code
\item
  A moving targets class
\item
  Finishing line and
\end{itemize}

\hypertarget{boilerplate-1}{%
\section{Boilerplate}\label{boilerplate-1}}

Create our usual boilerplate code in \emph{exercise01.py} (you will use the same files for classes but use versioning of the main file, it makes it easier for me to check your code):

\begin{itemize}
\tightlist
\item
  Import what is needed from PsychoPy
\item
  Create a window. I've picked 640×480 but chose whatever looks good on your screen.
\item
  Create our usual main game loop with \texttt{gamover} variable, flipping the window, and checking for \emph{escape} button press.
\end{itemize}

Put your boilerplate code into \emph{exercise01.py}.

\hypertarget{target-and-timedresponsetask-classes}{%
\section{Target and TimedResponseTask classes}\label{target-and-timedresponsetask-classes}}

OUr main work horse will be \texttt{TimedResponseTask} class. It will take spawn a new random \texttt{Target} at random intervals (which will depend on speed), pass speed information to moving targets, and remove targets, once they disappear below the screen. The \texttt{Target} class use \texttt{visual.Rect}\footnote{Inherting from \texttt{visual.Rect} would've make it even simpler but, due to so technical glitch, unfortunately that does not work.} with some extra bells and whistles to make it appear at the right location, move at the right speed, change it line color (if a player got the response for it right), compute whether it is already off the screen, etc. we will start with a single target first.

\hypertarget{target-class-static}{%
\section{Target class: static}\label{target-class-static}}

First create a \texttt{Target} class: a colored rectangle in one of the three positions that starts at the top of the window and moves down at a specific speed. Its constructor should take PsychoPy window as a parameter (you will need it to the rectangle attribute), position index (from 0 to 2), and speed (in norm units per second). The only thing we need to do right now in the constructor is to create a color rectangle (see below) and store \texttt{speed} as an attribute for later use.

The second parameter --- position index --- determines the horizontal position of the target and its color (to make targets more fun and distinct). For my code, I decided to make rectangle 0.4 norm units wide and 0.1 norm units high. The leftmost \emph{red} rectangle (for \texttt{ipos} 0), is centered at -0.5, the middle \emph{green} one is dead center, and the rightmost \emph{blue} rectangle is centered at 0.5. I've defined all these as \texttt{TARGET\_} constants (e.g., \texttt{TARGET\_COLOR\ =\ ...}), so think about how you can compute both color and position without using if-else statements. Also, think about the y-position of the rectangle, so it appears right at the top of the window.

The second method you need is \texttt{draw()} which simply draws the rectangle. Test it by creating a target at one of the position (all target at all three positions) and drawing them in the main loop. You should get static rectangle(s).

Put updated code in \emph{exercise02.py} and create the class \texttt{Target} in a separate file.

\hypertarget{target-class-moving}{%
\section{Target class: moving}\label{target-class-moving}}

Our targets fall down at speed defined by their \texttt{speed} attribute. Later on we will change that attribute dynamically to speed up or slow down their fall.

To implement the actual falling down, implement a new method, call it \texttt{fall()}. The speed is in \texttt{norm\ units\ per\ second}, thus, to compute the change in vertical position you also need to know the time elapsed since last position update \emph{in seconds}. The simplest way to do this is by using a \href{https://psychopy.org/api/clock.html\#psychopy.clock.Clock}{Clock} class. You create it as an attribute in the constructor and then, in the \texttt{fall} method you use its current time to compute (and apply) a change in vertical position of the rectangle. Don't forget to reset the clock!

Include \texttt{fall} method call in the main loop and see how the target falls. Experiment with falling speed!

Put updated code in \emph{exercise03.py} and update the class \texttt{Target}.

\hypertarget{iteratorgenerator-functions}{%
\section{Iterator/Generator functions}\label{iteratorgenerator-functions}}

In the next section, we will create a \texttt{TimedResponseTask} class that will generate targets at random location and after a random interval. We can, of course, do it directly in the class but instead, we will use this as an opportunity to learn about iterator/generator functions. You already know how to use duck typing to turn any class into a iterator by defining special method \texttt{\_\_iter()\_\_} and \texttt{\_\_next\_\_()}. But function can also be an iterator if it uses \texttt{yield} instead of \texttt{return} statement to \emph{yield} a value. It \emph{yields} it, because the function itself returns an iterator object that you can iterator over in for loop or via \texttt{next()} function. Importantly, \texttt{yield} ``freezes'' execution of the function and the next time you call the function \emph{it continues from that point} rather than from the start of the function. Once you reach the end of the function, it automatically raises \texttt{StopIteration()} exception, so you don't need to worry about this. It may sound confusing but it really simple. Here an example to illustrate this:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{def}\NormalTok{ iterator\_fun():}
    \ControlFlowTok{yield} \DecValTok{3}
    \ControlFlowTok{yield} \DecValTok{1}
    \ControlFlowTok{yield} \StringTok{"wow!"}
  
\CommentTok{\# function returned the iterator, not a value!}
\BuiltInTok{print}\NormalTok{(iterator\_fun())}

\CommentTok{\# iterating via for loop}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## <generator object iterator_fun at 0x000000002694BBA0>
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{for}\NormalTok{ elem }\KeywordTok{in}\NormalTok{ iterator\_fun():}
    \BuiltInTok{print}\NormalTok{(elem)}
    
\CommentTok{\# iterating via next(), note you use it the iterator object }
\CommentTok{\# that function returned, not with the function itself }
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## 3
## 1
## wow!
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{iterator\_var }\OperatorTok{=}\NormalTok{ iterator\_fun()  }
\BuiltInTok{print}\NormalTok{(}\BuiltInTok{next}\NormalTok{(iterator\_var))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## 3
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(}\BuiltInTok{next}\NormalTok{(iterator\_var))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## 1
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(}\BuiltInTok{next}\NormalTok{(iterator\_var))}

\CommentTok{\# next call will raise an exception StopIteration}
\CommentTok{\# print(next(iterator\_var))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## wow!
\end{verbatim}

This format makes writing iterators very easy, just \texttt{yield} whatever you want in the order you want and Python will take care of the rest. Also, you can \texttt{yield} in a loop, inside an if-else statement, etc.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{def}\NormalTok{ iterator\_fun():}
  \ControlFlowTok{for}\NormalTok{ e }\KeywordTok{in} \BuiltInTok{range}\NormalTok{(}\DecValTok{4}\NormalTok{):}
    \ControlFlowTok{if}\NormalTok{ e }\OperatorTok{\%} \DecValTok{2} \OperatorTok{==} \DecValTok{1}\NormalTok{:}
      \ControlFlowTok{yield}\NormalTok{ e}

\NormalTok{iterator }\OperatorTok{=}\NormalTok{ iterator\_fun()}
\BuiltInTok{next}\NormalTok{(iterator)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## 1
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{next}\NormalTok{(iterator)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## 3
\end{verbatim}

For our \texttt{TimedResponseTask} class, we will need two \emph{generators} (because both will be endless). One that generates a random delay until the next target and one that generates random target position (0, 1, or 2). Implement both in a separate file.

The \texttt{time\_to\_next\_target\_generator()} function should take a tuple of float values a its only parameter and \emph{yield} a random number within this range in an \emph{endless} loop. We need the endless loop (\texttt{while\ True:} will do) because we do not know how many values we will need, so we just generate as many as needed.

The \texttt{next\_target\_generator()} will be a bit more interesting. It can just return a \texttt{random.choice} from 0, 1, and 2 but where is fun in that? Instead, we will make a bit more complicate to ensure that all three targets appear equal number of times within N trials, where N will be a parameter of the generator. This would ensure random, reasonably unpredictable but balanced targets in the short run. Remember, in the long run random choice will give us a balanced uniform distribution but there is not such guarantee for the shorter runs. First, you should create a list where each target appears N times. Then, create an endless loop (again, we don't know how many values we need) in which you 1) shuffle elements of the list, 2) yield one element at a time via for loop. Then repeat. And again, and again (endless loop!).

I would suggest creating and testing both function in a Jupyter notebook first and then putting them in a separate file (e.g., \emph{generators.py}).

Put both generators into \emph{generators.py}.

\hypertarget{timedresponsetask-class}{%
\section{TimedResponseTask class}\label{timedresponsetask-class}}

Now we are ready to create the \texttt{TimedResponseTask} class. For our first take, it will create random targets after random intervals plus take care of moving and drawing all of them. More bells and whistles (disposing of targets that went past the screen, changing the speed, checking response validity, etc) will come later.

For the constructor, we definitely need PsychoPy window as a parameter (we'll need to pass it to the \texttt{Target} constructor). We can also pass initial speed, tuple with range for time intervals between targets and number of target repetitions (for the position generator). We could define those as constants but passing them as parameters will make you code more reusable. Store window and speed as attributes, create attribute \texttt{targets} and initialize it to an empty list, create attributes for both generator objects that we need using the appropriate parameters.

\hypertarget{settings-file}{%
\section{Settings file}\label{settings-file}}

So far, we either hard-coded values or defined constants. This means that to modify any of them, you need to modify the program itself. A better approach is to have a separate file with settings. This puts all of them in one place and makes easier to edit and check them. Plus, you can have many settings file for different experimental stages, groups, etc.

There multiple formats for settings files: XML, INI, YALM, etc. Experiment designed using PsychoPy Builder interface are stored using XML (Extensible Markup Language) files but with \href{https://www.psychopy.org/psyexp.html}{.psyexp extension}.

\hypertarget{cross-references}{%
\chapter*{Cross references}\label{cross-references}}
\addcontentsline{toc}{chapter}{Cross references}

\hypertarget{a}{%
\subsubsection*{A}\label{a}}

\begin{itemize}
\tightlist
\item
  \href{https://www.anaconda.com}{Anaconda}, a scientific Python distribution, see also \protect\hyperlink{install-anaconda}{installation notes}.
\end{itemize}

\hypertarget{b}{%
\subsubsection*{B}\label{b}}

\begin{itemize}
\tightlist
\item
  \protect\hyperlink{break}{Breaking} out of the loop.
\end{itemize}

\hypertarget{c}{%
\subsubsection*{C}\label{c}}

\begin{itemize}
\tightlist
\item
  \protect\hyperlink{constants}{Constants}
\end{itemize}

\hypertarget{i}{%
\subsubsection*{I}\label{i}}

\begin{itemize}
\tightlist
\item
  \protect\hyperlink{import}{importing} libraries.
\item
  \protect\hyperlink{input-function}{input({[}prompt{]}) function}, see also \href{https://docs.python.org/3/library/functions.html\#input}{official manual}.
\end{itemize}

\hypertarget{l}{%
\subsubsection*{L}\label{l}}

\begin{itemize}
\tightlist
\item
  \protect\hyperlink{lists}{lists}
\end{itemize}

\hypertarget{p}{%
\subsubsection*{P}\label{p}}

\begin{itemize}
\tightlist
\item
  \href{https://www.psychopy.org/}{PsychoPy} PsychoPy standalone application and library, see also \protect\hyperlink{install-psychopy}{installation notes}.
\end{itemize}

\hypertarget{s}{%
\subsubsection*{S}\label{s}}

\begin{itemize}
\tightlist
\item
  \protect\hyperlink{lists}{Slicing}
\item
  \protect\hyperlink{string-formatting}{String formatting}, see also \href{https://pyformat.info/}{PyFormat} for information on new string formatting and practical examples.
\end{itemize}

\hypertarget{t}{%
\subsubsection*{T}\label{t}}

\begin{itemize}
\tightlist
\item
  \protect\hyperlink{value-types}{Types}
\end{itemize}

\hypertarget{v}{%
\subsubsection*{V}\label{v}}

\begin{itemize}
\item
  \protect\hyperlink{value-types}{Value types (simple)}
\item
  \protect\hyperlink{variables}{Variables}
\item
  \href{https://code.visualstudio.com/}{Visual Studio Code}, a lightweight free open-source editor with strong support for Python. See also \protect\hyperlink{install-vs-code}{installation notes}.
\end{itemize}

\hypertarget{w--.unlisted}{%
\subsubsection{W\{- .unlisted\}\}}\label{w--.unlisted}}

\begin{itemize}
\tightlist
\item
  \protect\hyperlink{while-loop}{While} loop.
\end{itemize}

\end{document}
