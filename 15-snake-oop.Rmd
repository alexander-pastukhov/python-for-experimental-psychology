# Snake game: object-oriented programming {#seminar-02-03}
We will not be programming a new game today. Rather, you will learn about object-oriented approach in Python and will use it to simplify your code of the Snake game that you already programmed. Yes, it would be more fun to program a new game but this way you get to concentrate on the concepts rather than on the game logic.

## Object-oriented programming
The core idea is in the name: Instead of having variables/data and functions separately, you combine them in an object that has properties (its own variables) and methods (functions). This approach uses our natural tendency to perceive the world as a collection of interacting objects and has several advantages that I will discuss below.

### Classes and objects (instances of classes)
Before we continue, I need to make an important distinction between _classes_ and _objects_. A _class_ is a "blue print" that describes properties and behavior (methods) of objects of that class. This "blue print" is used  to create an _instance_ of that class, which is called an _object_. For example, Homo sapiens is a _class_ that describes species that have certain properties, such as height, and can do certain things, such as running. However, Homo sapiens as a class only has a concept of height but no specific height by itself. E.g., you cannot ask "What is height of Homo sapiens?" only what is an average (mean, median, etc.) height of individuals of that class. Similarly, you cannot say "Run, Homo sapiens! Run!" as abstract concepts have trouble with real actions like that. Instead, it is Alexander Pastukhov who is an _instance_ of Homo sapiens class with specific height and a specific (not particularly good) ability to run. Other instance of Homo sapiens (other people) will have different height and a different (typically better) ability to run. Thus class describes what kind of properties and methods objects have meaning that whenever you meet a Homo sapien, you could be sure that they have height. However, individual objects have different values for this properties and so calling their methods may result in different outcomes.

Another, a more applied, example would be your use of `ImageStim` class to create multiple instances of front side of a card in "Memory" game. Again, the _class_ defines properties (`image`, `pos`, `size`, etc.) and methods (e.g., method `draw()`) that individual objects will have. You created these objects to serve as front side of cards. You set _different_ values for same property (`pos`) and that ensured that when you call their common method `draw()`, each card was drawn at its own location. 

### Encapsulation
Putting all the data (properties) and behavior (methods) inside the class simplifies programming by ensuring that all relevant information can be found in its definition. This, you have a single place that should have _everything_ that defines object's behavior. Contrast this with our approach in previous two seminars where snake data (e.g., variable `snake`) was defined at one place and functions that used and altered it (e.g., `snake_bit_itself()` or `grow_snake()`) were defined elsewhere. Moreover, we had to resort to using _snake_ in these function names just to remind ourselves that they all belong to the snake. This also necessitated creating functions with multiple arguments that ensured that all information is available within each function. And, we modified `snake` inside the function creating further uncertainty about when and where it can be changed.

## Inheritance / Generalization
In object-oriented programming a class can be derived from some other _ancestor_ class and thus _inherit_ its properties and methods. Moreover, several classes can be derived from a single ancestor producing a mix of unique and shared functionality. This means that instead of rewriting the same code for each class, you can define a common code in an ancestor class and focus on differences in the descendants. 

Using the Homo sapiens example from above. Humans, chimpanzees and gorillas are all different species but we share a common ancestor. Hence, we are different in many respect, yet, you could think about all of us as "apes" that have common properties such as binocular trichromatic vision. Or, you can move further down the evolution tree and think about us as "mammals" that, again, have common properties and behavior, such as thermoregulation and lactation.

Similarly, in PsychoPy various visual stimuli that we used (`ImageStim`, `TextStim`, `Rect`) have same properties (e.g., `pos`, `size`, etc.) and methods (most notably, `draw()`). This is because they are all descendants from a common ancestor `BaseVisualStim` that defines their common properties and methods. This means that you can assume that _any_ visual stimulus (as long as it descends from `BaseVisualStim`) will have `size`, `pos`, `ori` and can be drawn. This, in turn, means that you can have a list of various PsychoPy visual stimuli and move or draw all of them in a single loop without thinking which _specific_ visual stimulus you are moving or drawing.

Note that in Python, where is another way of achieving common behavior without inheritance. It is called "duck typing"^[Yes, it is really called "duck typing".] and it will be the topic of our next seminar.

## Polymorphism
As you've learned in the previous section, inheritance allows different descendants to share common properties and behavior, so that in certain cases you can view them as being like an ancestor. E.g., any visual stimulus can be drawn, so you just call its `draw()` method. However, it is clear that they implement drawing _differently_, as the `Rect` stimulus looks different from the `ImageStim` or `TextStim`. This is called "polymorphism" and the idea is to keep the common interface while abstracting away the actual implementation. This allows you to think about what you want an object to do (or what to do with an object), instead of thinking how exactly you need to implement this.

## A minimal class example
Enough of the theory, let us see how classes are implemented in Python. Here is a very simple class that has nothing but the construction `__init__()` method, which is called whenever a new object (class instance) is created, and a single property `total`.

```python
class Accumulator:
    """
    Simple class that accumulates (sums up) values.

    Properties
    ----------
    total : float
        Total accumulated value
    """

    def __init__(self):
        """
        Constructor, initializes the total value to zero.
        """
        self.total = 0
        
# here we create an object number_sum, which is an instance of class Accumulator.
number_sum = Accumulator()
```

Let's go through it line by line. First line `class Accumulator:` shows that this is a declaration of a `class` whose name is `Accumulator`. Note that the first letter is capitalized. This is not required per se, so Python police won't be knocking on your door if you write it all in lowercase. However, the general recommendation is that **class** names are written using `UpperCaseCamelCase` whereas **object** (instances of the class) names are written using `lower_case_snake_case`. This makes distinguishing between classes and objects easier, so you should follow this convention.

The definition of the class are the remaining _indented_ lines. As with functions or loops, it is the indentation that defines what is inside and what is outside of the class. The only method we defined is `def __init__(self):`. This is a _special_ method^[There are more special methods that you will learn about alter, they all follow `__methodname__()` convention.] that is called when an object (instance of the class) is created. This allows you to  setup the object based on parameters that were passed to this function (if any). You do not call this function directly, rather it is called whenever an object is created, _e.g._ `number_sum = Accumulator()` (last line). Also, it does not return any value explicitly via `return`. Instead as `self` (the very first parameter) is returned automatically.

All class methods (apart from special cases we currently do not concern ourselves with) must have one special first parameter that is _the object_ itself. By convention it is called `self`. Technically, you can use any name but that will surely confuse everyone. It is passed to the method automatically, so whenever you write `square.draw()` (no explicit parameters passed in the function call), the actual method still received one parameter that is the reference to the `square` variable whose method you called. Inside a method, you use this variable to refer to the object itself. Thus, in the constructor, we add a new _persistent_ property to the object by assigning a value to it, as in `self.total = 0`. It is _persistent_, because even though we created it inside the method, we assigned it to the object itself. Now you can use access this property either from inside `self.total` or from outside `number_sum.total`. You can think of properties as being similar to field/value pairs in the dictionary we used during previous seminar but for syntax: `object.property` versus `dictonary["field"]`. Technically, you can create new properties in any method or even from outside (e.g., nothing prevents you from writing `number_sum.color = "red"`). However, this makes understand the code much harder, so the general recommendation is to create _all_ properties  inside the constructor (`__init__()`) method, even if this means assigning  `None` to them^[If you use a linter, it will complain whenever it sees a property not defined in the constructor].


## GridWindow

