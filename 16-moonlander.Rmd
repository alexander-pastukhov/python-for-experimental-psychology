# Moon lander game {#seminar-02-04}

## Create window

* create window
* main loop with gameover and exit via "Escape"


## Create MoonLander class

* create visuals via ImageStim
* `draw()` method. Remember, a class method must have at least _one_ parameter, which one?

Create lander object and draw it in the main loop


## Randomize position
New method `reset()` that will reset the lander for the next round. Currently, it will only randomize position of the image. Use range of -1..1 horizontally and 0.8..0.9 vertically.

Call it in the constructor (`__init__()`) and test it in the main loop by calling it every time you press "space" button.

## Gravity
Constant `GRAVITY = 9.81 / 30000`^[The constant itself does not mean anything, I adjusted it to be reasonable for the image and window size that we are using.]
New attribute `speed = [0, 0]` that is horizontal and vertical speed of the lander. On each frame, its position (`self.image.pos`) is adjusted based on the the speed. But before that, speed itself must be adjusted based on the forces from gravity and thrusters. Create a new method `update()` where you first adjust _vertical_ speed based on gravity (it becomes more negative due to it) and when adjust _vertical_ position based on vertical speed (we will worry about the horizontal speed, once we start working on horizontal thrusters). Call `update()` method before the `draw()` in the main loop. Your lander fall down at accelerated rate. Once it is off the screen, press space and see it go again.

## Vertical thurster
PsychoPy allows to get key presses or, using [hardware.keyboard](https://www.psychopy.org/api/hardware/keyboard.html) to get both press and release time. However, in our game, the thursters must be active for as long as the player presses the key. Thus, we need to know whether a key is _currently_ pressed, not that it was pressed and released at some time in the past. For this, we will use _pyglet_ library (that is used by PsychoPy)  directly. First, in your _moonlander.py_ add `import pyglet` and then include this code inside the constructor of the class.

```python
# setting up keyboard monitoring
self.key = pyglet.window.key
self.keyboard = self.key.KeyStateHandler()
win.winHandle.push_handlers(self.keyboard)
```

This installs a "handler" that monitors the state of the keyboard. Now, you can read out the state of, say, _down arrow_ key as`self.keyboard[self.key.DOWN]` (`True` if pressed, `False` other). We will use `DOWN` for the vertical thruster and `LEFT` and `RIGHT` for the horizontal ones.

Define a `VERTICAL_ACC` to be twice and update the `update()`^[Pun intended.], so that the total vertical acceleration is `VERTICAL_ACC + GRAVITY` if the the user is pressing _down_ key (use `self.keyboard` and `self.key` to figure that out) but `GRAVITY` alone, if not.

Test you that vertical thruster works!

## Horizontal thursters
Now implement the same logic, computing acceleration, speed, and position but for horizontal thrusters (define `HORIZONTAL_ACC`, decide on its value yourself). Remember, the _right_ thruster pushes the lander to the _left_ and vice versa! Assume that only one of the keys (_left_ or _right_) can be pressed at a time. Test it by flying around!

## Landing pad: visuals
The purpose of the game is to land on a landing pad. Let us add one! Create a new file _landing_pad.py_ and a new class `LandingPad`. In the constructor, create a rectangle that is `0.5` units wide and is located at the bottom of the window vertically but at a random position within window horizontally. Pick the fill and line colors that you like. The only other method the class needs is `draw()`. 

In the main code, create an object of class `LandingPad` and draw it in the main loop, along with the lander itself.

## Computing edges of game objects
The aim of the game is a soft touchdown on a landing pad. For this, we need to know where the _top_ of the landing pad is, as well as where the _bottom_ of the lander is and where _left_ and _right_ limits of each object are. Let us think about _top_ of the landing pad first, as the rest are very similar.

We do not have information about it _directly_. We have the vertical position of the landing pad in `self.image.pos[1]` (I assume here that the visuals attribute is called image) and its height in `self.image.size[1]`. From this, it is easy to compute the top edge (but remember that position is about the _center_ of the rectangle). Accordingly, you could create a method called `top()` that would return the computed value when it is called (e.g., `pad.top()`). 

## Virtual attributes via getters and setters
Our approach of using `pad.top()` works but it is _semantically_ inconsistent. Calling methods is about manipulating objects, e.g., drawing them, updating them, comparing them. However, `top` is, effectively, an _attribute_ of an object, like its position or size, it is just where the top of it is. We _could_ create and compute a `top` attribute inside the constructor, solving the problem of semantics, as now you could write `pad.top`. However, things are more involved with the lander, as it moves so all of its edge attributes (`bottom`, `left` and `right`) need to be recomputed after every update. This is unavoidable but a _real_ attribute approach still creates another problem: What if someone _changes_ it? In that case, its value will not be correct, as `top` value depends on both position and size, so changing it without a corresponding change in those two attributes makes no sense! And it is really hard to decide whether change in the `top` should mean a change in position, or size, or, perhaps, both? Thus, ideally, it should be read-only  attribute.

For cases like these, Python has special _decorators_^[These are functions that "decorate" you function and are called _before_ your function is called. They can control how and whether it is executed. They are very useful in certain scenarios and we will meet them again later. However, we will not talk about them in detail here.]: `@property` and `@<name>.setter`. The former one decorates a method that allows you to _get_ an attribute's value and, typically, is called a "getter". The latter one, is for a "setter" method that _sets_ a new value to an attribute. The idea is to isolate an actual attribute value from the outside influence. It is particularly helpful, if you need to control whether a new value of an attribute is a valid one, needs to converted, etc. For example, `color` attribute of rectangle stimulus uses this approach, which is why it can take RGB triplets, hexadecimal codes, or plain color names as value and set the color.

Here is a sketch of how it could work but note that today, we will only use the _getter_ bit. To have a virtual attribute for `color`, one typically creates an _internal_ attribute with almost the same name, e.g., `_color` or `__color` (see below for the difference). The value is stored and read from that internal attribute by getter and setter  methods:
```python
class ExampleClass:

  def __init__(self):
    self.__color = "red"

  @property
  def color(self):
    """
    This is a getter method for virtual color
    attribute.
    """
    # Here, we simply return the value. But we could 
    # compute it from some other attributes instead.
    return self.__color
    
  @color.setter # not the most elegant syntax
  def color(self, newvalue):
    """
    Note that the setter name has THE SAME name!
    It sets a new value and does not return anything.
    """
  
    # Here, you can have checks, conversion, 
    # additional changes to other attributes, etc.
    self.__color = newvalue
    
    
example = ExampleClass()

# get the value, note the lack of () after color
print(example.color)

# set the value
example.color = "blue"
```

Note that there is no _actual_ attribute `color`, yet, our code works as if it does exist. 

There is another twist to the story. If you only define the getter `@property` method but no setter method, your property is read-only^[Note that you cannot have write-only property, you must have either getter alone or both.]! And this exactly what we wanted. Turning out `top()` method into a getter of an attribute is as easy as adding the `@property` decorator to it. After that, we can use it as a read-only attribute `pad.top`. Do this and also create similar read-only attributes for `left` and `right` of the pad and for `bottom`, `left`, and `right` of the lander class.

## Access restrictions
In the example on getter/setter methods, I used `__color` name with two leading underscores. This is a Python way to make things (almost) private, that is, invisible from outside. If you copy-paste the class code from above and try to access the attribute directly via `example.__color`, you will get an error "'ExampleClass' object has no attribute '__color'". However, as I wrote, it is _almost_ private, so you still can access it! The code format is `object._<ClassName><hidden attribute name>`, so in our case `example._ExampleClass__color`^[Try it and see that it works.]. However, this is a last resort sort of thing that you should use only if you absolutely must access that attribute and, hopefully, know what you doing.
  
You can also come across attributes with a _single_ leading underscore in the name, e.g. `_color`. These are not private and are fully visible. However, the leading underscore _hints_ that this attribute or method should be _considered_ private. So, if you see an attribute like `_color`, you should pretend that you know not of its existence and, therefore, you never read or modify it directly. Of course, this is only an _agreement_, so you can always ignore it and work with that attribute directly^[On a side note of doing crazy things that you shouldn't: You can replace a class method with your own at run time, this is called "monkey patching".]. However, this almost certainly will break the code in unexpected and hard-to-trace ways.

